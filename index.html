<!DOCTYPE html>

<html lang="sv">
<head>

  <!-- App-lik upplevelse / PWA -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Dart-turnering</title>
<style>
    
    
html, body { height: 100%; }
body { padding-bottom: 1px; }
/* Hide progress pill (x / y klara) */
    #progressPill{display:none!important;}
:root{
            --accent: var(--primary);
--bg:#f4f6f8; --card:#fff; --ink:#111827; --muted:#6b7280;
      --primary:#2563eb; --primary-ink:#fff; --border:#e5e7eb;
      --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
          --matchTitleSize: clamp(22px, 4.8vw, 30px);
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;margin:0;background:var(--bg);color:var(--ink)}
    header{background:linear-gradient(180deg,#0b1220,#111827);color:#fff;padding:18px 16px;text-align:center}
    header h1{margin:0;font-size:28px;letter-spacing:0.2px}
    header p{margin:6px 0 0;color:rgba(255,255,255,.8);font-size:13px}
    main{padding:14px;max-width:980px;margin:0 auto 32px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 6px 16px rgba(0,0,0,.05)}
    .card h2{margin:0 0 10px;font-size:18px}
    .card h3{margin:14px 0 8px;font-size:15px}
    .grow{flex:1 1 320px}
    label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
    input, select, textarea{
      width:100%; padding:11px 12px; font-size:16px; border:1px solid var(--border);
      border-radius:12px; outline:none; background:#fff;
    }
    textarea{resize:vertical}
    input:focus, select:focus, textarea:focus{border-color:#c7d2fe; box-shadow:0 0 0 4px rgba(99,102,241,.12)}
    .btnbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      padding:11px 12px; font-size:15px; border-radius:12px; border:1px solid transparent;
      cursor:pointer;
    }
    .btn{background:var(--primary);color:var(--primary-ink)}
    .btn:hover{filter:brightness(.98)}
    .btn.secondary{background:#fff;color:var(--ink);border-color:var(--border)}
    .btn.danger{background:#fff;color:var(--danger);border-color:#fecaca}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted)}
    .pill strong{color:var(--ink)}
    .hidden{display:none !important}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{padding:10px 10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:middle}
    th{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.06em}
    tr.played{background:#eef2ff}
    .matchRow{cursor:pointer}

    #matchesTable th:first-child,#matchesTable td:first-child{width:72%}
    #matchesTable th:last-child,#matchesTable td:last-child{width:28%;white-space:nowrap}
    .matchMeta{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);white-space:nowrap;display:inline-flex;align-items:center;gap:4px;}
    .tag.ok{border-color:#bbf7d0;color:var(--ok);background:#f0fdf4}
    .tag.todo{border-color:#e5e7eb;color:var(--muted);background:#fafafa}
    .split{display:flex;gap:10px;flex-wrap:wrap}
    .split > div{flex:1 1 220px}
    .hint{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.35}
    label.statRow{display:flex;justify-content:space-between;align-items:baseline;gap:10px}
    .stepper{display:flex;gap:8px;flex-wrap:wrap;margin:12px 0}
    .step{padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted)}
    .step.active{background:#111827;color:#fff;border-color:#111827}
    .grid2{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width: 860px){ .grid2{grid-template-columns: 1.2fr .8fr} }
    /* Modal */
    .overlay{position:fixed;inset:0;background:rgba(17,24,39,.55);display:flex;align-items:flex-end;justify-content:center;padding:14px}
    .modal{width:min(680px,100%);background:#fff;border-radius:18px;border:1px solid var(--border);box-shadow:0 20px 60px rgba(0,0,0,.25);padding:14px}
    @media (min-width: 640px){ .overlay{align-items:center} }
    .modal h2{margin:0 0 10px;font-size:var(--matchTitleSize);line-height:1.1}
    .modal .top{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
.topActions{display:flex;flex-direction:column;gap:6px;align-items:flex-end}
.topActions .btn{padding:6px 10px}

    .x{background:#fff;border:1px solid var(--border);border-radius:12px;padding:8px 10px}
    .winBtns{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
    .winBtn{padding:12px;border-radius:14px;border:1px solid var(--border);background:#fff;font-weight:600}
    .winBtn.primary{border-color:#93c5fd;background:#eff6ff}

    /* Byt sida i matchmodal (A/B v√§nster/h√∂ger) */
    #matchModal.swapped .winBtns{direction:rtl;}
    #matchModal.swapped .winBtn{direction:ltr;}
    #matchModal.swapped .split{flex-direction:row-reverse;}

    .small{font-size:12px;color:var(--muted)}

    body.modal-open{overflow:hidden}
    .overlay{align-items:center; overflow:auto}
    .modal{max-height:90vh; overflow:auto; -webkit-overflow-scrolling:touch}
    .modal .top{position:sticky; top:0; background:#fff; padding-top:4px; z-index:2}

    /* Bracket */
    .bracket{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width: 860px){ .bracket{grid-template-columns: 1fr 1fr 1fr} }
    .roundCol h3{margin:0 0 8px}
    .matchCard{border:1px solid var(--border);border-radius:14px;padding:8px;background:#fff}
    .matchCard .name{display:flex;justify-content:space-between;gap:8px;padding:6px 8px;border-radius:12px;border:1px solid var(--border);margin-top:6px}
    .matchCard .name.win{border-color:#bbf7d0;background:#f0fdf4}
    .footerSpace{height:16px}
  
  .link{color:var(--accent);text-decoration:underline;word-break:break-all;}

  @media print{
        header, .stepper, .btnbar, .overlay, .pill, .btn, textarea, input, select { display:none !important; }
    button:not(.clickableName){ display:none !important; }
    /* Visa spelarnamn i PDF (de √§r klickbara knappar i tabellen) */
    button.clickableName{ display:inline !important; background:transparent !important; border:0 !important; padding:0 !important; margin:0 !important; color:#000 !important; font:inherit !important; text-decoration:underline; }

    /* Visa spelarnamn i PDF (de √§r klickbara knappar i tabellen) */
    /* Men l√•t spelarnamn synas i PDF */    body{ background:#fff !important; }
    main{ padding:0 !important; max-width:none !important; }
    .card{ box-shadow:none !important; border:1px solid #ddd !important; margin:0 0 12px 0 !important; }
    .grid2{ grid-template-columns: 1fr !important; }
    a{ color:#000 !important; text-decoration:underline !important; }
  }


  .qual{background:#e8f7ee !important;}
  .qual td{background:#e8f7ee !important;}
.qual td:first-child{font-weight:700;}
  .qual   .lockedBanner{padding:10px 12px;border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,0.03);margin:8px 0;}
  .clickableName{cursor:pointer;text-decoration:underline;text-decoration-thickness:1px;text-underline-offset:2px;}

  .linkbtn{background:none;border:none;padding:0;margin:0;color:inherit;font:inherit;cursor:pointer;text-decoration:underline;text-decoration-thickness:1px;text-underline-offset:2px;}

  .namebtn{background:none;border:none;padding:0;margin:0;color:inherit;font:inherit;cursor:pointer;text-decoration:underline;text-decoration-thickness:1px;text-underline-offset:2px;}

/* PRINT (PDF) ‚Äì sammanst√§llning */
#printRoot{display:none}
@media print{
  /* Visa bara printRoot */
  body > :not(#printRoot){display:none !important;}
  #printRoot{display:block !important;}
  .page-break{break-before:page; page-break-before:always}
  .avoid-break{break-inside:avoid; page-break-inside:avoid}
  table{width:100%; border-collapse:collapse; break-inside:avoid; page-break-inside:avoid}
  thead{display:table-header-group}
  tfoot{display:table-footer-group}
  tr{break-inside:avoid; page-break-inside:avoid}
  h1,h2{break-after:avoid; page-break-after:avoid; margin:0 0 8px 0}
  @page{margin:12mm}
}
    /* Checkbox ska inte √§rva input=100% bredd */
    input[type="checkbox"]{
      width:auto !important;
      padding:0 !important;
      border-radius:4px;
      box-shadow:none !important;
    }


/* --- Sportigt, professionellt tema (UI + PDF) --- */
:root{
  --primary:#0B1F3B;          /* navy */
  --primary-ink:#ffffff;
  --accent:#0B1F3B;
  --accent2:#22c55e;          /* sportgr√∂n */
  --bg:#f3f6fb;
  --card:#ffffff;
  --ink:#0b1220;
  --muted:#556070;
  --border:#d7dde6;
  --ok:#22c55e;
  --warn:#f59e0b;
  --danger:#ef4444;
}

header{
  background: linear-gradient(180deg, #071427, #0B1F3B);
}
header h1{ letter-spacing:0.5px; text-transform:uppercase; font-weight:800; }
header p{ color:rgba(255,255,255,.85); }

.card{
  border:1px solid rgba(11,31,59,.10);
}
.btn{
  border-radius:14px;
  box-shadow: 0 10px 24px rgba(11,31,59,.14);
}
.btn.secondary{
  background: rgba(11,31,59,.03);
  border-color: rgba(11,31,59,.14);
}
.btn.secondary:hover{
  background: rgba(11,31,59,.06);
}
.btn.danger{
  background:#fff;
  border-color: rgba(239,68,68,.35);
}
.pill{
  border-color: rgba(34,197,94,.35);
  background: rgba(34,197,94,.08);
  color: #2f3a4a;
}
.pill strong{ color: var(--primary); }

.titleblock{display:flex;flex-direction:column;gap:2px;}

.datestamp{
  font-size:12px;
  color: var(--muted);
  margin-top:2px;
}

/* Tabeller: b√§ttre l√§sbarhet */
table{
  border-radius:12px;
  overflow:hidden;
}
thead th{
  background: rgba(11,31,59,.06);
}
tbody tr:nth-child(even){
  background: rgba(11,31,59,.03);
}

/* Tabell: spelare (placering + avatar + namn p√• en rad) */
.standingsPlayerCell{
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;
  white-space:nowrap;
}
.standingsPlayerCell .avatarBtn{
  flex:0 0 auto;
}
.standingsNameBtn{
  display:inline-block;
  max-width: 14ch;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
  vertical-align:bottom;
}

/* PDF header */
@media print{
  .print-header{
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    margin:0 0 10px 0;
    padding:0 0 8px 0;
    border-bottom:2px solid rgba(11,31,59,.25);
  }
  .print-title{
    font-size:16pt;
    font-weight:800;
    letter-spacing:0.5px;
    text-transform:uppercase;
    color:#0B1F3B;
  }
  .print-meta{
    font-size:10pt;
    color:#334155;
  }
  .print-date-inline{
    font-size:10pt;
    font-weight:500;
    color:#334155;
    margin-left:8px;
  }
  h1{
    color:#0B1F3B;
  }
}


/* Initial-avatar f√∂r spelare */
.playerBadge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:26px;
  height:26px;
  border-radius:50%;
  background:#1f7a4f;
  color:#fff;
  font-weight:600;
  font-size:14px;
  margin-right:8px;
  flex-shrink:0;
}


/* Profil-avatar (initial) */
.playerHeader{display:flex;align-items:center;gap:10px;margin:0 0 6px 0;}
.playerAvatar{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:42px;
  height:42px;
  border-radius:50%;
  background:#1f7a4f;
  color:#fff;
  font-weight:700;
  font-size:20px;
  flex-shrink:0;
}


    .sliderWrap{margin-top:6px}
    .sliderWrap .statLabel{display:flex;justify-content:space-between;gap:10px;align-items:baseline}
    .sliderWrap input[type=range]{width:100%}

/* Slider value bubble */
.sliderBox{position:relative; padding-top:clamp(42px, 7vw, 56px);}
.sliderBubble{
  position:absolute;
  top:0;
  left:50%;
  transform:translateX(-50%);
  padding:6px 14px;
  border-radius:999px;
  background:#0c2340;
  color:#fff;
  font-size:var(--matchTitleSize);
  font-weight:700;
  line-height:1.1;
  max-width:90%;
  text-align:center;
  white-space:nowrap;
  pointer-events:none;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}



/* --- Slutspelstr√§d (bracket-canvas: Semis + Final, redo f√∂r Kvarts i framtiden) --- */
#playoffsBracket{
  position:relative;
  border-radius:18px;
  background:#f7f9fc;
  border:1px solid #eef1f6;
  padding:14px;
  overflow:hidden;            /* visa hela bracket utan scroll */
  -webkit-overflow-scrolling: touch;
}
#playoffsBracket::-webkit-scrollbar{ height:10px; }
#playoffsBracket::-webkit-scrollbar-thumb{ background:#dbe3ef; border-radius:10px; }

#playoffsBracket .bracketLines{
  position:absolute;
  left:0; top:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#playoffsBracketInner{
  position:relative;
  min-width:620px;           /* s√• det faktiskt ser ut som ett tr√§d p√• mobil */
  padding:6px;
  width:100%;
  min-width:0;
}
.bracketGrid4{
  display:grid;
  grid-template-columns: 240px 1fr;
  grid-template-rows: auto auto;
  column-gap: 16px;
  row-gap: 18px;
  align-items:center;
}
.bracketCell{ position:relative; }
.bracketCell.qf{
  grid-column:1;
  grid-row:1 / span 4;
  align-self:stretch;
  display:flex;
  flex-direction:column;
  gap:12px;
}
.bracketCell.final{ grid-column:2; grid-row:1 / span 2; align-self:center; }
.bracketCell.sf1{ grid-column:1; grid-row:1; align-self:start; }
.bracketCell.sf2{ grid-column:1; grid-row:2; align-self:end; }

/* 4 grupper: QF + SF + Final i tre kolumner */
#playoffsBracketInner.hasQF{ min-width: 880px; }
#playoffsBracketInner.hasQF .bracketGrid4{
  grid-template-columns: 280px 240px 1fr;
  grid-template-rows: repeat(4, auto);
  row-gap: 18px;
  align-items: stretch;
}
#playoffsBracketInner.hasQF .bracketCell.qf{ grid-column:1; grid-row:1 / span 4; }
#playoffsBracketInner.hasQF .bracketCell.sf1{ grid-column:2; grid-row:1 / span 2; align-self:center; }
#playoffsBracketInner.hasQF .bracketCell.sf2{ grid-column:2; grid-row:3 / span 2; align-self:center; }
#playoffsBracketInner.hasQF .bracketCell.final{ grid-column:3; grid-row:1 / span 4; align-self:center; }

/* Knockout med kval: extra kolumn l√§ngst till v√§nster */
#playoffsBracketInner.hasQUAL{ min-width: 980px; }
#playoffsBracketInner.hasQUAL .bracketGrid4{
  grid-template-columns: 240px 240px 1fr;
  grid-template-rows: repeat(4, auto);
  row-gap: 18px;
  align-items: stretch;
}
#playoffsBracketInner.hasQUAL .bracketCell.qual{ grid-column:1; grid-row:1 / span 4; align-self:stretch; display:flex; flex-direction:column; justify-content:space-between; gap:14px; }
#playoffsBracketInner.hasQUAL .bracketCell.sf1{ grid-column:2; grid-row:1 / span 2; align-self:center; }
#playoffsBracketInner.hasQUAL .bracketCell.sf2{ grid-column:2; grid-row:3 / span 2; align-self:center; }
#playoffsBracketInner.hasQUAL .bracketCell.final{ grid-column:3; grid-row:1 / span 4; align-self:center; }

/* Knockout med kval + kvarts: 4 kolumner */
#playoffsBracketInner.hasQUAL.hasQF{ min-width: 1180px; }
#playoffsBracketInner.hasQUAL.hasQF .bracketGrid4{
  grid-template-columns: 240px 280px 240px 1fr;
  grid-template-rows: repeat(4, auto);
  row-gap: 18px;
  align-items: stretch;
}
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.qual{ grid-column:1; grid-row:1 / span 4; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.qf{ grid-column:2; grid-row:1 / span 4; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.sf1{ grid-column:3; grid-row:1 / span 2; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.sf2{ grid-column:3; grid-row:3 / span 2; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.final{ grid-column:4; grid-row:1 / span 4; }


.finalWrap{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:nowrap;
}
.trophyCircle{
  width:48px;
  height:48px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#f1f3f7;
  border:1px solid #e6ebf3;
  font-size:22px;
  flex:0 0 auto;
}

.winnerAvatar{
  flex:0 0 auto;
}
.winnerAvatar .avatarBtn{
  pointer-events:none;
}
.winnerBox{
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid #e6ebf3;
  background:#fff;
  box-shadow: 0 6px 18px rgba(15,23,42,.06);
  max-width:260px;
  flex:0 0 auto;
}
.winnerBox.hasWinner{
  border-color:#bbf7d0;
  background:#f0fdf4;
}
.winnerText{
  display:flex;
  flex-direction:column;
  gap:2px;
  font-weight:800;
  line-height:1.15;
}
.winnerLabel{
  font-weight:800;
  font-size:12px;
  opacity:.85;
}
.winnerValue{
  font-weight:900;
}
.winnerText .winnerNameTxt{
  font-weight:900;
}


.bracketBox{
  background:#ffffff;
  border:1px solid #eef1f6;
  border-radius:16px;
  box-shadow: 0 10px 30px rgba(15,23,42,.06);
  overflow:hidden;
  cursor:pointer;
  user-select:none;
}


/* Steg 6: F√∂rberedd bracket-struktur anv√§nder bracketMatchBox/bracketTitle.
   Mappa dem till befintlig bracketBox-styling s√• att boxarna alltid renderas snyggt. */
.bracketMatchBox{
  background:#ffffff;
  border:1px solid #eef1f6;
  border-radius:16px;
  box-shadow: 0 10px 30px rgba(15,23,42,.06);
  overflow:hidden;
  cursor:pointer;
  user-select:none;
}
.bracketTitle{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  border-bottom:1px solid #f0f3f8;
  font-weight:800;
}
.bracketBoxHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  border-bottom:1px solid #f0f3f8;
}
.bracketBoxTitle{
  font-weight:800;
}
.bracketPill{
  font-size:12px;
  padding:5px 9px;
  border-radius:999px;
  border:1px solid #e6ebf3;
  background:#f7f9fc;
}
.bracketBody{ padding:8px 10px 10px 10px; display:flex; flex-direction:column; gap:6px; }
.bracketRow{
  padding:7px 10px;
  border-radius:10px;
  background:#f7f9fc;
  font-weight:800;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.bracketRow.winnerRow{
  background:#f0fdf4;
  border:1px solid #bbf7d0;
}
.winnerName{
  color: var(--ok);
}

.bracketRow .mutedName{ font-weight:700; opacity:.55; }
.bracketScore{
  font-weight:900;
  letter-spacing:.5px;
}
.bracketHint{
  margin-top:8px;
  font-size:13px;
  color:#667085;
}

@media (max-width: 720px){
/* P√• sm√• sk√§rmar kan linjer bli r√∂riga ‚Äì men vi visar dem √§nd√• */
  #playoffsBracket .bracketLines{ opacity:.9; }
  .trophyCircle{ width:56px; height:56px; font-size:24px; }
}

/* --- Kompakt bracket-rutor (visa namn + po√§ng, ingen extra rubrik/pill) --- */
.bracketBoxHeader{ display:none !important; }
.bracketBody{ padding:8px 10px !important; gap:6px !important; }
.bracketRow{ padding:8px 10px !important; }
.bracketScore{ font-size:16px !important; }


/* --- Bracket (slutspelstr√§d) layout tweaks v77 --- */
#playoffsBracketViewport{
  overflow-x: auto !important;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
}
#playoffsBracketCanvas{
  min-width: 640px; /* allow full tree on small screens */
}
.bracketBox{
  width: 220px; /* narrower boxes so final fits more often */
  max-width: 220px;
}
.bracketBox .brRow{
  display:flex;
  align-items:center;
  justify-content:flex-start; /* keep score close */
  gap: 10px;
  padding: 10px 12px;
}
.bracketBox .brName{
  flex: 0 1 auto;
  min-width: 0;
}
.bracketBox .brScore{
  flex: 0 0 auto;
  margin-left: auto; /* keep a small separation, but within narrow width */
}
/* Make final box slightly narrower too */
.bracketBox.brFinal{
  width: 210px;
  max-width: 210px;
}


/* --- Bracket layout tweaks v78 (smalare rutor + scroll tillbaka) --- */
#playoffsBracket{
  overflow-x: auto !important;
  overflow-y: hidden !important;
  -webkit-overflow-scrolling: touch;
}
#playoffsBracketInner{
  min-width: 640px; /* l√•t finalen f√• plats p√• sm√• sk√§rmar */
  padding-right: 18px; /* lite luft s√• sista rutan inte klipps */
}
/* Smalare matchrutor */
.bracketMatch{ width: 190px !important; max-width: 190px !important; }
/* G√∂r po√§ngen n√§rmare namnet och minska intern padding */
.bracketBody{ padding:8px 10px !important; }
.bracketRow{
  padding:8px 10px !important;
  justify-content:flex-start !important;
}
.bracketScore{
  margin-left:auto !important;
  font-size:16px !important;
}


/* --- Bracket polish v79 (smalare rutor, pokal l√§ngst h√∂ger, snabbknappar) --- */
.bracketNav{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin: 0 0 10px 0;
}
.bracketNavBtn{ padding:10px 14px; border-radius:999px; }
.finalWrap{ width:100%; }
.trophyCircle{ margin-left:auto; } /* put trophy at far right */

.bracketBox{
  width: 180px;           /* kortare rutor */
  max-width: 180px;
}
.bracketRow{
  display:flex;
  align-items:center;
  gap:10px;
  padding:8px 10px;
  justify-content:flex-start; /* inte space-between */
}
.bracketRow > div:first-child{
  flex:1 1 auto;
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.bracketScore{
  flex:0 0 auto;
  margin-left:auto; /* h√•ll √•t h√∂ger men n√§ra pga smal ruta */
}


/* bracketLines inside inner v80 */
#playoffsBracketInner{ position:relative; }
#playoffsBracketSvg.bracketLines{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }

/* Player modal: close button bottom-right (mobile friendly) */
.modalCloseBottom{
  position: sticky;
  bottom: 12px;
  display: flex;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 8px;
}

/* ===== Steg 5: Modal f√∂r "Ny spelare" ===== */
.modalOverlay{
  position:fixed; inset:0;
  background:rgba(10,20,35,.45);
  display:flex; align-items:center; justify-content:center;
  padding:16px;
  z-index:9999;
}
.modalOverlay.hidden{ display:none !important; }
.modalSheet{
  width:min(560px, 100%);
  background:#fff;
  border-radius:18px;
  box-shadow:0 18px 60px rgba(0,0,0,.22);
  border:1px solid #e9eef6;
  padding:14px 14px 16px 14px;
}

/* Multi-v√§ljare (Spelare) */
.multiPickList{display:flex;flex-direction:column;gap:10px;margin-top:10px}
.multiPickItem{display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px solid var(--border);border-radius:14px}
.multiPickItem input{width:20px;height:20px}
.multiPickItem .name{font-weight:600}
.multiPickItem .sub{font-size:12px;color:#6b7280}
.modalHeader{
  display:flex; align-items:center; justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
}
.modalHeader h3{ margin:0; }
.modalSub{ margin:0 0 10px 0; color:#6b7280; font-size:14px; }

/* Statsimport (ChatGPT JSON) */
.statsImportCard{ margin-top:10px; padding:12px; border:1px dashed var(--border); border-radius:14px; background:rgba(255,255,255,0.03); }
.statsImportHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.statsImportTitle{ font-weight:700; }
.statsImportPanel{ margin-top:10px; }
.statsImportPanel textarea{ width:100%; min-height:120px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }

/* Slutspel: tydlig visuell signal n√§r gruppspelet √§r klart */
#btnStartPlayoffs.ready{
  box-shadow: 0 0 0 3px rgba(34,197,94,0.18);
  border-color: rgba(34,197,94,0.55);
}
.statsImportStatus{ margin-top:8px; font-size:12px; color:var(--muted); }
.statsImportStatus.ok{ color:#34d399; }
.statsImportStatus.err{ color:#f87171; }


/* Knockout bracket (dynamic columns incl. kval) */
.koBracket{display:flex;gap:16px;align-items:flex-start;padding:6px;min-width:0;}
.koCol{min-width:240px;max-width:280px;display:flex;flex-direction:column;gap:12px;}
.koColTitle{font-weight:800;color:var(--ink);margin:4px 6px 2px;}
@media (max-width:600px){
  .koCol{min-width:220px;max-width:260px;}
}

    
    
    /* --- Startsk√§rm: statisk darttavla (SVG) --- */
    .startHero{
      position: relative;
      width: 100%;
      max-width: 420px;
      height: 230px;
      margin: 12px auto 14px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .startHero .boardWrap{
      position: relative;
      width: 190px;
      height: 190px;
      filter: drop-shadow(0 10px 26px rgba(0,0,0,0.14));
    }
    .startHero svg{ width:100%; height:100%; display:block; }

    /* --- Startsk√§rm: centrerad rubrik + statisk darttavla + startknapp l√§ngst ner --- */
    #startScreen .panel{
      display:flex;
      flex-direction:column;
    }
    #startScreen .panel > h2{
      text-align:center;
      margin-bottom:10px;
    }
    #startScreen .panel .row{
      justify-content:center;
      margin-top:auto;
    }



    /* --- Typografi: st√∂rre och snyggare rubrik p√• startsidan --- */
    #startScreen .panel > h2{
      font-family: "Poppins", "Montserrat", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      font-size: clamp(28px, 6vw, 38px);
      letter-spacing: 0.08em;
      font-weight: 700;
      text-transform: uppercase;
      color: #0b1d3a;
      margin-bottom: 14px;
    }


    /* Topp-rubrik (app-header) lite kraftigare */
    .appHeader h1, .appHeader .title{
      font-family: "Poppins", "Montserrat", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      letter-spacing: 0.1em;
      font-weight: 700;
    }

</style>
<!-- Anti pull-to-refresh (minskar risken p√• mobil) -->
<style id="antiPullToRefreshStyle">

html, body { height: 100%; }
body { padding-bottom: 1px; }
html, body{ overscroll-behavior-y: none; }
</style>

<style id="avatarStyles">

html, body { height: 100%; }
body { padding-bottom: 1px; }
/* ---- Avatars (profilbilder) ---- */
.avatarBtn{display:inline-flex;align-items:center;justify-content:center;width:34px;height:34px;border-radius:999px;border:1px solid #e5e7eb;background:#f3f4f6;color:#111827;font-weight:800;flex:0 0 auto;overflow:hidden;padding:0;cursor:pointer}
.avatarBtn img{width:100%;height:100%;object-fit:cover;display:block}
.avatarBtn.small{width:28px;height:28px}
.avatarBtn.big{width:64px;height:64px}
.avatarBtn:active{transform:scale(0.98)}
.avatarReadOnly{cursor:default;pointer-events:none}
.avatarReadOnly:active{transform:none}
.avatarRow{display:flex;align-items:flex-start;gap:10px;min-width:0}
.avatarMeta{min-width:0}
#avatarOverlay{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:9999}
#avatarModal{width:min(520px,92vw);background:#fff;border-radius:18px;box-shadow:0 25px 80px rgba(0,0,0,.25);padding:14px}
#avatarModal h3{margin:0 0 8px 0}
#avatarCropWrap{display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start}
#avatarCanvasWrap{width:260px;height:260px;border-radius:16px;border:1px solid #eef1f6;background:#f8fafc;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
#avatarCanvas{width:260px;height:260px}
#avatarHint{font-size:13px}


    /* Matchmodal-titel: avatar + namn */
    .matchTitleRow{display:inline-flex;align-items:center;gap:10px;flex-wrap:wrap}
    .matchTitleName{font-weight:800}
    .matchTitleVs{opacity:.65;margin:0 2px;font-weight:700}
</style>


<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 200vh; /* g√∂r sidan h√∂g s√• Chrome kan g√∂mma adressf√§ltet */
  }
</style>


<style>
</style>

</head>
<body>
<div aria-hidden="true" id="focusSink" style="position:fixed;left:-10000px;top:0;width:1px;height:1px;opacity:0;" tabindex="-1"></div>
<!-- Start overlay (forts√§tt/ny/import) -->
<div class="hidden" id="startGate" style="position:fixed;inset:0;background:rgba(0,0,0,0.45);z-index:9999;display:flex;align-items:center;justify-content:center;padding:16px">
<div style="max-width:520px;width:100%;background:var(--card);border:1px solid var(--border);border-radius:18px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,0.2)">
<h3 style="margin:0 0 6px 0">Forts√§tt turnering?</h3>
<div class="small">Det finns en sparad turnering p√• den h√§r enheten.</div>
<div class="btnbar" style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
<button class="btn" onclick="autosaveStartGateContinue()">Forts√§tt</button>
<button class="btn secondary" onclick="autosaveStartGateNew()">Ny turnering</button>
<label class="btn secondary" style="cursor:pointer">Ladda turnering fr√•n fil</label></div>
<div class="hint" style="margin-top:12px">Tips: Exportera turneringen n√§r ni √§r klara f√∂r att arkivera eller flytta den.</div>
</div>
</div>
<header>

  <!-- App-lik upplevelse / PWA -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<h1>Dart-turnering</h1>
</header>
<main><div class="row" style="justify-content:flex-end; margin-bottom:10px"><span class="pill" id="progressPill"><strong>0</strong> / 0 klara</span></div>
<!-- STEP 1: format -->
<section class="card" id="step1">
<h2>V√§lj uppl√§gg</h2>
<label>T√§vlingsform</label><select id="mode"><option selected="" value="single">Singel</option><option value="team">Lag (2-mot-2)</option></select>
<label>Spelform</label><select id="format" onchange="onFormatChange()">
<option value="knockout">Slutspel</option>
<option value="round_robin">Alla m√∂ter alla (serie)</option>
<option value="round_robin_playoffs">Alla m√∂ter alla (serie) + slutspel</option>
<option value="group_only">Gruppspel</option>
<option value="group_playoffs">Gruppspel + slutspel</option>
</select>
<div id="numGroupsWrap" style="display:none">
<label>Antal grupper</label><select id="numGroups">
<option value="2" selected>2 grupper</option>
<option value="4">4 grupper</option>
</select>
</div>

<label>Hur m√•nga g√•nger m√∂ts spelarna?</label><select id="repeat">
<option value="1">1 g√•ng</option>
<option value="2">2 g√•nger</option>
<option value="3">3 g√•nger</option>
</select>

<div class="btnbar">
<button class="btn secondary" type="button" onclick="openFormatLegend()">Uppl√§ggsf√∂rklaring</button>
<button class="btn" onclick="goStep(2)">N√§sta</button>
</div>
</section>
<!-- STEP 2: game -->
<section class="card hidden" id="step2">
<h2>V√§lj spel</h2>
<div class="split">
<div>
<label>Spel</label><select id="game">
<option value="301">301</option>
<option value="501">501</option>
</select>
</div>
<div>
<label>Ing√•ng</label><select id="inRule">
<option value="single">Enkel in</option>
<option value="double">Dubbel in</option>
</select>
</div>
<div>
<label>Utg√•ng</label><select id="outRule">
<option value="single">Enkel ut</option>
<option value="double">Dubbel ut</option>
</select>
</div>
<div>
<label>Matchformat (legs)</label><select id="legsMode">
<option value="single" selected>1 leg</option>
<option value="bo3">B√§st av 3 legs (f√∂rst till 2)</option>
</select>
<div class="hint"><strong>Leg</strong> = en omg√•ng. <strong>Set</strong> = flera leg (anv√§nds inte h√§r √§nnu).</div>
</div>
</div>
<div class="btnbar">
<button class="btn secondary" onclick="goStep(1)">Tillbaka</button>
<button class="btn" onclick="goStep(3)">N√§sta</button>
</div>
</section>
<!-- STEP 3: players -->
<section class="card hidden" id="step3">
<h2>Spelare</h2>
<div class="hint"></div>
<!-- Tidigare fanns en knapp f√∂r "L√§gg till en i taget" h√§r. Vi k√∂r alltid kiosk-l√§ge nu. -->
<div id="entryKioskWrap">
<div class="card" style="box-shadow:none;border:1px solid #eef1f6;margin-bottom:12px">
<h3 id="kioskTitle" style="margin-top:0">L√§gg till spelare</h3>
<div id="kioskSingleForm">
<div id="savedSingleWrap" style="margin:10px 0 6px 0">
<label>V√§lj sparad spelare</label>
<div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
<select id="savedPlayerSelect" style="flex:1;min-width:220px" onchange="savedAutoAddFromSelect('single')"></select>
<button class="btn secondary" id="btnMultiPickPlayers" onclick="openSavedMultiPicker('single')" type="button">V√§lj flera‚Ä¶</button>
<button class="btn secondary" id="btnNewPlayer" onclick="openNewPlayerModal('single')" type="button">Ny / √Ñndra</button>
<button class="btn danger secondary" id="btnDeleteProfileTop" onclick="savedDelete('single')" type="button">Ta bort vald profil</button>
</div>

</div>
<div class="card" style="box-shadow:none;border:1px solid #eef1f6">
<h3 style="margin-top:0">Tillagda</h3>
<div id="kioskList"></div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn primary" id="btnKioskCreateTournament" onclick="createTournament()" style="min-width:220px" type="button">Skapa turnering</button>
</div>
</div>
</div>
<div id="kioskSingleFields" class="hidden">
<label>Namn</label><input id="kName" placeholder="Skriv ditt namn"/>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn secondary" id="btnOpenSpotify" onclick="openSpotify()" type="button">üéµ √ñppna Spotify</button>
</div>
<label style="margin-top:10px">Spotify-l√§nk (valfritt)</label><input id="kSpotify" placeholder="Klistra in Spotify-l√§nk"/>
<label style="margin-top:10px">Pilar (valfritt)</label>
<input id="kDarts" placeholder="Ex: Winmau 22g"/>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn secondary" onclick="modalKioskAddSingle()" type="button">Spara</button>
</div>
</div>
</div>

<div id="kioskTeamFields" class="hidden">
  <label>Lagnamn</label><input id="kTeamName" placeholder="T.ex. Team Rocket"/>
  <div class="grid2" style="margin-top:10px">
    <div>
      <label>Spelare 1</label>
      <input id="kTeamP1" list="singlePlayersList" placeholder="V√§lj eller skriv namn"/>
    </div>
    <div>
      <label>Spelare 2</label>
      <input id="kTeamP2" list="singlePlayersList" placeholder="V√§lj eller skriv namn"/>
    </div>
  </div>
  <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
    <button class="btn secondary" id="btnOpenSpotifyTeam" onclick="openSpotify()" type="button">üéµ √ñppna Spotify</button>
  </div>
  <label style="margin-top:10px">Lagets Spotify-l√§nk (valfritt)</label><input id="kTeamSpotify" placeholder="Klistra in Spotify-l√§nk"/>
  <label style="margin-top:10px">Lagets pilar (valfritt)</label>
  <input id="kTeamDarts" placeholder="Ex: 24g"/>
  <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
    <button class="btn secondary" onclick="modalKioskAddTeam()" type="button">Spara</button>
  </div>
</div>

<datalist id="singlePlayersList"></datalist>

<div class="hidden" id="kioskTeamForm">
  <div id="savedTeamWrap" style="margin:10px 0 6px 0">
    <label>V√§lj sparat lag</label>
    <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
      <select id="savedTeamSelect" style="flex:1;min-width:220px" onchange="savedAutoAddFromSelect('team')"></select>
      <button class="btn secondary" id="btnNewTeam" onclick="openNewPlayerModal('team')" type="button">Ny / √Ñndra</button>
      <button class="btn danger secondary" id="btnDeleteTeamTop" onclick="savedDelete('team')" type="button">Ta bort vald profil</button>
    </div>
  </div>

  <div class="card" style="box-shadow:none;border:1px solid #eef1f6">
    <h3 style="margin-top:0">Tillagda</h3>
    <div id="kioskTeamList"></div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
      <button class="btn primary" id="btnKioskCreateTournamentTeam" onclick="createTournament()" style="min-width:220px" type="button">Skapa turnering</button>
    </div>
  </div>
</div>

<div class="hidden" id="teamFieldsWrap">
<h3 style="margin-top:14px">Lag (2-mot-2)</h3>
<label>Lagnamn (en per rad)</label>
<textarea id="teamNames" placeholder="Team Rocket
Team Viking" rows="5"></textarea>
<div class="grid2">
<div>
<label>Spelare 1 (en per rad)</label>
<textarea id="teamMember1" placeholder="Kalle
Anna" rows="5"></textarea>
</div>
<div>
<label>Spelare 2 (en per rad)</label>
<textarea id="teamMember2" placeholder="Per
Lisa" rows="5"></textarea>
</div>
</div>
<label style="margin-top:10px">Lagets Spotify-l√§nk (valfritt, en per lag)</label>
<textarea id="teamSpotify" placeholder="https://open.spotify.com/track/..." rows="4"></textarea>
<label style="margin-top:10px">Lagets pilar (valfritt, en per lag)</label>
<textarea id="teamDarts" placeholder="24g" rows="3"></textarea>
</div>
<!-- Manuell-l√§ge -->
<div id="manualPlayersWrap">
<div id="legacyImportWrap" style="display:none">
<div class="card" style="box-shadow:none;border:1px solid #eef1f6;margin-bottom:12px">
<h3 style="margin-top:0">Snabbimport (klistra in fr√•n Excel/Sheets)</h3>
<textarea id="bulkPaste" placeholder="1\tPer\tSeven Nation Army ‚Äì The White Stripes\thttps://open.spotify.com/track/...\t23g\n0\tKalle\t\t\t\n1\tJenny\tFreed From Desire ‚Äì Gala\thttps://open.spotify.com/track/...\t22g" rows="6"></textarea>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn" id="btnBulkParse" onclick="bulkParse()" type="button">F√∂rdela i f√§lten</button>
<button class="btn" id="btnBulkClear" onclick="bulkClear()" style="background:#f4f6fb;color:#0f172a" type="button">Rensa</button>
<div class="muted" id="bulkStatus" style="align-self:center"></div>
</div>
</div>
<label>Spelarnamn (en per rad)</label><textarea id="players" placeholder="Spelare 1
Spelare 2
Spelare 3" rows="8"></textarea>
<h3 style="margin-top:14px">Walk-on (visningsnamn) ‚Äì valfritt</h3>
<div class="hint">
    En rad per spelare (i samma ordning). H√§r skriver du bara vilket namn du vill visa i matchen.
  </div>
<textarea id="walkonLabels" placeholder="(valfritt)
L√•ttitel ‚Äì Artist" rows="5"></textarea>
<h3 style="margin-top:14px">Spotify-l√§nk ‚Äì valfritt</h3>
<div class="hint">
    En rad per spelare (i samma ordning). Klistra in en Spotify-l√§nk (t.ex. fr√•n Spotify ‚Üí Dela ‚Üí Kopiera l√§nk).
  </div>
<textarea id="spotifyLinks" placeholder="(valfritt)
https://open.spotify.com/track/..." rows="5"></textarea>
<h3 style="margin-top:14px">Pilar ‚Äì valfritt</h3>
<div class="hint">
    En rad per spelare (i samma ordning). Ex: <em>Winmau 22g</em>
</div>
<textarea id="darts" placeholder="(valfritt)
Winmau 22g" rows="4"></textarea>
</div>
<div class="hint"><span id="minParticipantsText">Minst 3 spelare.</span> F√∂r gruppspel blir 7 spelare perfekt (4+3).</div>
<div class="btnbar" style="margin-top:14px">
<button class="btn secondary" onclick="goStep(2)" type="button">Tillbaka</button>
<button class="btn primary" onclick="createTournament()" type="button">Skapa turnering</button>
</div>

</div>
</div></div></section>
<!-- STEP 4: groups approval -->
<section class="card hidden" id="step4">
<h2>Grupper</h2>

<div class="grid2">
<div class="card" style="box-shadow:none">
<h3>Grupp A</h3>
<div id="groupAList"></div>
</div>
<div class="card" style="box-shadow:none">
<h3>Grupp B</h3>
<div id="groupBList"></div>
</div>
</div>
<div class="card groupCD hidden" style="box-shadow:none">
<h3>Grupp C</h3>
<div id="groupCList"></div>
</div>
<div class="card groupCD hidden" style="box-shadow:none">
<h3>Grupp D</h3>
<div id="groupDList"></div>
</div>

<div class="btnbar">
<button class="btn secondary" onclick="goStep(3)">Tillbaka</button>
<button class="btn secondary" onclick="reshuffleGroups()">Slumpa om</button>
<button class="btn" onclick="confirmGroups()">Godk√§nn grupper</button>
</div>
</section>
<!-- STEP 5: overview -->
<section class="hidden" id="stepMatches">
<div class="card">
<div class="row between" style="align-items:center;gap:10px;">
<div>
<h2 style="margin:0">Matchschema</h2>
<div class="datestamp" id="uiDateMatches"></div>
</div>
<span class="pill" id="rulesPill"></span>
</div>
<div class="hint">Tryck p√• en match f√∂r att registrera vinnare, legs-resultat och averages.</div>
<table id="matchesTable"></table>
</div>
</section>
<section class="hidden" id="stepTable">
<div class="card">
<div class="row between" style="align-items:center;gap:10px;">
<div>
<h2 style="margin:0">Tabell</h2>
<div class="datestamp" id="uiDateTable"></div>
</div>
<span class="pill" id="rulesPillTable"></span>
</div>
<div id="standingsWrap"></div>
<div class="row" style="justify-content:flex-end;margin-top:10px">
  <button class="btn secondary" type="button" onclick="openTableLegend()">Tabellf√∂rklaring</button>
</div>
</div>
</section><section class="card hidden" id="stepTools"><h2>Verktyg</h2><div class="hint">Export, import, PDF och nollst√§llning.</div><div class="row" style="gap:8px; flex-wrap:wrap"><button class="btn secondary" onclick="autosaveExportTournament()">Exportera turnering</button><label class="btn secondary" style="cursor:pointer">Importera turnering <input accept="application/json,.json" hidden="" id="importJson" onchange="autosaveHandleImportJsonFile(this.files[0]); this.value='';" type="file"/></label><button class="btn secondary" onclick="exportPDF()">Exportera (PDF)</button><button class="btn danger" onclick="resetAll()">Nollst√§ll</button></div>

</section>
<!-- STEP 6: playoffs -->
<section class="card hidden" id="stepPlayoffs">
<div class="row" style="align-items:center;justify-content:space-between">
<div class="titleblock"><h2 style="margin:0">Slutspel</h2><div class="datestamp" id="uiDatePlayoffs"></div></div>
<div class="row" style="align-items:center;gap:10px;justify-content:flex-end;flex-wrap:wrap">
<span class="pill" id="playoffsPill" style="display:none"></span>
<button class="btn" id="btnStartPlayoffs" onclick="startPlayoffsFromCurrent()" type="button">Starta slutspel</button>
<button class="btn secondary" id="btnPlayoffsBracketToggle" onclick="togglePlayoffBracket()" type="button">Visa slutspelstr√§d</button>
</div>
</div>
<div id="playoffsScheduleView">
<div class="hint">Semifinaler: A1 vs B2 och B1 vs A2. Vinnarna m√∂ts i final.</div>
<div class="card exportHide" style="margin-top:12px"><div id="tourneySummary"></div></div>
<table id="playoffsTable"></table>
</div>
<div class="hidden" id="playoffsBracketView" style="margin-top:12px">

<div aria-label="Snabbnavigering i slutspelstr√§d" class="bracketNav">
<button class="btn secondary bracketNavBtn hidden" id="btnBracketQual" onclick="scrollPlayoffsBracket('qual')" type="button">Kval</button>
<button class="btn secondary bracketNavBtn" disabled="" onclick="scrollPlayoffsBracket('qf')" type="button">Kvartsfinal</button>
<button class="btn secondary bracketNavBtn" onclick="scrollPlayoffsBracket('sf')" type="button">Semifinal</button>
<button class="btn secondary bracketNavBtn" onclick="scrollPlayoffsBracket('final')" type="button">Final</button>
</div>
<div aria-label="Slutspelstr√§d" id="playoffsBracket">
<div id="playoffsBracketViewport">
<div id="playoffsBracketInner">
<svg class="bracketLines" id="playoffsBracketSvg" xmlns="http://www.w3.org/2000/svg"></svg>
<div id="playoffsBracketContent">
  <!-- F√∂rberedd struktur (kan vara tom initialt). JS fyller i namn/resultat n√§r data finns. -->
  <div class="bracketGrid4">
    
<div class="bracketCell qual hidden">
  <div class="bracketMatchBox" data-po-id="po_k1"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k2"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k3"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k4"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k5"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k6"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k7"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
</div>

<div class="bracketCell qf groupCD hidden">
      <div class="bracketMatchBox" data-po-id="po_qf1"><div class="bracketTitle">Kvartsfinal 1</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
      <div class="bracketMatchBox" data-po-id="po_qf2"><div class="bracketTitle">Kvartsfinal 2</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
      <div class="bracketMatchBox" data-po-id="po_qf3"><div class="bracketTitle">Kvartsfinal 3</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
      <div class="bracketMatchBox" data-po-id="po_qf4"><div class="bracketTitle">Kvartsfinal 4</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
    </div>

    <div class="bracketCell sf1">
      <div class="bracketMatchBox" data-po-id="po_sf1"><div class="bracketTitle">Semifinal 1</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
    </div>
    <div class="bracketCell sf2">
      <div class="bracketMatchBox" data-po-id="po_sf2"><div class="bracketTitle">Semifinal 2</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
    </div>

    <div class="bracketCell final">
      <div class="finalWrap">
        <div class="bracketMatchBox" data-po-id="po_f"><div class="bracketTitle">Final</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">‚Äî</div></div><div class="bracketRow"><div class="mutedName">‚Äî</div></div></div></div>
        <div class="winnerBox"><div class="trophyCircle" title="Vinnare">üèÜ</div><div class="winnerText"><div class="winnerLabel">Vinnare av turneringen</div><div class="winnerValue">‚Äî</div></div></div>
      </div>
    </div>
  </div>
</div>
</div>
</div>
</div>
<div class="btnbar">
<button class="btn secondary" onclick="goStep(getStepNums().table)">Tillbaka</button>
</div>
</div></section>

<!-- Format legend modal -->
<div class="overlay hidden" id="overlayFormatLegend" onclick="closeFormatLegend()">
  <div class="modal" id="formatLegendModal" onclick="stopPropagation(event)" style="max-width:620px">
    <div class="top">
      <div>
        <h2 style="margin:0">Uppl√§ggsf√∂rklaring</h2>
        <div class="small muted">Vad spelformerna betyder just nu i appen</div>
      </div>
      <button class="btn secondary" type="button" onclick="closeFormatLegend()">St√§ng</button>
    </div>
    <div id="formatLegendBody" class="small" style="margin-top:10px; line-height:1.35"></div>
  </div>
</div>

<!-- Table legend modal -->
<div class="overlay hidden" id="overlayTableLegend" onclick="closeTableLegend()">
  <div class="modal" id="tableLegendModal" onclick="stopPropagation(event)" style="max-width:520px">
    <div class="top">
      <div>
        <h2 style="margin:0">Tabellf√∂rklaring</h2>
        <div class="small muted">Po√§ngsystem och f√∂rkortningar</div>
      </div>
      <button class="btn secondary" type="button" onclick="closeTableLegend()">St√§ng</button>
    </div>
    <div id="tableLegendBody" class="small" style="margin-top:10px; line-height:1.35"></div>
  </div>
</div>

<!-- Multi-v√§ljare: v√§lj flera sparade spelare -->
<div class="overlay hidden" id="overlayMultiPick" onclick="closeSavedMultiPicker(true)">
  <div class="modal" id="multiPickModal" onclick="stopPropagation(event)" style="max-width:520px">
    <div class="top">
      <div>
        <h2 style="margin:0">V√§lj flera spelare</h2>
        <div class="small muted">Markera flera och tryck utanf√∂r rutan (eller "Klar")</div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
        <button class="btn secondary" type="button" onclick="closeSavedMultiPicker(false)">Avbryt</button>
        <button class="btn" type="button" onclick="closeSavedMultiPicker(true)">Klar</button>
      </div>
    </div>
    <div id="multiPickList" class="multiPickList"></div>
  </div>
</div>

<!-- Modal -->
<div class="row" style="margin-top:16px; justify-content:center"><div class="stepper" id="stepper"></div></div><div class="overlay hidden" id="overlay" onclick="closeModal()">
<div class="modal" id="matchModal" onclick="stopPropagation(event)">
<div class="top">
<div>
<h2 id="modalTitle">Match</h2>
<div class="small" id="modalMeta"></div>
<div class="lockedBanner hidden" id="lockedBanner">
<div><strong>Match sparad</strong> ‚Äì redigering √§r l√•st f√∂r att undvika misstag.</div>
<div class="btnbar" style="margin-top:8px">
<button class="btn secondary" onclick="enableEdit()">Redigera</button>
</div>
</div>
<div class="hint" id="walkonInfo" style="margin-top:6px"></div>
</div>
<div class="topActions"><button class="btn" onclick="saveMatch()">Spara</button><button class="btn secondary" onclick="clearMatch()">Rensa</button><button class="btn secondary" id="swapSidesBtn" onclick="toggleSides()">Byt sida</button><button class="x" onclick="closeModal()">‚úï</button></div>
</div>
<div class="winBtns">
<button class="winBtn" id="winA" onclick="pickWinner('A')">Vinnare: A</button>
<button class="winBtn" id="winB" onclick="pickWinner('B')">Vinnare: B</button>
</div>
<div class="btnbar" id="resultButtons" style="margin-top:10px"></div>
<div class="hint" id="resultHint" style="margin-top:6px"></div>
<div class="statsImportCard" id="statsImportCard">
  <div class="statsImportHeader">
    <div>
      <div class="statsImportTitle">Importera statistik (JSON)</div>
      <div class="small muted">Klistra in JSON fr√•n ChatGPT eller ladda en .json-fil f√∂r att fylla reglagen automatiskt.</div>
    </div>
    <button class="btn secondary" type="button" onclick="toggleStatsImport()">Visa/D√∂lj</button>
  </div>
  <div class="statsImportPanel hidden" id="statsImportPanel">
    <div style="margin-top:10px">
      <label class="small">JSON</label>
      <textarea id="statsJsonText" placeholder='{"players":{"A":{"name":"","avg":null,"first9":null,"checkoutPct":null},"B":{"name":"","avg":null,"first9":null,"checkoutPct":null}},"meta":{"source":"photo","confidence":0.0}}'></textarea>
    </div>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:10px">
      <button class="btn" type="button" onclick="applyStatsImportFromText()">Anv√§nd JSON</button>
      <label class="btn secondary" style="cursor:pointer">Ladda .json
        <input accept="application/json,.json" hidden type="file" id="statsJsonFile" onchange="applyStatsImportFromFile(this.files[0]); this.value='';"/>
      </label>
      <button class="btn secondary" type="button" onclick="clearStatsImport()">Rensa</button>
    </div>
    <div class="statsImportStatus" id="statsImportStatus"></div>
  </div>
</div>
<div class="split" id="avgSplit" style="margin-top:10px">
<div>
<label class="statRow" id="avgALabel">Average (A) <strong><span id="avgAVal">70.0</span></strong></label><div class="sliderWrap"><div class="sliderBox"><input id="avgA" max="120" min="20" oninput="setStatVal('avgA','avgAVal',1)" step="0.5" type="range" value="70.0"/><div class="sliderBubble" id="avgABubble">‚Äì</div></div></div>
</div>
<div>
<label class="statRow" id="avgBLabel">Average (B) <strong><span id="avgBVal">70.0</span></strong></label><div class="sliderWrap"><div class="sliderBox"><input id="avgB" max="120" min="20" oninput="setStatVal('avgB','avgBVal',1)" step="0.5" type="range" value="70.0"/><div class="sliderBubble" id="avgBBubble">‚Äì</div></div></div>
</div>
</div>
<div class="split">
<div>
<div class="split" id="f9Split" style="margin-top:10px">
<div>
<label class="statRow" id="f9ALabel" title="Snittpo√§ng under f√∂rsta 9 pilarna">First 9 (A) <strong><span id="f9AVal">85.0</span></strong></label><div class="sliderWrap"><div class="sliderBox"><input id="f9A" max="140" min="30" oninput="setStatVal('f9A','f9AVal',1)" step="0.5" type="range" value="85.0"/><div class="sliderBubble" id="f9ABubble">‚Äì</div></div></div>
</div>
<div>
<label class="statRow" id="f9BLabel" title="Snittpo√§ng under f√∂rsta 9 pilarna">First 9 (B) <strong><span id="f9BVal">85.0</span></strong></label><div class="sliderWrap"><div class="sliderBox"><input id="f9B" max="140" min="30" oninput="setStatVal('f9B','f9BVal',1)" step="0.5" type="range" value="85.0"/><div class="sliderBubble" id="f9BBubble">‚Äì</div></div></div>
</div>
</div>
<div class="split" id="coSplit">
<div>
<label class="statRow" id="coALabel" title="Andel lyckade utg√•ngar (%)">Utg√•ng % (A) ‚Äì manuellt <strong><span id="coAVal">50.0%</span></strong></label><div class="sliderWrap"><div class="sliderBox"><input data-unit="pct" id="coA" max="100" min="0" oninput="setStatVal('coA','coAVal',1)" step="0.5" type="range" value="50.0"/><div class="sliderBubble" id="coABubble">50.0%</div></div></div>
</div>
<div>
<label class="statRow" id="coBLabel" title="Andel lyckade utg√•ngar (%)">Utg√•ng % (B) ‚Äì manuellt <strong><span id="coBVal">50.0%</span></strong></label><div class="sliderWrap"><div class="sliderBox"><input data-unit="pct" id="coB" max="100" min="0" oninput="setStatVal('coB','coBVal',1)" step="0.5" type="range" value="50.0"/><div class="sliderBubble" id="coBBubble">50.0%</div></div></div>
</div>
</div>
<div class="hint" id="outOverrideWrap" style="margin-top:10px">
<label style="display:flex;gap:10px;align-items:center">
<input id="outOverrideDouble" type="checkbox">
<span>Den h√§r matchen spelades med <strong>dubbel utg√•ng</strong></span>
</input></label>
<div class="hint" style="margin-top:6px">Anv√§nd om ni avviker fr√•n turneringens inst√§llning f√∂r utg√•ng.</div>
</div>
<label>Anteckningar (valfritt)</label><input id="notes" placeholder="t.ex. grym match...">
</input></div>
</div>
<div class="btnbar">
<button class="btn secondary" onclick="closeModal()">St√§ng</button>
</div>
</div>
</div>
</main>
<!-- Player modal -->
<div class="overlay hidden" id="playerOverlay" onclick="closePlayerModal()">
<div class="modal" onclick="stopPropagation(event)">
<div class="row" style="justify-content:space-between;align-items:flex-start">
<div>
<div class="playerHeader"><button type="button" class="playerAvatar avatarBtn big" id="playerAvatarBtn" data-avatar-pid="" data-avatar-name=""><span id="playerAvatarInitials"></span><img alt="" style="display:none"></button><h3 id="playerTitle" style="margin:0">Spelare</h3></div>
<div class="small" id="playerSubtitle"></div>
</div>
</div>
<div id="playerBody" style="margin-top:12px"></div>
<div class="modalCloseBottom"></div>
<!-- History modal -->
<div class="overlay hidden" id="historyOverlay" onclick="closeHistoryModal()">
<div class="modal" onclick="stopPropagation(event)">
<div class="row" style="justify-content:space-between;align-items:flex-start">
<div>
<h3 id="historyTitle" style="margin:0">Historik</h3>
<div class="small" id="historySubtitle"></div>
</div>
<button class="btn secondary" onclick="closeHistoryModal()">St√§ng</button>
</div>
<div id="historyBody" style="margin-top:12px"></div>
</div>
</div>
</div>
</div>
<script>


const STORAGE_KEY = "turneringsapp_v2_2";
// Extra autospar (separat nyckel) f√∂r snabb √•terst√§llning vid oavsiktlig uppdatering.
const AUTOSAVE_KEY = "turneringsapp_autosave_v1";

const HISTORY_KEY = "turneringsapp_playerhistory_v1";

function normName(s){
  return (s||"").toString().trim().toLowerCase().replace(/\s+/g," ");
}

function loadHistory(){
  try{
    var raw = _storage().getItem(HISTORY_KEY);
    if(!raw) return { players:{} };
    var obj = JSON.parse(raw);
    if(!obj || typeof obj !== "object") return { players:{} };
    if(!obj.players) obj.players = {};
    return obj;
  }catch(e){
    return { players:{} };
  }
}

function saveHistory(h){
  try{ _storage().setItem(HISTORY_KEY, JSON.stringify(h)); }catch(e){}
}

function clearHistoryForPlayer(pid){
  try{
    var title = playerName(pid) || "";
    var key = normName(title);
    if(!key) return;
    if(!confirm("√Ñr du s√§ker p√• att du vill radera historiken f√∂r " + title + "?\n\nDetta tar bort alla sparade matcher f√∂r profilen, men beh√•ller namn, pilar och l√•t.")) return;
    var h = loadHistory();
    if(h && h.players && h.players[key]){ delete h.players[key]; }
    saveHistory(h || {players:{}});
    // Uppdatera √∂ppet profilkort om det √§r √∂ppet
    try{ openPlayerModal(pid); }catch(e){}
  }catch(e){}
}


function upsertHistoryMatch(pid, matchObj){
  var h = loadHistory();
  var key = normName(playerName(pid));
  if(!key) return;
  if(!h.players[key]) h.players[key] = { matches:[] };
  var arr = h.players[key].matches || (h.players[key].matches = []);
  // ta bort ev. tidigare version av samma match (om man redigerar)
  arr = arr.filter(function(x){ return x && x.matchId !== matchObj.matchId; });
  arr.push(matchObj);
  // sortera efter tid (√§ldst->nyast)
  arr.sort(function(a,b){
    return String(a.finishedAt||"").localeCompare(String(b.finishedAt||""));
  });
  h.players[key].matches = arr;
  saveHistory(h);
}

function computeHistorySummary(key){
  var h = loadHistory();
  var entry = h.players && h.players[key];
  var ms = (entry && entry.matches) ? entry.matches.slice() : [];
  var sum = { played:0,w:0,l:0,legsW:0,legsL:0,avg:null,f9:null,co:null,coSingle:null,coDouble:null,last:null };
  if(!ms.length) return sum;

  var avgN=0,f9N=0,coN=0;
  var avgS=0,f9S=0,coS=0;

  var coSingleN=0, coDoubleN=0;
  var coSingleS=0, coDoubleS=0;

  ms.forEach(function(m){
    if(!m) return;
    sum.played++;
    if(m.won) sum.w++; else sum.l++;
    sum.legsW += (m.legsFor||0);
    sum.legsL += (m.legsAgainst||0);

    if(typeof m.avg === "number" && !isNaN(m.avg)){ avgS += m.avg; avgN++; }
    if(typeof m.f9 === "number" && !isNaN(m.f9)){ f9S += m.f9; f9N++; }

    if(typeof m.co === "number" && !isNaN(m.co)){
      coS += m.co; coN++;
      var rule = (m.outRule || "").toLowerCase();
      if(rule === "double"){ coDoubleS += m.co; coDoubleN++; }
      else if(rule === "single"){ coSingleS += m.co; coSingleN++; }
    }

    sum.last = m.finishedAt || sum.last;
  });

  sum.avg = avgN ? (avgS/avgN) : null;
  sum.f9  = f9N ? (f9S/f9N) : null;
  sum.co  = coN ? (coS/coN) : null;
  sum.coSingle = coSingleN ? (coSingleS/coSingleN) : null;
  sum.coDouble = coDoubleN ? (coDoubleS/coDoubleN) : null;
  return sum;
}


function computeHistoryExtras(key){
  // Extra, "kul" statistik f√∂r spelarkortet: form (trend) och personb√§sta.
  // Form = snitt senaste 3 matcher (med avg) j√§mf√∂rt med spelarens historiska snitt (med avg).
  // Personb√§sta = h√∂gsta avg i historiken (med avg).
  var h = loadHistory();
  var entry = h.players && h.players[key];
  var ms = (entry && entry.matches) ? entry.matches.slice() : [];
  if(!ms.length) return { trend:null, best:null, bestOpp:null };

  // Sortera s√§kert p√• datum (√§ldre -> nyare)
  ms.sort(function(a,b){
    try{
      return String(a.finishedAt||"").localeCompare(String(b.finishedAt||""));
    }catch(e){ return 0; }
  });

  // Personb√§sta
  var best = null, bestOpp = null;
  ms.forEach(function(m){
    if(!m) return;
    var a = (typeof m.avg==="number") ? m.avg : parseFloat(m.avg);
    if(isNaN(a)) return;
    if(best===null || a > best){
      best = a;
      bestOpp = m.opponent || null;
    }
  });

  // Form (trend) p√• average
  var avgVals = ms.map(function(m){
    var a = (typeof m.avg==="number") ? m.avg : parseFloat(m.avg);
    return (isNaN(a) ? null : a);
  }).filter(function(v){ return v!==null; });

  if(avgVals.length < 3){
    return { trend:null, best:best, bestOpp:bestOpp };
  }

  var overall = avgVals.reduce(function(s,v){ return s+v; },0) / avgVals.length;
  var recent3 = avgVals.slice(-3);
  var recent = recent3.reduce(function(s,v){ return s+v; },0) / recent3.length;

  var delta = recent - overall; // positiv = b√§ttre √§n historiskt snitt
  // D√§mpa brus: sm√• skillnader betraktas som stabilt
  if(Math.abs(delta) < 0.3) delta = 0;

  return {
    trend: { delta: delta, recent: recent, overall: overall },
    best: best,
    bestOpp: bestOpp
  };
}

function fmtNum(x, dec){
  if(x===null || x===undefined || isNaN(x)) return "-";
  return Number(x).toFixed(dec);
}

function fmtDateTime(iso){
  try{
    if(!iso) return "-";
    var d = new Date(iso);
    if(isNaN(d.getTime())) return iso;
    var y=d.getFullYear();
    var m=("0"+(d.getMonth()+1)).slice(-2);
    var da=("0"+d.getDate()).slice(-2);
    var hh=("0"+d.getHours()).slice(-2);
    var mm=("0"+d.getMinutes()).slice(-2);
    return y+"-"+m+"-"+da+" "+hh+":"+mm;
  }catch(e){ return iso||"-"; }
}

function openHistoryModal(pid){
  var title = playerName(pid);
  document.getElementById("historyTitle").textContent = "Historik ‚Äì " + (title||"");
  var key = normName(title);
  var h = loadHistory();
  var entry = h.players && h.players[key];
  var ms = (entry && entry.matches) ? entry.matches.slice().reverse() : [];
  document.getElementById("historySubtitle").textContent = ms.length ? (ms.length + " matcher") : "Ingen historik sparad.";
  var body = "";
  if(ms.length){
    body += "<div class='tablewrap'><table><thead><tr><th>Datum</th><th>Mot</th><th>Res</th><th class='right'>Avg</th><th class='right'>F9</th><th class='right'>Utg%</th></tr></thead><tbody>";
    ms.forEach(function(m){
      var res = (m.won ? "V " : "F ") + (m.result||"");
      body += "<tr>"
        + "<td class='small'>"+escapeHtml(fmtDateTime(m.finishedAt))+"</td>"
        + "<td>"+escapeHtml(m.opponent||"")+"</td>"
        + "<td class='small'>"+escapeHtml(res)+"</td>"
        + "<td class='right small'>"+escapeHtml(fmtNum(m.avg,1))+"</td>"
        + "<td class='right small'>"+escapeHtml(fmtNum(m.f9,1))+"</td>"
        + "<td class='right small'>"+escapeHtml(fmtNum(m.co,1))+"</td>"
        + "</tr>";
    });
    body += "</tbody></table></div>";
  }else{
    body = "<div class='small'>Ingen historik √§nnu. N√§r du sparar matcher kommer de dyka upp h√§r.</div>";
  }
  document.getElementById("historyBody").innerHTML = body;
  document.getElementById("historyOverlay").classList.remove("hidden");
}

function closeHistoryModal(){
  var o=document.getElementById("historyOverlay");
  if(o) o.classList.add("hidden");
}

/* Lagring: f√∂rs√∂k localStorage, fallback till sessionStorage (funkar ofta b√§ttre f√∂r content:// p√• Android) */
function _storage(){
  try{ const t="__ta_test__"; localStorage.setItem(t,"1"); localStorage.removeItem(t); return localStorage; }catch(e){}
  try{ const t="__ta_test__"; sessionStorage.setItem(t,"1"); sessionStorage.removeItem(t); return sessionStorage; }catch(e){}
  return null;
}
const STORAGE = _storage();

function _nameStoreRead(){
  try{
    const prefix = "TA_STORE:";
    const raw = (typeof window !== "undefined" && typeof window.name === "string") ? window.name : "";
    if(raw && raw.indexOf(prefix) === 0){
      const obj = JSON.parse(raw.slice(prefix.length) || "{}");
      return (obj && typeof obj === "object") ? obj : {};
    }
  }catch(e){}
  return {};
}
function _nameStoreWrite(obj){
  try{
    const prefix = "TA_STORE:";
    if(typeof window !== "undefined"){
      window.name = prefix + JSON.stringify(obj || {});
      return true;
    }
  }catch(e){}
  return false;
}

function storageSet(key, value){
  // F√∂rst: local/sessionStorage om tillg√§ngligt
  try{
    if(STORAGE){
      STORAGE.setItem(key, value);
      return true;
    }
  }catch(e){}
  // Fallback: window.name (√∂verlever reload i samma flik √§ven n√§r lagring blockas)
  const obj = _nameStoreRead();
  obj[key] = value;
  return _nameStoreWrite(obj);
}
function storageGet(key){
  try{
    if(STORAGE){
      return STORAGE.getItem(key);
    }
  }catch(e){}
  const obj = _nameStoreRead();
  return (obj && Object.prototype.hasOwnProperty.call(obj, key)) ? obj[key] : null;
}
function storageDel(key){
  let ok=false;
  try{
    if(STORAGE){
      STORAGE.removeItem(key);
      ok=true;
    }
  }catch(e){}
  const obj = _nameStoreRead();
  if(obj && Object.prototype.hasOwnProperty.call(obj, key)){
    delete obj[key];
    ok = _nameStoreWrite(obj) || ok;
  }
  return ok;
}

function deepClone(obj){
  return JSON.parse(JSON.stringify(obj));
}
function $(id){ return document.getElementById(id); }


function ensureKnockoutSync(){
  // S√§kerst√§ll att knockout alltid har ett slutspels-tr√§d att rendera,
  // √§ven efter att man navigerat bak√•t/fram√•t eller laddat om.
  try{
    if(state && state.format==="knockout"){
      const hasPO = state.playoffs && Array.isArray(state.playoffs.matches) && state.playoffs.matches.length>0;
      if(!hasPO){
        const ms = Array.isArray(state.matches) ? state.matches : [];
        const po = ms.filter(m => m && typeof m.id==="string" && m.id.indexOf("po_")===0);
        if(po.length){
          if(!state.playoffs) state.playoffs = {};
          state.playoffs.matches = po;
          if(typeof state.playoffs.started !== "boolean") state.playoffs.started = false;
        }
      }
    }
  }catch(e){}
}




function ensurePlayoffsSync(){
  // H√•ll state.playoffs.matches och ev. po_* matcher i state.matches synkade.
  // Viktigt: om man sparar i slutspelstr√§det f√•r det INTE skrivas √∂ver av en √§ldre kopia i matchlistan.
  try{
    if(!state) return;

    // Knockout: skapa vid behov playoffs.matches fr√•n po_* i state.matches.
    try{ ensureKnockoutSync(); }catch(e){}

    if(!state.playoffs || !Array.isArray(state.playoffs.matches)) return;

    const po = state.playoffs.matches;
    const ms = Array.isArray(state.matches) ? state.matches : [];

    // Indexera
    const poById = {};
    for(let i=0;i<po.length;i++){
      const mm = po[i];
      if(mm && typeof mm.id==="string") poById[mm.id] = mm;
    }

    // Hitta po_* i state.matches
    const poInMatches = ms.filter(m => m && typeof m.id==="string" && m.id.indexOf("po_")===0);
    if(!poInMatches.length){
      // Om matchlistan inte inneh√•ller po_* (vanligt i grupp/serie+slutspel) finns inget mer att synka.
      return;
    }

    // Hj√§lp: j√§mf√∂r tidsst√§mplar (ISO). Returnerar true om a > b.
    function isoAfter(a,b){
      if(!a) return false;
      if(!b) return true;
      try{ return String(a) > String(b); }catch(e){ return false; }
    }

    // 1) F√∂rst: spegla fr√•n playoffs -> matches (s√• att sparningar i tr√§det alltid vinner).
    po.forEach(function(src){
      const idx = ms.findIndex(m => m && m.id===src.id);
      if(idx<0) return;
      const dst = ms[idx];
      if(!dst) return;

      // Endast uppdatera om playoffs har nyare info eller om matchlistan saknar vinnare.
      const srcNewer = isoAfter(src.finishedAt, dst.finishedAt);
      const srcHasWinner = !!src.winnerId;
      const dstHasWinner = !!dst.winnerId;

      if(srcNewer || (srcHasWinner && !dstHasWinner)){
        const keys = ["aId","bId","winnerId","result","avgA","avgB","f9A","f9B","coA","coB","notes","finishedAt","outRule"];
        keys.forEach(function(k){
          if(Object.prototype.hasOwnProperty.call(src, k)) dst[k] = src[k];
        });
      }
    });

    // 2) Sen: synka fr√•n matches -> playoffs, men bara om matchlistan √§r nyare.
    poInMatches.forEach(function(src){
      const dst = poById[src.id];
      if(!dst) return;

      const srcNewer = isoAfter(src.finishedAt, dst.finishedAt);
      const srcHasWinner = !!src.winnerId;
      const dstHasWinner = !!dst.winnerId;

      // Kopiera om matchlistan √§r nyare, eller om playoffs saknar vinnare men matchlistan har.
      if(srcNewer || (srcHasWinner && !dstHasWinner)){
        for(const k in src){
          if(Object.prototype.hasOwnProperty.call(src, k)){
            dst[k] = src[k];
          }
        }
      }
    });

    // 3) Efter synk: uppdatera final/semis n√§r det √§r relevant
    try{
      if(state.playoffs && state.playoffs.started && state.format!=="knockout"){
        updateFinalFromSemis();
      }
    }catch(e){}

  }catch(e){}
}

function advancePlayoffWinners(){
  // F√∂r knockout: f√∂r vinnare vidare enligt nextId/nextSlot i matchobjekten.
  // K√∂rs efter att en slutspelsmatch sparats s√• att tr√§det + kommande matcher uppdateras direkt.
  try{
    if(!state || state.format!=="knockout") return false;
    ensureKnockoutSync();

    // Prim√§r k√§lla: state.matches (Match-fliken). Fallback: state.playoffs.matches.
    var ms = Array.isArray(state.matches) ? state.matches : (state.playoffs && Array.isArray(state.playoffs.matches) ? state.playoffs.matches : []);
    if(!ms || !ms.length) return false;

    // Plocka bara slutspelsmatcher (po_*)
    var po = ms.filter(function(m){ return m && typeof m.id==="string" && m.id.indexOf("po_")===0; });
    if(!po.length) return false;

    var byId = {};
    po.forEach(function(m){ byId[m.id]=m; });

    function clearMatch(m){
      if(!m) return;
      m.winnerId = "";
      m.result = "";
      m.avgA = ""; m.avgB = "";
      m.f9A = ""; m.f9B = "";
      m.coA = ""; m.coB = "";
      m.notes = "";
      m.finishedAt = "";
    }

    var changedAny = false;

    // K√∂r ett par varv f√∂r att "sk√∂lja igenom" hela tr√§det (kval -> qf/sf -> final)
    for(var pass=0; pass<5; pass++){
      var changed = false;

      po.forEach(function(m){
        if(!m || !m.winnerId || !m.nextId || !m.nextSlot) return;
        var nm = byId[m.nextId];
        if(!nm) return;

        if(nm[m.nextSlot] !== m.winnerId){
          nm[m.nextSlot] = m.winnerId;

          // Om deltagare √§ndras: rensa matchen och allt nedstr√∂ms s√• det inte blir sp√∂k-vinnare.
          clearMatch(nm);
          changed = true;
        }
      });

      // Om vi under passet uppdaterade deltagare, m√•ste vi ocks√• s√§kerst√§lla att
      // "winnerId" fortfarande √§r giltig i alla matcher (annars rensa).
      po.forEach(function(m){
        if(!m || !m.winnerId) return;
        if(m.winnerId !== m.aId && m.winnerId !== m.bId){
          clearMatch(m);
          changed = true;
        }
      });

      if(changed){
        changedAny = true;
      }else{
        break; // stabilt
      }
    }

    // H√•ll state.playoffs.matches pekande mot aktuella objekt om det finns.
    try{
      if(state.playoffs){
        state.playoffs.matches = po;
      }
    }catch(e){}

    return changedAny;
  }catch(e){
    console.error(e);
    return false;
  }
}


function togglePlayoffBracket(){
  if(!state.ui) state.ui = {};
  state.ui.showPlayoffsBracket = !state.ui.showPlayoffsBracket;
  saveState();
  applyPlayoffView();
  try{ window.scrollTo(0,0); }catch(e){}
}


function applyPlayoffView(){
  // Persist UI choice (schema vs tr√§d) without affecting tournament logic
  if(!state.ui) state.ui = {};
  var show = !!state.ui.showPlayoffsBracket;

  var sched = $("playoffsScheduleView");
  var br = $("playoffsBracketView");
  var btn = $("btnPlayoffsBracketToggle");

  if(sched) sched.classList.toggle("hidden", show);
  if(br) br.classList.toggle("hidden", !show);

  if(btn){
    btn.textContent = show ? "Visa slutspelsschema" : "Visa slutspelstr√§d";
  }

  if(show){
    renderPlayoffBracket();
  }
}

function scrollPlayoffsBracket(where){
  try{
    var vp = document.getElementById('playoffsBracket');
    if(!vp) return;

    var scroller = document.getElementById('playoffsBracketViewport') || vp;
    var inner = document.getElementById('playoffsBracketInner');
    if(!scroller || !inner) return;

    var hasQF = !!(inner.querySelector && inner.querySelector('[data-po-id="po_qf1"]'));
    var hasQUAL = !!(inner.querySelector && inner.querySelector('[data-po-id="po_k1"]'));


    // Kval = l√§ngst till v√§nster n√§r den finns
    if(where==='qual'){
      scroller.scrollTo({left:0, behavior:'smooth'});
      return;
    }

    // Kvartsfinal = l√§ngst till v√§nster (start) n√§r den finns
    if(where==='qf'){
      // om Kval finns, scrolla lite √•t h√∂ger s√• Kvarts hamnar snyggt
      if(hasQUAL){
        scroller.scrollTo({left: 0, behavior:'smooth'});
      }else{
        scroller.scrollTo({left:0, behavior:'smooth'});
      }
      return;
    }

    // Semifinal: vid 2 grupper √§r den l√§ngst till v√§nster. Vid 4 grupper scrollar vi till SF-kolumnen.
    if(where==='sf'){
      if(!hasQF){
        scroller.scrollTo({left:0, behavior:'smooth'});
        return;
      }
      var sf = inner.querySelector('[data-po-id="po_sf1"]');
      if(!sf){ scroller.scrollTo({left:0, behavior:'smooth'}); return; }
      var sRect = scroller.getBoundingClientRect();
      var fRect = sf.getBoundingClientRect();
      var cur = scroller.scrollLeft;
      var target = cur + (fRect.left - sRect.left) - 24;
      if(target < 0) target = 0;
      scroller.scrollTo({left: target, behavior:'smooth'});
      return;
    }

    // Final = s√• att b√•de final och pokal syns (om pokal finns)
    if(where==='final'){
      var fin = inner.querySelector('[data-po-id="po_f"]');
      var trophy = inner.querySelector('.trophyCircle');

      if(!fin){
        scroller.scrollTo({left:scroller.scrollWidth, behavior:'smooth'});
        return;
      }

      var sRect = scroller.getBoundingClientRect();

      // Prioritera att pokalen kommer in i bild om den finns
      if(trophy){
        var tRect = trophy.getBoundingClientRect();
        var cur = scroller.scrollLeft;
        // Flytta s√• att pokalens h√∂gersida hamnar innanf√∂r viewport (med marginal)
        var target = cur + (tRect.right - sRect.right) + 24;
        if(target < 0) target = 0;
        scroller.scrollTo({left: target, behavior:'smooth'});
        return;
      }

      // Annars: centrera finalrutan s√• gott det g√•r
      var fRect = fin.getBoundingClientRect();
      var current = scroller.scrollLeft;
      var target2 = current + (fRect.left - sRect.left) - (sRect.width/2) + (fRect.width/2);
      scroller.scrollTo({left: Math.max(0, target2), behavior:'smooth'});
      return;
    }
  }catch(e){
    console.error(e);
  }
}

function renderPlayoffBracket(){
  ensurePlayoffsSync();
  var hasPO = !!(state.playoffs && state.playoffs.matches && state.playoffs.matches.length>0);
  var started = !!(state.playoffs && state.playoffs.started && hasPO);

  // Knockout: visa alltid det skapade tr√§det (√§ven innan man tryckt Starta slutspel)
  // s√• att Slumpa om + f√∂rhandsvisning fungerar och tr√§det matchar Match-fliken.
  var ms = (state.format === "knockout" && hasPO) ? state.playoffs.matches
           : (started ? state.playoffs.matches : (buildPlayoffsPreview() || []));
  if(!ms || ms.length===0) return;

  // Se till att finalen alltid f√•r deltagare fr√•n semis n√§r de √§r spelade (endast n√§r slutspelet √§r startat)
  if(started && state.format!=="knockout"){
    try{ updateFinalFromSemis(); }catch(e){}
  }
  function byId(id){ for(var i=0;i<ms.length;i++) if(ms[i].id===id) return ms[i]; return null; }

  var qf1 = byId("po_qf1");
  var qf2 = byId("po_qf2");
  var qf3 = byId("po_qf3");
  var qf4 = byId("po_qf4");

  var sf1 = byId("po_sf1");
  var sf2 = byId("po_sf2");
  var fin = byId("po_f");

  function pname(pid, placeholder){
    try{ if(pid) return playerName(pid); }catch(e){}
    return placeholder || "";
  }

  function splitResult(m){
    if(!m || !m.result) return null;
    var parts = String(m.result).split("-");
    if(parts.length!==2) return null;
    var a = parseInt(parts[0],10); var b=parseInt(parts[1],10);
    if(isNaN(a)||isNaN(b)) return null;
    return [a,b];
  }
  function scoresForRows(m){
    if(!m || !m.winnerId) return ["",""];
    var ab = splitResult(m);
    if(!ab) return ["",""];
    var w = ab[0], l = ab[1];
    if(m.winnerId===m.aId) return [String(w), String(l)];
    if(m.winnerId===m.bId) return [String(l), String(w)];
    return ["",""];
  }

  function rowHtml(pid, scoreTxt, isWinner, placeholder){
    var nm = pname(pid, placeholder);
    var rowClass = "bracketRow" + (isWinner ? " winnerRow" : "");
    var nameClass = isWinner ? "winnerName" : "mutedName";
    var left = "<div class='row' style='align-items:center;gap:8px;min-width:0'>"
             + _avatarBtnViewHtml(pid||'', nm, 'small')
             + "<div class='"+nameClass+"' style='min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap'>"+escapeHtml(nm)+"</div>"
             + "</div>";
    return '<div class="'+rowClass+'">'
         +   left
         +   (scoreTxt ? '<div class="bracketScore">'+escapeHtml(scoreTxt)+'</div>' : '')
         + '</div>';
  }

  function matchBox(m, aPlaceholder, bPlaceholder){
    // Om platsen kommer fr√•n kval, visa r√§tt placeholder
    try{
      if(m && m._aFromQual!==null && m._aFromQual!==undefined) aPlaceholder = 'Vinnare Kval ' + (m._aFromQual+1);
      if(m && m._bFromQual!==null && m._bFromQual!==undefined) bPlaceholder = 'Vinnare Kval ' + (m._bFromQual+1);
    }catch(e){}

    var played = !!(m && m.winnerId);
    var rowScores = scoresForRows(m);

    var aWinner = played && m.winnerId===m.aId;
    var bWinner = played && m.winnerId===m.bId;

    var aRow = rowHtml(m ? m.aId : null, rowScores[0], aWinner, aPlaceholder);
    var bRow = rowHtml(m ? m.bId : null, rowScores[1], bWinner, bPlaceholder);

    var clickable = !!(m && m.id);
    
    

    var attrs = 'class="bracketBox" data-po-id="'+escapeHtml(m?m.id:"")+'"'
              + (m && m._aFromQual!==null && m._aFromQual!==undefined ? ' data-k-a="'+escapeHtml(String(m._aFromQual))+'"' : '')
              + (m && m._bFromQual!==null && m._bFromQual!==undefined ? ' data-k-b="'+escapeHtml(String(m._bFromQual))+'"' : '')
              + (clickable ? ' onclick="openPlayoffMatch(\''+escapeHtml(m.id)+'\')"' : '');

    return '<div '+attrs+'>'
         +   '<div class="bracketBody">'+aRow+bRow+'</div>'
         + '</div>';
  }

  var inner = $("playoffsBracketContent") || $("playoffsBracketInner");
  if(!inner) return;

  // Vinnarruta (visas √§ven innan finalen √§r spelad)
  var winnerName = "‚Äî";
  try{ if(fin && fin.winnerId) winnerName = playerName(fin.winnerId); }catch(e){}
  var winnerAvatar = _avatarBtnViewHtml((fin && fin.winnerId) ? fin.winnerId : '', winnerName, 'small');
  var winnerBox = ''
    + '<div class="winnerBox'+((fin && fin.winnerId) ? ' hasWinner' : '')+'">'
    +   '<div class="trophyCircle" title="Vinnare">üèÜ</div>'
    +   '<div class="winnerAvatar" aria-hidden="true">'+winnerAvatar+'</div>'
    +   '<div class="winnerText">'
    +     '<div class="winnerLabel">Vinnare av turneringen</div>'
    +     '<div class="winnerValue">'+escapeHtml(winnerName)+'</div>'
    +   '</div>'
    + '</div>';

  var hasQF = !!(qf1 || qf2 || qf3 || qf4 || state.numGroups===4);
  var hasQUAL = false;
  for(var ki=1; ki<=7; ki++){ if(byId('po_k'+ki)) { hasQUAL=true; break; } }


  // Layout: v√§xla mellan 2-kolumn (SF+Final) och 3-kolumn (QF+SF+Final)
  try{
    var shell = $("playoffsBracketInner");
    if(shell && shell.classList){
      shell.classList.toggle('hasQF', !!hasQF);
      shell.classList.toggle('hasQUAL', !!hasQUAL);
    }
  }catch(e){}

  var html = ''
    + '<div class="bracketGrid4">';


if(hasQUAL){
  html += '<div class="bracketCell qual">';
  for(var ki=1; ki<=7; ki++){
    var km = byId('po_k'+ki);
    if(km) html += matchBox(km, "‚Äî", "‚Äî");
  }
  html += '</div>';
}

if(hasQF){
    html += ''
      + '<div class="bracketCell qf">'
      +   matchBox(qf1, "Spelare A1", "Spelare B2")
      +   matchBox(qf2, "Spelare B1", "Spelare A2")
      +   matchBox(qf3, "Spelare C1", "Spelare D2")
      +   matchBox(qf4, "Spelare D1", "Spelare C2")
      + '</div>';
  }

  html += ''
    +   '<div class="bracketCell sf1">'+matchBox(sf1, (hasQF ? "Vinnare QF1" : "Spelare A1"), (hasQF ? "Vinnare QF2" : "Spelare B2"))+'</div>'
    +   '<div class="bracketCell sf2">'+matchBox(sf2, (hasQF ? "Vinnare QF3" : "Spelare B1"), (hasQF ? "Vinnare QF4" : "Spelare A2"))+'</div>'
    +   '<div class="bracketCell final">'
    +     '<div class="finalWrap">'
    +       '<div>'+matchBox(fin, "Vinnare SF1", "Vinnare SF2")+'</div>'
    +       winnerBox
    +     '</div>'
    +   '</div>'
    + '</div>';

  inner.innerHTML = html;

  // Aktivera/inaktivera snabbnavigering f√∂r kvartsfinal beroende p√• uppl√§gg
  try{
    var qfBtn = document.querySelector("button.bracketNavBtn[onclick*='scrollPlayoffsBracket(\\'qf\\')']");
    if(qfBtn) qfBtn.disabled = !hasQF;
    var kvalBtn = document.getElementById('btnBracketQual');
    if(kvalBtn){
      if(hasQUAL){ kvalBtn.classList.remove('hidden'); kvalBtn.disabled = false; }
      else{ kvalBtn.classList.add('hidden'); kvalBtn.disabled = true; }
    }
  }catch(e){}

  try{ hydrateAvatarsIn(inner); }catch(e){}

  // Rita linjer efter att layouten lagt sig
  setTimeout(drawPlayoffsBracketLines, 0);
  try{
    if(!window.__bracketLinesBound){
      window.__bracketLinesBound = true;
      var sc = document.getElementById('playoffsBracketViewport');
      if(sc){ sc.addEventListener('scroll', function(){ drawPlayoffsBracketLines(); }, {passive:true}); }
      window.addEventListener('resize', function(){ drawPlayoffsBracketLines(); });
    }
  }catch(e){}
}

function drawPlayoffsBracketLines(){
  var canvas = $("playoffsBracketViewport") || $("playoffsBracket");
  var svg = $("playoffsBracketSvg");
  var inner = $("playoffsBracketContent") || $("playoffsBracketInner");
  if(!canvas || !svg || !inner) return;

  function box(id){
    return inner.querySelector('[data-po-id="'+id+'"]');
  }
  var k1 = box("po_k1");
  var k2 = box("po_k2");
  var k3 = box("po_k3");
  var k4 = box("po_k4");
  var k5 = box("po_k5");
  var k6 = box("po_k6");
  var k7 = box("po_k7");

  var qf1 = box("po_qf1");
  var qf2 = box("po_qf2");
  var qf3 = box("po_qf3");
  var qf4 = box("po_qf4");

  var sf1 = box("po_sf1");
  var sf2 = box("po_sf2");
  var fin = box("po_f");

  if(!sf1 || !sf2 || !fin) { svg.innerHTML=""; return; }

  var hasQF = !!(qf1 || qf2 || qf3 || qf4);
  var hasQUAL = !!(k1||k2||k3||k4||k5||k6||k7);

  var cRect = canvas.getBoundingClientRect();
  var width = inner.scrollWidth || inner.clientWidth;
  var height = inner.scrollHeight || inner.clientHeight;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", "0 0 "+width+" "+height);
  svg.style.width = width+"px";
  svg.style.height = height+"px";

  var baseRect = inner.getBoundingClientRect();
  function relRect(el){
    var r = el.getBoundingClientRect();
    return {
      left: r.left - baseRect.left,
      top: r.top - baseRect.top,
      right: r.right - baseRect.left,
      bottom: r.bottom - baseRect.top,
      cx: (r.left + r.right)/2 - cRect.left + canvas.scrollLeft,
      cy: (r.top + r.bottom)/2 - cRect.top
    };
  }

  var r1 = relRect(sf1);
  var r2 = relRect(sf2);
  var rf = relRect(fin);

  var trophy = (inner.querySelector && inner.querySelector(".trophyCircle")) ? inner.querySelector(".trophyCircle") : null;
  var rt = trophy ? relRect(trophy) : null;

  var stroke = "#dbe3ef";
  var strokeW = 6;

  function pathL(sx, sy, tx, ty, mx){
    return "M "+sx+" "+sy+" L "+mx+" "+sy+" L "+mx+" "+ty+" L "+tx+" "+ty;
  }

  var paths = [];

  // Kval-linjer: fr√•n po_kX till matcher som v√§ntar kvalvinnare
if(hasQUAL){
  var targets = inner.querySelectorAll('[data-k-a], [data-k-b]');
  targets.forEach(function(t){
    var aK = t.getAttribute('data-k-a');
    var bK = t.getAttribute('data-k-b');
    var idx = aK || bK;
    if(!idx) return;
    var kEl = box('po_k'+idx);
    if(!kEl) return;

    var rk = relRect(kEl);
    var rt = relRect(t);

    var ax = rk.right, ay = rk.cy;
    var tx = rt.left,  ty = rt.cy;

    var joinX = (ax + tx) / 2;

    paths.push("M "+ax+" "+ay+" L "+joinX+" "+ay+" L "+joinX+" "+ty+" L "+tx+" "+ty);
  });
}


  if(hasQF && qf1 && qf2 && qf3 && qf4){
    var rq1 = relRect(qf1);
    var rq2 = relRect(qf2);
    var rq3 = relRect(qf3);
    var rq4 = relRect(qf4);

    function addBracketPair(qA, qB, sfRect){
      var ax = qA.right, ay = qA.cy;
      var bx = qB.right, by = qB.cy;
      var tx = sfRect.left, ty = sfRect.cy;
      var joinX = (ax + tx) / 2;

      paths.push("M "+ax+" "+ay+" L "+joinX+" "+ay);
      paths.push("M "+bx+" "+by+" L "+joinX+" "+by);

      var topY = Math.min(ay, by);
      var botY = Math.max(ay, by);
      paths.push("M "+joinX+" "+topY+" L "+joinX+" "+botY);

      paths.push("M "+joinX+" "+ty+" L "+tx+" "+ty);
    }

    addBracketPair(rq1, rq2, r1);
    addBracketPair(rq3, rq4, r2);
  }

  var p1x = r1.right;
  var p1y = r1.cy;
  var p2x = r2.right;
  var p2y = r2.cy;
  var fx = rf.left;
  var fy = rf.cy;
  var midSFtoF = (p1x + fx) / 2;

  paths.push(pathL(p1x, p1y, fx, fy, midSFtoF));
  paths.push(pathL(p2x, p2y, fx, fy, midSFtoF));

  svg.innerHTML = paths.map(function(d){
    return '<path d="'+d+'" fill="none" stroke="'+stroke+'" stroke-width="'+strokeW+'" stroke-linecap="round" stroke-linejoin="round" />';
  }).join("");

  if(rt){
    var tx1 = rf.right;
    var ty1 = rf.cy;
    var tx2 = rt.left;
    var ty2 = rt.cy;
    var mx = (tx1 + tx2) / 2;
    svg.innerHTML += '<path d="'+pathL(tx1, ty1, tx2, ty2, mx)+'" fill="none" stroke="'+stroke+'" stroke-width="'+strokeW+'" stroke-linecap="round" stroke-linejoin="round" />';
  }
}



function setStatVal(inputId, spanId, decimals){
  var el = document.getElementById(inputId);
  var out = document.getElementById(spanId);

  if(!el) return;

  var min = Number(el.min || 0);
  var max = Number(el.max || 100);
  var step = Number(el.step || 1);

  // Read value; if empty/NaN, fall back to min so we always show something
  var raw = (el.value === "" || el.value == null) ? NaN : Number(el.value);
  var v = Number.isFinite(raw) ? raw : min;

  // Snap to step if needed (helps when browser gives weird floats)
  if(Number.isFinite(step) && step > 0){
    var snapped = Math.round((v - min) / step) * step + min;
    // avoid -0
    v = Math.abs(snapped) < 1e-9 ? 0 : snapped;
  }

  // Format text
  var txt = (decimals != null) ? v.toFixed(decimals) : String(v);
  if (inputId === "coA" || inputId === "coB") txt = txt + "%";

  if(out) out.textContent = txt;

  // Bubble element (supports multiple id conventions)
  var bub = document.getElementById(inputId + "Bubble")
         || document.getElementById(spanId + "Bubble")
         || document.getElementById(spanId + "_bubble");

  if(bub){
    bub.textContent = txt;

    // Position bubble to follow the thumb
    // We position relative to the sliderBox container so it works on mobile.
    var box = bub.parentElement; // .sliderBox
    if(box){
      // Positionering som funkar stabilt i mobil-modaler (offset* i st√§llet f√∂r getBoundingClientRect)
      var pct = (max === min) ? 0 : (v - min) / (max - min);
      pct = Math.min(1, Math.max(0, pct));

      // x inom sliderBox
      var sliderW = (el.offsetWidth || 0);
      var boxW = (box.clientWidth || 0);

      // Om modalen precis √∂ppnats kan offsetWidth/bubbleWidth vara 0 (pga display:none innan),
      // d√• centrerar vi bubblan och l√•ter en senare sync (rAF) placera den korrekt.
      var bw0 = (bub.offsetWidth || 0);
      if(sliderW < 5 || boxW < 5 || bw0 < 5){
        bub.style.left = "50%";
        bub.style.transform = "translateX(-50%)";
        return;
      }

      var x = (el.offsetLeft || 0) + (pct * sliderW);

      // clamp s√• bubblan inte hamnar "d√∂d" utanf√∂r
      var bw = bw0;
      var maxX = boxW - (bw/2);
      var minX = (bw/2);
      if(Number.isFinite(x)){
        x = Math.max(minX, Math.min(maxX, x));
      } else {
        x = minX;
      }

      bub.style.left = x + "px";
      bub.style.transform = "translateX(-50%)";
    }
  }
}


function syncStatSliders(){
  try{ setStatVal('avgA','avgAVal',1); }catch(e){}
  try{ setStatVal('avgB','avgBVal',1); }catch(e){}
  try{ setStatVal('f9A','f9AVal',1); }catch(e){}
  try{ setStatVal('f9B','f9BVal',1); }catch(e){}
  try{ setStatVal('coA','coAVal',1); }catch(e){}
  try{ setStatVal('coB','coBVal',1); }catch(e){}
}
// ===== Statsimport (ChatGPT JSON) =====
function resetStatsImportUi(){
  try{
    var p = $("statsImportPanel");
    if(p) p.classList.add("hidden");
    var t = $("statsJsonText");
    if(t) t.value = "";
    statsImportSetStatus("", null);
  }catch(e){}
}

function toggleStatsImport(){
  var p = $("statsImportPanel");
  if(!p) return;
  p.classList.toggle("hidden");
  if(!p.classList.contains("hidden")){
    try{ $("statsJsonText").focus(); }catch(e){}
  }
}

function clearStatsImport(){
  try{ var t=$("statsJsonText"); if(t) t.value=""; }catch(e){}
  statsImportSetStatus("", null);
}

function statsImportSetStatus(msg, ok){
  var el = $("statsImportStatus");
  if(!el) return;
  el.textContent = msg || "";
  el.classList.remove("ok","err");
  if(ok === true) el.classList.add("ok");
  if(ok === false) el.classList.add("err");
}

function applyStatsImportFromFile(file){
  if(!file){ statsImportSetStatus("Ingen fil vald.", false); return; }
  var reader = new FileReader();
  reader.onload = function(){
    try{
      var txt = (reader.result||"").toString();
      var ta = $("statsJsonText");
      if(ta) ta.value = txt;
      applyStatsImportFromText();
    }catch(e){
      statsImportSetStatus("Kunde inte l√§sa filen.", false);
    }
  };
  reader.onerror = function(){ statsImportSetStatus("Kunde inte l√§sa filen.", false); };
  reader.readAsText(file);
}

function _toNumOrNull(v){
  if(v===null || v===undefined) return null;
  if(typeof v === "number" && isFinite(v)) return v;
  if(typeof v === "string"){
    var s = v.trim().replace(",",".");
    if(!s) return null;
    var n = parseFloat(s);
    return isFinite(n) ? n : null;
  }
  return null;
}

function _clamp(n, min, max){
  if(n===null || n===undefined) return null;
  if(!isFinite(n)) return null;
  if(min!=null) n = Math.max(min, n);
  if(max!=null) n = Math.min(max, n);
  return n;
}

function _findMatchById(id){
  var m = (state.matches||[]).find(function(x){ return x.id===id; });
  if(m) return m;
  if(state.playoffs && Array.isArray(state.playoffs.matches)){
    m = state.playoffs.matches.find(function(x){ return x.id===id; });
    if(m) return m;
  }
  return null;
}

function _applySlider(id, val, min, max){
  var el = $(id);
  if(!el) return;
  var n = _toNumOrNull(val);
  if(n===null) return;
  n = _clamp(n, min, max);
  el.value = n;
}

function applyStatsImportFromText(){
  try{
    var raw = ($("statsJsonText") && $("statsJsonText").value) ? $("statsJsonText").value.trim() : "";
    if(!raw){ statsImportSetStatus("Klistra in JSON eller ladda en fil.", false); return; }
    var obj = JSON.parse(raw);
    applyStatsImportObject(obj);
  }catch(e){
    statsImportSetStatus("JSON kunde inte tolkas. Kontrollera att du bara klistrat in JSON (utan extra text).", false);
  }
}

function applyStatsImportObject(obj){
  var m = _findMatchById(modal.id);
  if(!m){ statsImportSetStatus("Ingen match √§r √∂ppen.", false); return; }

  var aName = playerName(m.aId) || "";
  var bName = playerName(m.bId) || "";

  var playersObj = (obj && obj.players) ? obj.players : null;
  var inA = playersObj && playersObj.A ? playersObj.A : {};
  var inB = playersObj && playersObj.B ? playersObj.B : {};

  function n(s){ return normName(s||""); }
  var aKey = n(aName), bKey = n(bName);

  var slotA = null, slotB = null;

  // F√∂rs√∂k matcha p√• namn f√∂rst (robust mot A/B-ordning)
  if(n(inA.name) && n(inA.name)===aKey) slotA = inA;
  if(n(inA.name) && n(inA.name)===bKey) slotB = inA;
  if(n(inB.name) && n(inB.name)===aKey) slotA = inB;
  if(n(inB.name) && n(inB.name)===bKey) slotB = inB;

  // Om namnen saknas eller inte matchar: fallback till ordning A->A, B->B
  if(!slotA) slotA = inA;
  if(!slotB) slotB = inB;

  // Applicera
  _applySlider("avgA", slotA.avg, 20, 120);
  _applySlider("avgB", slotB.avg, 20, 120);
  _applySlider("f9A", slotA.first9, 30, 140);
  _applySlider("f9B", slotB.first9, 30, 140);
  _applySlider("coA", slotA.checkoutPct, 0, 100);
  _applySlider("coB", slotB.checkoutPct, 0, 100);

  syncStatSliders();

  // Spara till matchobjektet direkt s√• det f√∂ljer med "Spara"
  m.avgA = $("avgA").value;
  m.avgB = $("avgB").value;
  m.f9A  = $("f9A").value;
  m.f9B  = $("f9B").value;
  m.coA  = $("coA").value;
  m.coB  = $("coB").value;

  statsImportSetStatus("Importerat. Kontrollera v√§rdena och tryck sedan Spara.", true);
}
// ===== /Statsimport =====

function stopPropagation(e){ try{ if(e) e.stopPropagation(); }catch(_){} }
function uuid(){ return "p_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); }

// Fisher‚ÄìYates shuffle (returns a new array)
function shuffle(arr){
  const a = Array.isArray(arr) ? arr.slice() : [];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    const tmp=a[i]; a[i]=a[j]; a[j]=tmp;
  }
  return a;
}


let state = {
  step: 1,
  format: "round_robin",
  mode: "single",
  entryMode: "kiosk",
  repeats: 1,
  importedPlayers: null,  // f√∂rhandsvisning fr√•n manuella f√§lt (innan "Anv√§nd")
  rules: { game:"301", inRule:"single", outRule:"single", legsMode:"single" },
  players: [],
  groups: { A: [], B: [] },
  matches: [],
  startedAt: null,
  playoffs: { started:false, matches: [] }
};

state.playerSource = "manual";

let modal = { id:null };

function saveState(){
  try{
    const json = JSON.stringify(state);
    storageSet(STORAGE_KEY, json);
    // P√• Android/Chrome med lokala filer (file://) kan localStorage vara op√•litligt vid reload.
    // Spegla d√§rf√∂r √§ven till window.name s√• att uppdatering i samma flik alltid kan √•terst√§lla.
    try{
      if(typeof location !== "undefined" && location.protocol === "file:"){
        const obj = _nameStoreRead() || {};
        obj[STORAGE_KEY] = json;
        _nameStoreWrite(obj);
      }
    }catch(e){}
  }catch(e){}

  // Local Hub: om turneringen har ett tournamentId, spara √§ven i biblioteket
  // s√• att "√ñppna" alltid √•terst√§ller senaste √§ndringar.
  try{
    if(typeof window !== 'undefined' && typeof window.__hubPersistCurrent === 'function'){
      window.__hubPersistCurrent();
    }
  }catch(e){}
}

// Spara en "senaste"-kopia f√∂r snabb √•terst√§llning vid oavsiktlig uppdatering.
// Anropas vid Skapa turnering och Spara match.
function autosaveTournament(){
  try{
    const payload = { savedAt: new Date().toISOString(), state: state };
    const json = JSON.stringify(payload);
    storageSet(AUTOSAVE_KEY, json);
    // Spegla √§ven till window.name f√∂r stabil √•terst√§llning vid reload p√• file://
    try{
      if(typeof location !== "undefined" && location.protocol === "file:"){
        const obj = _nameStoreRead() || {};
        obj[AUTOSAVE_KEY] = json;
        _nameStoreWrite(obj);
      }
    }catch(e){}
  }catch(e){}

  // Local Hub: spegla √§ven autosave till biblioteket
  try{
    if(typeof window !== 'undefined' && typeof window.__hubPersistCurrent === 'function'){
      window.__hubPersistCurrent();
    }
  }catch(e){}
}

function loadAutosaveTournament(){
  try{
    let raw = storageGet(AUTOSAVE_KEY);
    if(!raw){
      // Om storage finns men inte h√∂ll vid reload (vanligt f√∂r file:// p√• mobil),
      // f√∂rs√∂k √§ven l√§sa direkt fr√•n window.name-speglingen.
      try{
        const obj = _nameStoreRead() || {};
        raw = obj[AUTOSAVE_KEY] || null;
      }catch(e){}
    }
    if(!raw) return false;
    const parsed = JSON.parse(raw);
    if(parsed && parsed.state && parsed.state.rules && parsed.state.step){
      state = parsed.state;
      // H√§rda mot gamla versioner / saknade f√§lt
      if(!state.playerSource) state.playerSource = "manual";
      if(state.playerSource !== "manual") state.playerSource = "manual";
      if(!state.mode) state.mode="single";
      if(state.mode!=="single" && state.mode!=="team") state.mode="single";
      if(!state.entryMode) state.entryMode="import";
      if(state.entryMode!=="import" && state.entryMode!=="kiosk") state.entryMode="import";
      if(!state.repeats) state.repeats = 1;
      return true;
    }
  }catch(e){}
  return false;
}
function loadState(){
  const raw = storageGet(STORAGE_KEY);
  if(!raw) return false;
  try{
    const parsed = JSON.parse(raw);
    if(parsed && parsed.rules && parsed.step){
      state = parsed;

      // Skydd mot gamla versioner som sparat fil-l√§ge eller saknar f√§lt
      if(!state.playerSource) state.playerSource = "manual";
      if(state.playerSource !== "manual") state.playerSource = "manual";
      if(!state.mode) state.mode="single";
      if(state.mode!=="single" && state.mode!=="team") state.mode="single";
      if(!state.entryMode) state.entryMode="import";
      if(state.entryMode!=="import" && state.entryMode!=="kiosk") state.entryMode="import";
      if(!state.repeats) state.repeats = 1;
      if(!state.playoffs) state.playoffs = { started:false, matches: [] };
      // Antal grupper (2 = standard, 4 = ut√∂kat)
      if(!state.numGroups){
        try{
          var keys = state.groups ? Object.keys(state.groups) : [];
          state.numGroups = (keys && keys.length >= 4) ? 4 : 2;
        }catch(e){
          state.numGroups = 2;
        }
      }
      if(!state.groups){
        state.groups = (state.numGroups===4) ? { A: [], B: [], C: [], D: [] } : { A: [], B: [] };
      }else{
        // S√§kerst√§ll att nycklar finns n√§r man byter/√∂ppnar √§ldre turneringar
        if(state.numGroups===4){
          if(!state.groups.C) state.groups.C = [];
          if(!state.groups.D) state.groups.D = [];
        }
      }
      if(!state.matches) state.matches = [];

      if(!state.startedAt){
        // Om turnering redan finns men saknar starttid, s√§tt den till nu.
        const hasData = (state.players && state.players.length) || (state.matches && state.matches.length) || (state.groups && ((state.groups && state.groups.A && state.groups.A.length)||(state.groups && state.groups.B && state.groups.B.length)));
        state.startedAt = hasData ? new Date().toISOString() : null;
      }

      return true;
    }
  }catch(e){}
  return false;
}

function renderAll(){
  setStepper();
  $("format").value = state.format;
  if($("numGroups")) $("numGroups").value = String(state.numGroups || 2);
  try{ onFormatChange(); }catch(e){}
  $("game").value = state.rules.game;
  $("inRule").value = state.rules.inRule;
  $("outRule").value = state.rules.outRule;
  $("legsMode").value = state.rules.legsMode;

  var ids = ["step1","step2","step3","step4","stepMatches","stepTable","stepPlayoffs","stepTools"];
  ids.forEach(function(id){
    var el = document.getElementById(id);
    if(el) el.classList.add("hidden");
  });

  var nums = getStepNums();
  // Normalisera gammalt sparat steg (om appen uppdaterats)
  if(state.step > nums.tools) state.step = 1;

  var activeId = stepId(state.step);
  var activeEl = document.getElementById(activeId);
  if(activeEl) activeEl.classList.remove("hidden");


  if(state.step===3) renderPlayersStep();

  if(nums.isGroup && state.step===nums.groups) renderGroups();

  if(state.step===nums.matches){
    renderMatches();
    renderDailyMatch();
  }

  if(state.step===nums.table){
    renderStandings();
    // Visa slutspel-knappen n√§r gruppspel + slutspel √§r valt och gruppspelet √§r klart
    var ns = document.getElementById('nextStageWrap');
    if(ns){
      if(state.format==='group_playoffs' && groupStageComplete()) ns.classList.remove('hidden');
      else ns.classList.add('hidden');
    }
  }

  if(state.step===nums.playoffs){
    renderPlayoffs();
    renderTournamentSummary();
  }
  applyStartStamp();
  updateProgress();
  saveState();
}


function resetAll(){
  if(!confirm("Nollst√§lla allt?")) return;
  storageDel(STORAGE_KEY);

  // state
  state.step = 1;
  state.mode = 'single';
  state.entryMode = 'import';
  state.format = "round_robin";
  state.rules = { game:"301", inRule:"single", outRule:"single", legsMode:"single" };
  state.players = [];
  state.numGroups = parseInt(($("numGroups") && $("numGroups").value) || state.numGroups || "2", 10) || 2;
    state.groups = (state.numGroups===4) ? {A:[], B:[], C:[], D:[]} : {A:[], B:[]};
  state.matches = [];
  state.playoffs = { started:false, matches: [] };
  state.startedAt = null;

  // rensa ev. inmatningsf√§lt (f√∂r att undvika sp√∂kdata p√• mobil)
  var ids = [
    'players','walkonLabels','spotifyLinks','darts',
    'teamNames','teamMember1','teamMember2','teamSpotify','teamDarts',
    'kSingleName','kSingleSpotify','kSingleDarts',
    'kTeamName','kTeamP1','kTeamP2','kTeamSpotify','kTeamDarts',
    'quickImportBox'
  ];
  for(var i=0;i<ids.length;i++){
    var el=document.getElementById(ids[i]);
    if(el && typeof el.value !== 'undefined') el.value='';
  }

  renderAll();
}

function exportPDF(){
  // Bygger en sammanst√§llning (Slutspel ‚Üí Matcher ‚Üí Tabell) och √∂ppnar browserns utskrift (Spara som PDF).
  try{ buildPrintView(); }catch(e){ console.error(e); }
  try{ window.scrollTo(0,0); }catch(e){}
  window.print();
}

function buildPrintView(){
  var finalsDst = document.getElementById('print-finals-content');
  var matchesDst = document.getElementById('print-matches-content');
  var tableDst = document.getElementById('print-table-content');
  if(!finalsDst || !matchesDst || !tableDst) return;

  finalsDst.innerHTML = '';
  matchesDst.innerHTML = '';
  tableDst.innerHTML = '';

  function cloneInto(dst, el){
    if(!el) return;
    var c = el.cloneNode(true);
    // S√§kerst√§ll att dolda/export-hide element inte st√∂r utskrift
    if(c.classList && c.classList.contains('hidden')) c.classList.remove('hidden');
    dst.appendChild(c);
  }

  // Slutspel: sammanfattning + tabell (om finns)
  cloneInto(finalsDst, document.getElementById('tourneySummary'));
  cloneInto(finalsDst, document.getElementById('playoffsTable'));
  if(finalsDst.innerHTML.trim()===''){
    finalsDst.innerHTML = '<div class="small">Inget slutspel att visa.</div>';
  }

  // Matcher
  cloneInto(matchesDst, document.getElementById('matchesTable'));

  // Tabell
  cloneInto(tableDst, document.getElementById('standingsWrap'));

  // Undvik sidbryt mitt i rader/tabeller (s√• l√•ngt webbl√§saren till√•ter)
  document.getElementById('printRoot').querySelectorAll('table, tr').forEach(function(n){
    n.classList.add('avoid-break');
  });
}


function openPlayerModal(pid){
  try{
  var p = playerById(pid); if(!p) return;
  var st = computeStandings(state.players.map(function(x){return x.id;}), state.matches, null);
  var row = st.find(function(x){ return x.pid===pid; });
  var title = playerName(pid);
  document.getElementById("playerTitle").textContent = title;

  // Profilbild i profilkortet: anv√§nd sparad avatar om den finns, annars initialer
  var kindForAvatar = (p && p.type==='team') ? "team" : "single";
  var avatarPid = (typeof findSavedPlayerIdByName==="function") ? findSavedPlayerIdByName(title, kindForAvatar) : null;

  var btnA = document.getElementById("playerAvatarBtn");
  var initA = document.getElementById("playerAvatarInitials");
  if(btnA){
    btnA.setAttribute("data-avatar-pid", avatarPid || "");
    btnA.setAttribute("data-avatar-name", title || "");
    if(initA) initA.textContent = _avatarInitials(title||"") || "?";
    try{ hydrateAvatarsIn(btnA.parentNode || btnA); }catch(e){}
    btnA.onclick = function(ev){
      try{ ev.stopPropagation(); }catch(e){}
      try{ openAvatarModal(avatarPid, title); }catch(e){}
    };
  }
  var sub = [];
  if(p && p.type==='team' && p.members){
    var mem = p.members.filter(Boolean).join(' & ');
    if(mem) sub.push('Medlemmar: ' + mem);
  }
  if(row){
    sub.push("Matcher idag: " + row.played + " ‚Ä¢ V: " + row.w + " ‚Ä¢ F: " + row.l + " ‚Ä¢ P: " + row.pts);
    if(row.avg!=null) sub.push("Avg: " + (Math.round(row.avg*10)/10).toFixed(1));
    if(row.f9!=null) sub.push("F9: " + (Math.round(row.f9*10)/10).toFixed(1));
    if(row.co!=null) sub.push("Utg%: " + (Math.round(row.co*10)/10).toFixed(1));
  }
  document.getElementById("playerSubtitle").textContent = sub.join(" ‚Ä¢ ");

  var body = "";
  var dartsInfo = (p.darts||"").trim();
  if(dartsInfo){
    body += "<div class='card' style='margin:0 0 10px 0'><strong>Pilar</strong><div class='small' style='margin-top:6px'>"+escapeHtml(dartsInfo)+"</div></div>";
  }
  if(p.walkonLabel || p.walkonUrl){
    var url = (p.walkonUrl||"").trim();
    var rawLabel = (p.walkonLabel||"").trim();
    // Backward-compatible: om √§ldre data sparat l√§nken i "walkonLabel" (och inte i walkonUrl)
    // s√• ska den √§nd√• bli klickbar.
    var inferredUrl = url || (rawLabel && looksLikeUrl(rawLabel) ? rawLabel : "");
    var urlEsc = inferredUrl ? escapeHtml(inferredUrl) : "";
    var labelSafe = escapeHtml(rawLabel);

    // Om vi har en URL, g√∂r alltid en klickbar l√§nk (visa label om den inte bara √§r en URL).
    var textToShow = labelSafe && !(rawLabel && looksLikeUrl(rawLabel)) ? labelSafe : (urlEsc || "-");
    var labelHtml = urlEsc
      ? ("<a class='link' href='"+urlEsc+"' target='_blank' rel='noopener' onclick=\"stopPropagation(event)\">"+textToShow+"</a>")
      : (labelSafe || "-");
    body += "<div class='card' style='margin:0'><strong>Walk-on</strong>";
    if(urlEsc){
      body += "<div style='margin-top:8px'><a class='link' href='"+urlEsc+"' target='_blank' rel='noopener' onclick=\"stopPropagation(event)\">√ñppna i Spotify</a></div>";
    }
    body += "</div>";
  }else{
    body += "<div class='small'>Ingen walk-on song sparad.</div>";
  }


  // historik (sparad mellan turneringar)
  try{
    var hKey = normName(title);
    var hs = computeHistorySummary(hKey);
    if(hs && hs.played){
      body += "<div class='card' style='margin-top:12px'><strong>Statistik</strong>";
      body += "<div class='small' style='margin-top:6px'>Matcher: "+hs.played+" ‚Ä¢ V: "+hs.w+" ‚Ä¢ F: "+hs.l+"</div>";
      body += "<div class='small'>VL: "+hs.legsW+"</div>";
      body += "<div class='small'>Avg: "+escapeHtml(fmtNum(hs.avg,1))+" ‚Ä¢ F9: "+escapeHtml(fmtNum(hs.f9,1))+" ‚Ä¢ Utg EO: "+escapeHtml(fmtNum(hs.coSingle,1))+" ‚Ä¢ Utg DO: "+escapeHtml(fmtNum(hs.coDouble,1))+"</div>";

      // Kul extra: Average-form + Personb√§sta (fr√•n historik)
      var ex = computeHistoryExtras(hKey);
      if(ex && ex.trend && ex.trend.delta!=null){
        var d = ex.trend.delta || 0;
        var arrow = d>0 ? "‚Üë" : (d<0 ? "‚Üì" : "‚Üí");
        var sign  = d>0 ? "+" : (d<0 ? "‚àí" : "");
        var abs   = Math.abs(d);
        body += "<div class='small' style='margin-top:10px'><strong>Average-form</strong> <span style='margin-left:6px'>"+arrow+" "+sign+escapeHtml(fmtNum(abs,1))+"</span></div>";
      }
      if(ex && ex.best!=null){
        var bestTxt = escapeHtml(fmtNum(ex.best,1));
        var oppTxt  = ex.bestOpp ? (" <span style='opacity:.75'>(vs "+escapeHtml(ex.bestOpp)+")</span>") : "";
        body += "<div class='small' style='margin-top:6px'><strong>Personb√§sta</strong> "+bestTxt+oppTxt+"</div>";
      }
      body += "<div style='display:flex; gap:10px; flex-wrap:wrap; margin-top:10px'><button class='btn secondary' onclick=\"openHistoryModal('"+pid+"')\">Historik</button><button class='btn danger' onclick=\"clearHistoryForPlayer('"+pid+"')\">Rensa historik</button></div>";
      body += "</div>";
    }
  }catch(e){}

  // senaste matcherna
  var recent = (state.matches||[]).filter(function(m){
    return m.winnerId && (m.aId===pid || m.bId===pid);
  }).slice(-5).reverse();
  if(recent.length){
    body += "<div style='margin-top:12px'><strong>Senaste matcher</strong></div>";
    body += "<table style='margin-top:8px'><tr><th>Match</th><th>Resultat</th></tr>";
    recent.forEach(function(m){
      var opp = (m.aId===pid) ? playerName(m.bId) : playerName(m.aId);
      var res = m.result || (state.rules.legsMode==='single' ? '1-0' : '');
      var win = (m.winnerId===pid) ? "V" : "F";
      body += "<tr><td>"+escapeHtml(opp)+"</td><td>"+win+" "+escapeHtml(res)+"</td></tr>";
    });
    body += "</table>";
  }

  document.getElementById("playerBody").innerHTML = body;
  document.getElementById("playerOverlay").classList.remove("hidden");
  }catch(e){
    console.error(e);
    alert("Kunde inte √∂ppna spelarkortet. Prova att ladda om sidan.");
  }
}
function closePlayerModal(){ document.getElementById("playerOverlay").classList.add("hidden"); }

function setModalLocked(isLocked){
  var banner = document.getElementById("lockedBanner");
  if(banner) banner.classList.toggle("hidden", !isLocked);

  var disable = isLocked;
  ["winA","winB","avgA","avgB","f9A","f9B","coA","coB","notes"].forEach(function(id){
    var el = document.getElementById(id);
    if(el) el.disabled = disable;
  });

  // result buttons
  var rb = document.getElementById("resultBtns");
  if(rb){
    rb.querySelectorAll("button").forEach(function(b){ b.disabled = disable; });
  }
  // clear/save buttons remain enabled, but saving while locked does nothing
  state.modalLocked = isLocked;
}

function enableEdit(){
  setModalLocked(false);
}

function getDailyMatch(){
  // pick played match with highest combined avg (if exists), else null
  var best = null, bestScore = -1;
  (state.matches||[]).forEach(function(m){
    if(!m.winnerId) return;
    var a = parseFloat(m.avgA); var b = parseFloat(m.avgB);
    if(isNaN(a) && isNaN(b)) return;
    var s = 0;
    if(!isNaN(a)) s += a;
    if(!isNaN(b)) s += b;
    if(s > bestScore){ bestScore = s; best = m; }
  });
  return best;
}

function renderDailyMatch(){
  var el = document.getElementById("dailyMatch");
  if(!el) return;
  var m = getDailyMatch();
  if(!m){
    el.innerHTML = "<span class='small'>Inga spelade matcher med average √§nnu.</span>";
    return;
  }
  var aName = playerName(m.aId), bName = playerName(m.bId);
  var res = m.result || (state.rules.legsMode==='single' ? '1-0' : '');
  var ctx = (m.group==='Alla'?'Serie':(m.group==='A'||m.group==='B'?'Grupp '+m.group:(m.round||"")));
  el.innerHTML = "<div class='row' style='justify-content:space-between;align-items:center'><div><strong>üî• Dagens match</strong><div class='small'>"+escapeHtml(ctx)+"</div></div><button class='btn secondary' onclick=\"openMatch('"+m.id+"')\">√ñppna</button></div>"
    + "<div style='margin-top:8px'>"+escapeHtml(aName)+" vs "+escapeHtml(bName)+" <span class='tag'>"+escapeHtml(res)+"</span></div>"
    + "<div class='small' style='margin-top:6px'>Avg: "+escapeHtml(m.avgA||'‚Äì')+" / "+escapeHtml(m.avgB||'‚Äì')+"</div>";
}

function tournamentWinnerId(){
  if(!state.playoffs || !state.playoffs.matches) return "";
  var fin = state.playoffs.matches.find(function(x){ return x.id==='po_f'; });
  return fin && fin.winnerId ? fin.winnerId : "";
}

function renderTournamentSummary(){
  var el = document.getElementById("tourneySummary");
  if(!el) return;
  var win = tournamentWinnerId();
  if(!win){
    el.innerHTML = "<span class='small'>Sammanfattning visas n√§r finalen √§r spelad.</span>";
    return;
  }
  var st = computeStandings(state.players.map(function(p){return p.id;}), state.matches.concat((state.playoffs&&state.playoffs.matches)||[]), null);
  function bestBy(key){
    var best = null, val = -1;
    st.forEach(function(r){
      var v = r[key];
      if(v==null) return;
      if(v>val){ val=v; best=r; }
    });
    return best ? {pid:best.pid, v:val} : null;
  }
  var bAvg = bestBy("avg");
  var bF9 = bestBy("f9");
  var bCo = bestBy("co");
  var html = "<div class='card' style='margin:0'><div class='row' style='justify-content:space-between;align-items:center'><div><strong>üèÜ Turneringen √§r avgjord</strong><div class='small'>Vinnare: <strong>"+escapeHtml(playerName(win))+"</strong></div></div></div>";
  html += "<div style='margin-top:10px' class='small'>";
  if(bAvg) html += "B√§sta Avg: <strong>"+escapeHtml(playerName(bAvg.pid))+"</strong> ("+(Math.round(bAvg.v*10)/10).toFixed(1)+")<br>";
  if(bF9) html += "B√§sta F9: <strong>"+escapeHtml(playerName(bF9.pid))+"</strong> ("+(Math.round(bF9.v*10)/10).toFixed(1)+")<br>";
  if(bCo) html += "B√§sta Utg%: <strong>"+escapeHtml(playerName(bCo.pid))+"</strong> ("+(Math.round(bCo.v*10)/10).toFixed(1)+")";
  html += "</div></div>";
  el.innerHTML = html;
}

function getStepNums(){
  var isGroup = (state.format && state.format.indexOf("group")===0);
  return {
    isGroup: isGroup,
    groups: isGroup ? 4 : null,
    matches: isGroup ? 5 : 4,
    table: isGroup ? 6 : 5,
    playoffs: isGroup ? 7 : 6,
    tools: isGroup ? 8 : 7
  };
}

function stepId(n){
  var nums = getStepNums();
  if(n===1) return "step1";
  if(n===2) return "step2";
  if(n===3) return "step3";
  if(nums.isGroup && n===nums.groups) return "step4";
  if(n===nums.matches) return "stepMatches";
  if(n===nums.table) return "stepTable";
  if(n===nums.playoffs) return "stepPlayoffs";
  if(n===nums.tools) return "stepTools";
  return "step1";
}

function setStepper(){
  var nums = getStepNums();
  var steps = [
    {n:1, t:"1. Uppl√§gg"},
    {n:2, t:"2. Spel"},
    {n:3, t:"3. Spelare"}
  ];
  if(nums.isGroup){
    steps.push({n:nums.groups, t:"4. Grupper"});
  }
  steps.push({n:nums.matches, t:(nums.isGroup?"5. Matcher":"4. Matcher")});
  steps.push({n:nums.table, t:(nums.isGroup?"6. Tabell":"5. Tabell")});
  steps.push({n:nums.playoffs, t:(nums.isGroup?"7. Slutspel":"6. Slutspel")});
  steps.push({n:nums.tools, t:(nums.isGroup?"8. Verktyg":"7. Verktyg")});

  $("stepper").innerHTML = '<span class="step" onclick="goStart()">Start</span>' + steps.map(function(s){
    return '<span class="step '+(state.step===s.n?'active':'')+'" onclick="goStep('+s.n+')">'+s.t+'</span>';
  }).join("");
  try{ hydrateAvatarsIn(box); }catch(e){}
}



function goStart(){
  // Navigera till "Lokala turneringar" (hubben d√§r man kan √∂ppna/ladda turneringar)
  // Viktigt: ingen history/hash-navigering h√§r, annars triggas back-guard overlay p√• vissa Android-webviews.
  try{ doSave(true); }catch(e){}
  try{
    if(typeof window.__showLocalHub === "function"){
      window.__showLocalHub();
    }else{
      // Fallback: visa localHubScreen direkt om hj√§lpfunktionen saknas
      try{
        var el = document.getElementById("localHubScreen");
        if(el){
          // d√∂lj startsida om den finns
          try{ document.getElementById("startScreen")?.classList.remove("active"); }catch(e){}
          el.classList.add("active");
          el.setAttribute("aria-hidden","false");
        }
      }catch(e2){}
    }
  }catch(e){}
  try{ window.scrollTo(0,0); }catch(e){}
}


function goStep(n){
  var nums = getStepNums();
  if(state.step===1){ state.format = $("format").value; var ng = $("numGroups"); if(ng) state.numGroups = parseInt(ng.value||"2",10)||2; }
  if(state.step===2){
    state.rules.game = $("game").value;
    state.rules.inRule = $("inRule").value;
    state.rules.outRule = $("outRule").value;
    state.rules.legsMode = $("legsMode").value;
  }

  // Kr√§v att turnering/matcher √§r skapade innan man g√•r till Matcher/Tabell/Slutspel
  if((n===nums.matches || n===nums.table || n===nums.playoffs) && (!state.matches || state.matches.length===0)){
    alert("Skapa turnering f√∂rst (steg 3).");
    return;
  }

  state.step = n;
  saveState();
  renderAll();
  try{ window.scrollTo(0,0); }catch(e){}
}


function escapeHtml(s){
  return (""+s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[c]));
}

function escapeAttr(s){
  return escapeHtml(String(s||"")).replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function escapeJs(s){
  return String(s||"")
    .replace(/\\/g,"\\\\")
    .replace(/'/g,"\\'")
    .replace(/\n/g," ")
    .replace(/\r/g," ");
}

// Robust ID-generator (f√∂r spelare/matcher) som funkar √§ven i √§ldre mobilwebbl√§sare.
// - F√∂redrar crypto.randomUUID()
// - Annars crypto.getRandomValues()
// - Annars Math.random() fallback
function cryptoId(){
  try{
    if(window.crypto && typeof window.crypto.randomUUID === "function"){
      return window.crypto.randomUUID();
    }
    if(window.crypto && typeof window.crypto.getRandomValues === "function"){
      const bytes = new Uint8Array(16);
      window.crypto.getRandomValues(bytes);
      // S√§tt version/variant-bitar ungef√§r som UUIDv4 (inte kritiskt, men trevligt).
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = [...bytes].map(b=>b.toString(16).padStart(2,"0")).join("");
      return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
    }
  }catch(e){ /* fall through */ }
  // Fallback: tillr√§ckligt unikt f√∂r denna app
  return "id_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
}

function parseLines(text){
  return (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
}

function setEntryMode(mode){
  state.entryMode = mode;
  if(state.entryMode!=='import' && state.entryMode!=='kiosk') state.entryMode='import';
  applyEntryUI();
  var ks=document.getElementById('kioskStatus'); if(ks) ks.textContent='';
  savedEditingPlayerId=null; savedEditingTeamId=null;
  try{ renderKioskList(); }catch(e){}
  saveState();
}

function applyEntryUI(){
  var isTeam = (state.mode==='team');
  var minTxt = document.getElementById('minParticipantsText');
  if(minTxt) minTxt.textContent = isTeam ? 'Minst 3 lag.' : 'Minst 3 spelare.';

  // v√§xla mellan singel- och lagf√§lt
  var teamWrap = document.getElementById('teamFieldsWrap');
  if(teamWrap) teamWrap.classList.toggle('hidden', (!isTeam) || (state.entryMode!=='import'));

  // v√§xla mellan import och kiosk
  var kioskWrap = document.getElementById('entryKioskWrap');
  if(kioskWrap) kioskWrap.classList.toggle('hidden', state.entryMode!=='kiosk');

  var importWrap = document.getElementById('manualPlayersWrap');
  if(importWrap) importWrap.classList.toggle('hidden', (state.entryMode!=='import' || isTeam));

  // knapparnas "valda" k√§nsla
  var bI = document.getElementById('btnEntryImport');
  var bK = document.getElementById('btnEntryKiosk');
  if(bI) bI.style.opacity = (state.entryMode==='import') ? '1' : '0.75';
  if(bK) bK.style.opacity = (state.entryMode==='kiosk') ? '1' : '0.75';

  // kiosk: visa r√§tt formul√§r beroende p√• l√§ge
  var ks=document.getElementById('kioskSingleForm');
  var kt=document.getElementById('kioskTeamForm');
  var ktit=document.getElementById('kioskTitle');
  if(ks) ks.classList.toggle('hidden', isTeam);
  if(kt) kt.classList.toggle('hidden', !isTeam);
  if(ktit) ktit.textContent = isTeam ? 'L√§gg till lag' : 'L√§gg till spelare';

  // synka select
  var ms=document.getElementById('mode');
  if(ms && ms.value !== state.mode) ms.value = state.mode;

  var ks=document.getElementById('kioskStatus'); if(ks) ks.textContent='';
  try{ refreshSavedDropdowns(); 
    
    try{ if(window.__modalAvatarPid) window.__modalAvatarPid.single = null; }catch(e){}
try{ if(window.__modalAvatarPid) window.__modalAvatarPid.team = null; }catch(e){}
}catch(e){}
  renderKioskList();
}

function openSpotify(){
  var url = 'https://open.spotify.com/search';
  try{ window.location.href = url; }catch(e){}
}

function defocusKeyboard(){
  try{
    var ae = document.activeElement;
    if(ae && typeof ae.blur === 'function') ae.blur();
  }catch(e){}
  try{
    var sink = document.getElementById('focusSink');
    if(sink && typeof sink.focus === 'function') sink.focus({preventScroll:true});
  }catch(e){}
}



// ---- Sparade profiler (lokalt p√• enheten) ----
const SAVED_PLAYERS_KEY = "dart_saved_players_v1";
const SAVED_TEAMS_KEY = "dart_saved_teams_v1";


// Hj√§lp: hitta saved profile-id via namn (f√∂r att koppla avatar -> playerId)
function findSavedPlayerIdByName(name, kind){
  kind = (kind==="team") ? "team" : "single";
  var key = (kind==="team") ? SAVED_TEAMS_KEY : SAVED_PLAYERS_KEY;
  try{
    var list = _loadSaved(key) || [];
    var low = (name||"").trim().toLowerCase();
    var rec = list.find(function(p){
      var nm = (kind==="team") ? (p.teamName||"") : (p.name||"");
      return (nm||"").trim().toLowerCase() === low;
    });
    return rec ? rec.id : null;
  }catch(e){
    return null;
  }
}

let savedEditingPlayerId = null;
let savedEditingTeamId = null;

function _loadSaved(key){
  try{
    const raw = localStorage.getItem(key);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function _saveSaved(key, arr){
  try{ localStorage.setItem(key, JSON.stringify(arr||[])); }catch(e){}
}
function _byId(arr, id){ return (arr||[]).find(x=>x && x.id===id) || null; }

function refreshSavedDropdowns(){
  const spSel = document.getElementById("savedPlayerSelect");
  const tmSel = document.getElementById("savedTeamSelect");
  const dl = document.getElementById("singlePlayersList");

  const players = _loadSaved(SAVED_PLAYERS_KEY).sort((a,b)=>((a.name||"").localeCompare(b.name||"", 'sv')));
  const teams = _loadSaved(SAVED_TEAMS_KEY).sort((a,b)=>((a.teamName||"").localeCompare(b.teamName||"", 'sv')));

  if(spSel){
    spSel.innerHTML = '<option value="">‚Äî V√§lj ‚Äî</option>' + players.map(p=>{
      const t = escapeHtml(p.name||"");
      return '<option value="'+escapeHtml(p.id)+'">'+t+'</option>';
    }).join("");
  }
  if(tmSel){
    tmSel.innerHTML = '<option value="">‚Äî V√§lj ‚Äî</option>' + teams.map(t=>{
      const n = escapeHtml(t.teamName||"");
      return '<option value="'+escapeHtml(t.id)+'">'+n+'</option>';
    }).join("");
  }

  // Datalist f√∂r att kunna v√§lja redan registrerade singelspelare n√§r man bygger lag
  if(dl){
    dl.innerHTML = players.map(p=>{
      const t = escapeHtml(p.name||"");
      return '<option value="'+t+'"></option>';
    }).join("");
  }
}

// Tar bort ett option-element ur en <select> direkt (snabb UI-uppdatering)
function _removeSelectOptionByValue(sel, value){
  try{
    if(!sel || !value) return;
    // Om value finns, ta bort alla matchande options
    for(let i = sel.options.length - 1; i >= 0; i--){
      if(sel.options[i] && sel.options[i].value === value){
        sel.remove(i);
      }
    }
    // S√§kerst√§ll att ingen "d√∂d" value √§r vald
    if(sel.value === value) sel.value = "";
  }catch(e){}
}


function savedLoad(kind){
  if(kind==="team"){
    const sel = document.getElementById("savedTeamSelect");
    const id = sel ? sel.value : "";
    if(!id){ alert("V√§lj ett lag i rullistan f√∂rst."); return; }
    const list = _loadSaved(SAVED_TEAMS_KEY);
    const t = _byId(list, id);
    if(!t){ alert("Kunde inte hitta laget."); return; }
    savedEditingTeamId = t.id;
    document.getElementById("kTeamName").value = t.teamName||"";
    document.getElementById("kTeamP1").value = (t.members && t.members[0]) ? t.members[0] : (t.p1||"");
    document.getElementById("kTeamP2").value = (t.members && t.members[1]) ? t.members[1] : (t.p2||"");
    document.getElementById("kTeamSpotify").value = t.spotify||"";
    document.getElementById("kTeamDarts").value = t.darts||"";
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Laddat lag: " + (t.teamName||"");
    return true;
  }else{
    const sel = document.getElementById("savedPlayerSelect");
    const id = sel ? sel.value : "";
    if(!id){ alert("V√§lj en spelare i rullistan f√∂rst."); return; }
    const list = _loadSaved(SAVED_PLAYERS_KEY);
    const p = _byId(list, id);
    if(!p){ alert("Kunde inte hitta spelaren."); return; }
    savedEditingPlayerId = p.id;
    document.getElementById("kName").value = p.name||"";
    document.getElementById("kSpotify").value = p.spotify||"";
    document.getElementById("kDarts").value = p.darts||"";
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Laddat: " + (p.name||"");
  }
}

// Snabbt: v√§lj sparad profil och l√§gg till direkt i turneringen (utan att scrolla)
function savedQuickAdd(kind){
  // Robust: anv√§nd alltid aktuellt turneringsl√§ge som k√§lla till sanning
  var mode = (typeof state !== "undefined" && state && state.mode) ? state.mode : "single";
  var effectiveKind = (mode === "team") ? "team" : "single";

  // Om fel kind skickats, r√§tta automatiskt
  if(kind !== "team" && kind !== "single") kind = effectiveKind;

  // Om UI visar den andra listan (t.ex. efter l√§gesbyte), fall back till den som har val
  var selPrimary = document.getElementById(kind === "team" ? "savedTeamSelect" : "savedPlayerSelect");
  var selSecondary = document.getElementById(kind === "team" ? "savedPlayerSelect" : "savedTeamSelect");

  var id = (selPrimary && selPrimary.value) ? selPrimary.value : "";
  if(!id && selPrimary && selPrimary.selectedIndex > 0){
    id = selPrimary.options[selPrimary.selectedIndex].value || "";
  }
  if(!id && selSecondary){
    var sid = selSecondary.value || "";
    if(!sid && selSecondary.selectedIndex > 0){
      sid = selSecondary.options[selSecondary.selectedIndex].value || "";
    }
    if(sid){
      // Byt kind till den listan anv√§ndaren faktiskt valde i
      kind = (kind === "team") ? "single" : "team";
      id = sid;
    }
  }

  if(!id){
    alert("V√§lj en spelare i rullistan f√∂rst.");
    return;
  }

  // Ladda profilen direkt (utan att kr√§va separat 'Ladda'-klick)
  savedLoad(kind);

  // L√§gg till i turneringen
  if(kind === "team"){
    kioskAddTeam();
  }else{
    kioskAddSingle();
  }
}



function savedDelete(kind){
  try{
    const isTeam = (kind === "team");

    // F√∂redra modalens rullista om den finns (Ny / √Ñndra)
    const modalSelId = isTeam ? "modalSavedTeamSelect" : "modalSavedPlayerSelect";
    const mainSelId  = isTeam ? "savedTeamSelect" : "savedPlayerSelect";
    const modalSel = document.getElementById(modalSelId);
    const mainSel  = document.getElementById(mainSelId);

    const id = (modalSel && modalSel.value) ? modalSel.value : (mainSel ? mainSel.value : "");
    if(!id){
      toast("V√§lj en profil att ta bort.");
      return;
    }

    // En enda bekr√§ftelse (r√§cker)
    if(!confirm("Ta bort profilen permanent?")) return;

    const key = isTeam ? SAVED_TEAMS_KEY : SAVED_PLAYERS_KEY;
    const list = _loadSaved(key).filter(x => x && x.id !== id);
    _saveSaved(key, list);

    // Ta bort option direkt ur rullistorna (s√• det f√∂rsvinner utan flikbyte)
    _removeSelectOptionByValue(modalSel, id);
    _removeSelectOptionByValue(mainSel, id);

    // Nollst√§ll val i b√•da rullistorna
    if(modalSel) modalSel.value = "";
    if(mainSel)  mainSel.value  = "";

    // Nollst√§ll ev. laddat formul√§r
    if(isTeam){
      state.kiosk.team.selectedSavedId = "";
      state.kiosk.team.teamName = "";
      state.kiosk.team.spotify = "";
      state.kiosk.team.darts = "";
    }else{
      state.kiosk.player.selectedSavedId = "";
      state.kiosk.player.name = "";
      state.kiosk.player.spotify = "";
      state.kiosk.player.darts = "";
    }

    refreshSavedDropdowns();
    // Uppdatera √§ven modalens rullista direkt om den √§r √∂ppen
    if(typeof refreshNewPlayerModalSelect === "function"){
      refreshNewPlayerModalSelect(isTeam ? "team" : "single");
    }

    
    // Uppdatera huvudvyns rullistor s√• att borttagen profil f√∂rsvinner direkt
    if(typeof refreshSavedDropdowns === "function"){
      refreshSavedDropdowns();
      if(mainSel) mainSel.value = "";
      if(modalSel) modalSel.value = "";
    }

// Rendera om spelarsidan (r√§tt funktion i denna fil)
    if(typeof renderPlayersStep === "function") renderPlayersStep();
    else if(typeof renderAll === "function") renderAll();

    toast("Profil borttagen.");
  }catch(e){
    console.error(e);
    toast("Kunde inte ta bort profilen.");
  }
}


function savedUpsertFromForm(kind){
  if(kind==="team"){
    const teamName = (document.getElementById("kTeamName").value||"").trim();
    const p1 = (document.getElementById("kTeamP1").value||"").trim();
    const p2 = (document.getElementById("kTeamP2").value||"").trim();
    if(!teamName){ alert("Skriv in ett lagnamn."); return false; }
    if(!p1 || !p2){ alert("Fyll i b√•da spelarna i laget."); return false; }
    const spotify = (document.getElementById("kTeamSpotify").value||"").trim();
    const darts = (document.getElementById("kTeamDarts").value||"").trim();

    let list = _loadSaved(SAVED_TEAMS_KEY);
    const id = savedEditingTeamId || cryptoId();
    // F√∂rhindra att man r√•kar skapa dubletter med samma namn (om det inte √§r samma id)
    try{
      var low = (teamName||"").trim().toLowerCase();
      var clash = list.find(function(x){
        return x && x.id !== id && ((x.teamName||"").trim().toLowerCase() === low);
      });
      if(clash){ toast("Lagnamnet √§r redan sparat."); return false; }
    }catch(e){}
    const existing = _byId(list, id);
    const obj = { id, teamName, members:[p1,p2], spotify, darts };
    if(existing){
      Object.assign(existing, obj);
    }else{
      list.push(obj);
      savedEditingTeamId = id;
    }
    _saveSaved(SAVED_TEAMS_KEY, list);
    refreshSavedDropdowns();
    const sel = document.getElementById("savedTeamSelect"); if(sel) sel.value = id;
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Lag uppdaterat: " + teamName;
    toast("Laget √§r uppdaterat.");
    return true;
  }else{
    const name = (document.getElementById("kName").value||"").trim();
    if(!name){ alert("Skriv in ett namn."); return false; }
    const spotify = (document.getElementById("kSpotify").value||"").trim();
    const darts = (document.getElementById("kDarts").value||"").trim();

    let list = _loadSaved(SAVED_PLAYERS_KEY);
    const id = savedEditingPlayerId || cryptoId();
    // F√∂rhindra att man r√•kar skapa dubletter med samma namn (om det inte √§r samma id)
    try{
      var low = (name||"").trim().toLowerCase();
      var clash = list.find(function(x){
        return x && x.id !== id && ((x.name||"").trim().toLowerCase() === low);
      });
      if(clash){ toast("Spelaren √§r redan sparad."); return false; }
    }catch(e){}
    const existing = _byId(list, id);
    const obj = { id, name, spotify, darts };
    if(existing){
      Object.assign(existing, obj);
    }else{
      list.push(obj);
      savedEditingPlayerId = id;
    }
    _saveSaved(SAVED_PLAYERS_KEY, list);
    refreshSavedDropdowns();
    const sel = document.getElementById("savedPlayerSelect"); if(sel) sel.value = id;
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Spelare uppdaterad: " + name;
    toast("Spelaren √§r uppdaterad.");
    return true;
  }
}

// Om en spelare/lag redan ligger under "Tillagda" f√∂r aktuell turnering, uppdatera raderna d√§r ocks√•
function _updateAddedSingleLines(oldName, newName, spotify, darts){
  try{
    oldName = (oldName||"").trim();
    newName = (newName||"").trim();
    if(!oldName || !newName) return;
    var p = document.getElementById('players');
    var s = document.getElementById('spotifyLinks');
    var d = document.getElementById('darts');
    if(!p || !s || !d) return;
    var pLines = parseLines(p.value);
    var sLines = parseLines(s.value);
    var dLines = parseLines(d.value);
    var lowOld = oldName.toLowerCase();
    for(var i=0;i<pLines.length;i++){
      if(((pLines[i]||"").trim().toLowerCase()) === lowOld){
        pLines[i] = newName;
        // s√§kra att arrayerna √§r l√•nga nog
        while(sLines.length < pLines.length) sLines.push('');
        while(dLines.length < pLines.length) dLines.push('');
        sLines[i] = spotify || '';
        dLines[i] = darts || '';
        break;
      }
    }
    p.value = pLines.join('\n');
    s.value = sLines.join('\n');
    d.value = dLines.join('\n');
  }catch(e){}
}

function _updateAddedTeamLines(oldTeamName, newTeamName, p1, p2, spotify, darts){
  try{
    oldTeamName = (oldTeamName||"").trim();
    newTeamName = (newTeamName||"").trim();
    if(!oldTeamName || !newTeamName) return;
    var tn = document.getElementById('teamNames');
    var m1 = document.getElementById('teamMember1');
    var m2 = document.getElementById('teamMember2');
    var sp = document.getElementById('teamSpotify');
    var da = document.getElementById('teamDarts');
    if(!tn || !m1 || !m2 || !sp || !da) return;
    var tLines = parseLines(tn.value);
    var m1Lines = parseLines(m1.value);
    var m2Lines = parseLines(m2.value);
    var spLines = parseLines(sp.value);
    var daLines = parseLines(da.value);
    var lowOld = oldTeamName.toLowerCase();
    for(var i=0;i<tLines.length;i++){
      if(((tLines[i]||"").trim().toLowerCase()) === lowOld){
        tLines[i] = newTeamName;
        while(m1Lines.length < tLines.length) m1Lines.push('');
        while(m2Lines.length < tLines.length) m2Lines.push('');
        while(spLines.length < tLines.length) spLines.push('');
        while(daLines.length < tLines.length) daLines.push('');
        m1Lines[i] = p1 || '';
        m2Lines[i] = p2 || '';
        spLines[i] = spotify || '';
        daLines[i] = darts || '';
        break;
      }
    }
    tn.value = tLines.join('\n');
    m1.value = m1Lines.join('\n');
    m2.value = m2Lines.join('\n');
    sp.value = spLines.join('\n');
    da.value = daLines.join('\n');
  }catch(e){}
}

function savedSaveNewFromForm(kind){
  if(kind==="team"){
    const teamName = (document.getElementById("kTeamName").value||"").trim();
    const p1 = (document.getElementById("kTeamP1").value||"").trim();
    const p2 = (document.getElementById("kTeamP2").value||"").trim();
    if(!teamName){ alert("Skriv in ett lagnamn."); return false; }
    if(!p1 || !p2){ alert("Fyll i b√•da spelarna i laget."); return false; }
    const spotify = (document.getElementById("kTeamSpotify").value||"").trim();
    const darts = (document.getElementById("kTeamDarts").value||"").trim();

    let list = _loadSaved(SAVED_TEAMS_KEY);

    // Om vi importerat en profil med avatar i modalen s√• finns ofta ett "f√∂r-reserverat" pid.
    // Anv√§nd samma id h√§r s√• att avatar (IndexedDB) och profil f√•r exakt samma nyckel direkt.
    var preId = null;
    try{ preId = (typeof savedEditingTeamId!=="undefined" && savedEditingTeamId) ? savedEditingTeamId : null; }catch(e){}
    try{ if(!preId && window.__modalAvatarPid) preId = window.__modalAvatarPid.team || null; }catch(e){}
    const id = preId || cryptoId();

    const rec = { id, teamName, members:[p1,p2], spotify, darts };
    const idx = list.findIndex(function(x){ return x && x.id === id; });
    if(idx >= 0) list[idx] = rec; else list.push(rec);

    _saveSaved(SAVED_TEAMS_KEY, list);
    refreshSavedDropdowns();

    // nollst√§ll f√§lten s√• man kan skriva n√§sta direkt
    savedEditingTeamId = null;
    const sel = document.getElementById("savedTeamSelect"); if(sel) sel.value = "";
    document.getElementById("kTeamName").value = "";
    document.getElementById("kTeamP1").value = "";
    document.getElementById("kTeamP2").value = "";
    document.getElementById("kTeamSpotify").value = "";
    document.getElementById("kTeamDarts").value = "";
    try{ document.getElementById("kTeamName").focus(); }catch(e){}
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Sparat som ny: " + teamName;
    return true;
  }else{
    const name = (document.getElementById("kName").value||"").trim();
    if(!name){ alert("Skriv in ett namn."); return false; }
    const spotify = (document.getElementById("kSpotify").value||"").trim();
    const darts = (document.getElementById("kDarts").value||"").trim();

    let list = _loadSaved(SAVED_PLAYERS_KEY);

    // Om vi importerat en profil med avatar i modalen s√• finns ofta ett "f√∂r-reserverat" pid.
    // Anv√§nd samma id h√§r s√• att avatar (IndexedDB) och profil f√•r exakt samma nyckel direkt.
    var preId = null;
    try{ preId = (typeof savedEditingPlayerId!=="undefined" && savedEditingPlayerId) ? savedEditingPlayerId : null; }catch(e){}
    try{ if(!preId && window.__modalAvatarPid) preId = window.__modalAvatarPid.single || null; }catch(e){}
    const id = preId || cryptoId();

    const rec = { id, name, spotify, darts };
    const idx = list.findIndex(function(x){ return x && x.id === id; });
    if(idx >= 0) list[idx] = rec; else list.push(rec);

    _saveSaved(SAVED_PLAYERS_KEY, list);
    refreshSavedDropdowns();

    // nollst√§ll f√§lten s√• man kan skriva n√§sta direkt
    savedEditingPlayerId = null;
    const sel = document.getElementById("savedPlayerSelect"); if(sel) sel.value = "";
    document.getElementById("kName").value = "";
    document.getElementById("kSpotify").value = "";
    document.getElementById("kDarts").value = "";
    try{ document.getElementById("kName").focus(); }catch(e){}
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Sparat som ny: " + name;
    return true;
  }
}


function exportSavedProfiles(){
  const data = {
    players: _loadSaved(SAVED_PLAYERS_KEY),
    teams: _loadSaved(SAVED_TEAMS_KEY),
    exportedAt: new Date().toISOString()
  };
  const ta = document.getElementById("savedProfilesBox");
  if(ta) ta.value = JSON.stringify(data, null, 2);
  try{ ta && ta.focus(); ta && ta.select(); }catch(e){}
}

function importSavedProfiles(){
  const ta = document.getElementById("savedProfilesBox");
  const raw = ta ? ta.value.trim() : "";
  if(!raw){ alert("Klistra in text f√∂rst."); return; }
  let obj;
  try{ obj = JSON.parse(raw); }catch(e){ alert("Ogiltig text/JSON."); return; }
  const players = Array.isArray(obj.players) ? obj.players : [];
  const teams = Array.isArray(obj.teams) ? obj.teams : [];
  // normalisera
  const p2 = players.map(p=>({ id: p.id||cryptoId(), name: (p.name||"").trim(), spotify:(p.spotify||"").trim(), darts:(p.darts||"").trim() })).filter(p=>p.name);
  const t2 = teams.map(t=>({ id: t.id||cryptoId(), teamName:(t.teamName||"").trim(), members:[((t.members&&t.members[0])||t.p1||"").trim(), ((t.members&&t.members[1])||t.p2||"").trim()], spotify:(t.spotify||"").trim(), darts:(t.darts||"").trim() })).filter(t=>t.teamName && t.members[0] && t.members[1]);
  _saveSaved(SAVED_PLAYERS_KEY, p2);
  _saveSaved(SAVED_TEAMS_KEY, t2);
  refreshSavedDropdowns();
  alert("Importerade sparade profiler: " + p2.length + " spelare, " + t2.length + " lag.");
}

function clearSavedProfiles(){
  if(!confirm("Rensa alla sparade spelare och lag p√• denna enhet?")) return;
  try{ localStorage.removeItem(SAVED_PLAYERS_KEY); localStorage.removeItem(SAVED_TEAMS_KEY); }catch(e){}
  savedEditingPlayerId = null;
  savedEditingTeamId = null;
  refreshSavedDropdowns();
  const ta = document.getElementById("savedProfilesBox"); if(ta) ta.value = "";
}

function clearStatsOnly(){
  if(!confirm("Rensa all sparad statistik/historik p√• denna enhet? (Sparade spelare och lag beh√•lls)")) return;
  try{ localStorage.removeItem(HISTORY_KEY); }catch(e){}
  // Om en profilruta/historik √§r √∂ppen, st√§ng och uppdatera vyer
  try{ closeProfile(); }catch(e){}
  try{ closeHistoryModal(); }catch(e){}
  // Uppdatera ev. visning om du st√•r p√• en profilsida just nu
  try{ renderAll(); }catch(e){}
}




function kioskAddSingle(){
  var name=(document.getElementById('kName').value||'').trim();
  if(!name){ alert('Skriv in ett namn.'); return false; }
  var sp=(document.getElementById('kSpotify').value||'').trim();
  var da=(document.getElementById('kDarts').value||'').trim();
  // F√∂rhindra dubletter i "Tillagda"
  try{
    var existing = parseLines($('players').value).map(function(x){return (x||'').trim().toLowerCase();}).filter(Boolean);
    if(existing.indexOf(name.toLowerCase()) !== -1){
      if(typeof toast === "function") toast("Spelaren √§r redan tillagd.");
      else alert("Spelaren √§r redan tillagd.");
      // Rensa f√§lt f√∂r snabb forts√§ttning
      document.getElementById('kName').value='';
      document.getElementById('kSpotify').value='';
      document.getElementById('kDarts').value='';
      renderKioskList();
      return false;
    }
  }catch(e){}

  // spara spelare f√∂r framtiden (lokalt)
  try{
    
      var list=_loadSaved(SAVED_PLAYERS_KEY);
      // om man har laddat en sparad profil: uppdatera den (√§ven om namn √§ndras)
      if(savedEditingPlayerId){
        var exId=_byId(list, savedEditingPlayerId);
        if(exId){ exId.name=name; exId.spotify=sp; exId.darts=da; }
        else{ list.push({id:savedEditingPlayerId, name:name, spotify:sp, darts:da}); }
      }else{
        // annars: uppdatera om samma namn finns, annars skapa ny
        var low=name.toLowerCase();
        var ex=list.find(function(p){return ((p.name||'').trim().toLowerCase()===low);});
        if(ex){ ex.spotify=sp; ex.darts=da; }
        else{ list.push({id:cryptoId(), name:name, spotify:sp, darts:da}); }
      }
      _saveSaved(SAVED_PLAYERS_KEY, list);
      refreshSavedDropdowns();
      var sel=document.getElementById('savedPlayerSelect'); if(sel) sel.value='';
      savedEditingPlayerId=null;
  }catch(e){}

  $('players').value = (parseLines($('players').value).concat([name])).join('\n');
  $('spotifyLinks').value = (parseLines($('spotifyLinks').value).concat([sp])).join('\n');
  $('darts').value = (parseLines($('darts').value).concat([da])).join('\n');
  $('walkonLabels').value = (parseLines($('walkonLabels').value).concat([''])).join('\n');

  document.getElementById('kName').value='';
  document.getElementById('kSpotify').value='';
  document.getElementById('kDarts').value='';
  // Undvik att √∂ppna tangentbordet efter snabb-add fr√•n rullistan
  var ae = null;
  try{ ae = document.activeElement; }catch(e){}
  var shouldRefocus = !!(ae && (ae.id==='kName' || ae.id==='kSpotify' || ae.id==='kDarts'));
  if(shouldRefocus){
    try{ document.getElementById('kName').focus({preventScroll:true}); }catch(e){}
  }else{
    defocusKeyboard();
  }
  renderKioskList();
  return true;
}

function kioskAddTeam(){
  var team=(document.getElementById('kTeamName').value||'').trim();
  var p1=(document.getElementById('kTeamP1').value||'').trim();
  var p2=(document.getElementById('kTeamP2').value||'').trim();
  if(!team){ alert('Skriv in ett lagnamn.'); return; }
  if(!p1 || !p2){ alert('Fyll i b√•da spelarna i laget.'); return false; }

  var existing=parseLines(($('teamNames')?$('teamNames').value:'')).map(function(x){return (x||'').trim().toLowerCase();});
  // F√∂rhindra dubletter i "Tillagda"
  try{
    var lowTeam = (team||'').trim().toLowerCase();
    if(lowTeam && existing.indexOf(lowTeam) !== -1){
      if(typeof toast === "function") toast("Laget √§r redan tillagt.");
      else alert("Laget √§r redan tillagt.");
      document.getElementById('kTeamName').value='';
      document.getElementById('kTeamP1').value='';
      document.getElementById('kTeamP2').value='';
      document.getElementById('kTeamSpotify').value='';
      document.getElementById('kTeamDarts').value='';
      renderKioskList();
      return false;
    }
  }catch(e){}
  if(existing.indexOf(team.toLowerCase())>=0){ alert('Lagnamnet finns redan.'); return; }

  var sp=(document.getElementById('kTeamSpotify').value||'').trim();
  var da=(document.getElementById('kTeamDarts').value||'').trim();

  // spara lag f√∂r framtiden (lokalt)
  try{
    
      var list=_loadSaved(SAVED_TEAMS_KEY);
      if(savedEditingTeamId){
        var exId=_byId(list, savedEditingTeamId);
        var obj={id:savedEditingTeamId, teamName:team, members:[p1,p2], spotify:sp, darts:da};
        if(exId){ Object.assign(exId, obj); }
        else{ list.push(obj); }
      }else{
        var low=team.toLowerCase();
        var ex=list.find(function(t){return ((t.teamName||'').trim().toLowerCase()===low);});
        if(ex){ ex.members=[p1,p2]; ex.spotify=sp; ex.darts=da; }
        else{ list.push({id:cryptoId(), teamName:team, members:[p1,p2], spotify:sp, darts:da}); }
      }
      _saveSaved(SAVED_TEAMS_KEY, list);
      refreshSavedDropdowns();
      var sel=document.getElementById('savedTeamSelect'); if(sel) sel.value='';
      savedEditingTeamId=null;
  }catch(e){}


  $('teamNames').value = (parseLines($('teamNames').value).concat([team])).join('\n');
  $('teamMember1').value = (parseLines($('teamMember1').value).concat([p1])).join('\n');
  $('teamMember2').value = (parseLines($('teamMember2').value).concat([p2])).join('\n');
  $('teamSpotify').value = (parseLines($('teamSpotify').value).concat([sp])).join('\n');
  $('teamDarts').value = (parseLines($('teamDarts').value).concat([da])).join('\n');

  document.getElementById('kTeamName').value='';
  document.getElementById('kTeamP1').value='';
  document.getElementById('kTeamP2').value='';
  document.getElementById('kTeamSpotify').value='';
  document.getElementById('kTeamDarts').value='';
  // Undvik att √∂ppna tangentbordet efter snabb-add fr√•n rullistan
  var ae2 = null;
  try{ ae2 = document.activeElement; }catch(e){}
  var shouldRefocus2 = !!(ae2 && (ae2.id==='kTeamName' || ae2.id==='kTeamP1' || ae2.id==='kTeamP2' || ae2.id==='kTeamSpotify' || ae2.id==='kTeamDarts'));
  if(shouldRefocus2){
    try{ document.getElementById('kTeamName').focus({preventScroll:true}); }catch(e){}
  }else{
    defocusKeyboard();
  }
  renderKioskList();
  return true;
}


function kioskRemoveAt(idx){
  if(state.mode==='team'){
    var tn=parseLines($('teamNames').value), a=parseLines($('teamMember1').value), b=parseLines($('teamMember2').value),
        sp=parseLines($('teamSpotify').value), da=parseLines($('teamDarts').value);
    tn.splice(idx,1); a.splice(idx,1); b.splice(idx,1); sp.splice(idx,1); da.splice(idx,1);
    $('teamNames').value=tn.join('\n'); $('teamMember1').value=a.join('\n'); $('teamMember2').value=b.join('\n');
    $('teamSpotify').value=sp.join('\n'); $('teamDarts').value=da.join('\n');
  }else{
    var n=parseLines($('players').value), wl=parseLines($('walkonLabels').value), sp2=parseLines($('spotifyLinks').value), da2=parseLines($('darts').value);
    n.splice(idx,1); wl.splice(idx,1); sp2.splice(idx,1); da2.splice(idx,1);
    $('players').value=n.join('\n'); $('walkonLabels').value=wl.join('\n'); $('spotifyLinks').value=sp2.join('\n'); $('darts').value=da2.join('\n');
  }
  renderKioskList();
}

function renderKioskList(){
  var boxes=[document.getElementById('kioskList'), document.getElementById('kioskTeamList')].filter(Boolean);
  if(!boxes.length) return;

  var items=[];
  if(state.mode==='team'){
    var tn=parseLines(($('teamNames')?$('teamNames').value:'')),
        a=parseLines(($('teamMember1')?$('teamMember1').value:'')),
        b=parseLines(($('teamMember2')?$('teamMember2').value:''));
    for(var i=0;i<tn.length;i++){
      var title=(tn[i]||'').trim();
      if(!title) continue;
      items.push({title:title, sub: ((a[i]||'').trim()+' & '+(b[i]||'').trim()).trim(), pid:_avatarPlayerIdFromAddedTitle(title)});
    }
  }else{
    var n=parseLines($('players').value);
    for(var j=0;j<n.length;j++){
      var t=(n[j]||'').trim();
      if(!t) continue;
      items.push({title:t, sub:'', pid:_avatarPlayerIdFromAddedTitle(t)});
    }
  }

  function buildHtml(){
    if(!items.length) return "<div class='muted'>Inga tillagda √§n.</div>";
    return items.map(function(it,i){
      var sub = it.sub ? ("<div class='muted' style='margin-top:2px'>"+escapeHtml(it.sub)+"</div>") : "";
      return "<div class='row' style='justify-content:space-between;align-items:flex-start;border-bottom:1px solid #eef1f6;padding:8px 0'>"
        + "<div class='avatarRow'>"
          + "<button class='avatarBtn small' type='button' data-avatar-pid='"+(it.pid||"")+"' data-avatar-name='"+escapeAttr(it.title||"")+"' onclick=\"openAvatarModalResolved('"+(it.pid||"")+"', '"+escapeJs(it.title||"")+"')\">"
            + "<span>"+escapeHtml(_avatarInitials(it.title||""))+"</span>"
          + "</button>"
          + "<div class='avatarMeta' style='min-width:0'><strong>"+escapeHtml(it.title||('-'))+"</strong>"+sub+"</div>"
        + "</div>"
        + "<button class='btn secondary' style='padding:6px 10px' type='button' onclick='kioskRemoveAt("+i+")'>Ta bort</button>"
        + "</div>";
    }).join("");
  }

  var html = buildHtml();
  boxes.forEach(function(box){ box.innerHTML = html; try{ hydrateAvatarsIn(box); }catch(e){} });
}

// beh√∂vs f√∂r onclick
window.kioskRemoveAt = kioskRemoveAt;


function parseWalkonLine(line){
  const parts = line.split("|");
  if(parts.length===1) return { label: parts[0].trim(), url:"" };
  return { label: parts[0].trim(), url: parts.slice(1).join("|").trim() };
}

function normalizeSpotifyUrl(url){
  url = (url||"").trim();
  if(!url) return "";
  // Till√•t b√•de https://open.spotify.com/... och spotify:track:...
  if(url.startsWith("spotify:")) return "https://open.spotify.com/" + url.replace(/^spotify:/,"").replace(/:/g,"/");
  if(url.startsWith("http://") || url.startsWith("https://")) return url;
  return url; // fallback
}

function buildPlayersFromInput(){
  // Manuell inmatning (rad per spelare)
  const names = parseLines($("players").value);
  const walkonLabels = parseLines(($("walkonLabels")?$("walkonLabels").value:""));
  const spotifyLinks = parseLines(($("spotifyLinks")?$("spotifyLinks").value:""));
  const darts = parseLines(($("darts")?$("darts").value:""));

  const players = names.map((name, i)=>{
    // Till√•t flera s√§tt att klistra in walk-on:
    // 1) Visningsnamn i "Walk-on (visningsnamn)" + l√§nk i "Spotify-l√§nk".
    // 2) En rad i "Walk-on" p√• formen: Visningsnamn | https://open.spotify.com/...
    // 3) Bara en Spotify-l√§nk (i valfri av rutorna) ‚Äì vi g√∂r den klickbar √§nd√•.
    const rawWalk = (walkonLabels[i]||"").trim();
    const parsed = parseWalkonLine(rawWalk);

    let label = (parsed.label||"").trim();
    let url = normalizeSpotifyUrl((parsed.url||"").trim());
    if(!url) url = normalizeSpotifyUrl((spotifyLinks[i]||"").trim());

    // Om anv√§ndaren r√•kar klistra in l√§nken i "visningsnamn"-rutan
    if(!url && /spotify\.(com|link)/i.test(label)){
      url = normalizeSpotifyUrl(label);
      label = "";
    }

    const _saved = _findSavedPlayerByName(name);
    const _pid = _saved && _saved.id ? _saved.id : cryptoId();

    return {
      id: _pid,
      name,
      walkonLabel: label,
      walkonUrl: url,
      darts: (darts[i]||"").trim(),
    };
  });

  return players;
}

function buildTeamsFromInput(){
  var teamNames = parseLines(($('teamNames') ? $('teamNames').value : ''));
  var m1 = parseLines(($('teamMember1') ? $('teamMember1').value : ''));
  var m2 = parseLines(($('teamMember2') ? $('teamMember2').value : ''));
  var sp = parseLines(($('teamSpotify') ? $('teamSpotify').value : ''));
  var da = parseLines(($('teamDarts') ? $('teamDarts').value : ''));

  var teams = [];
  for(var i=0;i<teamNames.length;i++){
    var tn = (teamNames[i]||'').trim();
    var a = (m1[i]||'').trim();
    var b = (m2[i]||'').trim();
    if(!tn) continue;
    if(!a || !b) continue;
    const _savedT = _findSavedTeamByName(tn);
    const _tid = _savedT && _savedT.id ? _savedT.id : cryptoId();
    teams.push({
      id: _tid,
      type: 'team',
      teamName: tn,
      members: [a,b],
      walkonLabel: '',
      walkonUrl: (sp[i]||'').trim(),
      darts: (da[i]||'').trim(),
    });
  }
  return teams;
}

function buildParticipantsFromInput(){
  return (state.mode === 'team') ? buildTeamsFromInput() : buildPlayersFromInput();
}


function playerById(pid){ return (state.players||[]).find(p=>p.id===pid); }

function playerInitial(pid){
  const name = playerName(pid) || "";
  const ch = name.trim().charAt(0);
  return ch ? ch.toUpperCase() : "?";
}

function playerName(pid){ var p=playerById(pid); if(!p) return ""; return (p.type==='team') ? (p.teamName||"") : (p.name||"");
}

function suggestGroups(playerIds, numGroups){
  const shuffled = shuffle(playerIds);
  numGroups = parseInt(numGroups || state.numGroups || 2, 10) || 2;

  // Standard (2 grupper): beh√•ll exakt nuvarande beteende
  if(numGroups !== 4){
    const aSize = playerIds.length >= 7 ? 4 : Math.ceil(playerIds.length/2);
    return { A: shuffled.slice(0,aSize), B: shuffled.slice(aSize) };
  }

  // Ut√∂kat (4 grupper): f√∂rdela s√• j√§mnt som m√∂jligt (maxexempel: 16 spelare => 4x4)
  const n = shuffled.length;
  const base = Math.floor(n / 4);
  const rem = n % 4;
  const sizes = [base, base, base, base];
  for(let i=0;i<rem;i++) sizes[i] += 1;

  let idx = 0;
  const A = shuffled.slice(idx, idx+=sizes[0]);
  const B = shuffled.slice(idx, idx+=sizes[1]);
  const C = shuffled.slice(idx, idx+=sizes[2]);
  const D = shuffled.slice(idx, idx+=sizes[3]);
  return { A, B, C, D };
}

function makeRoundRobinMatches(playerIds, repeats){
  repeats = repeats || 1;
  const ms=[];
  let id=0;
  for(let i=0;i<playerIds.length;i++){
    for(let j=i+1;j<playerIds.length;j++){
      for(let r=0;r<repeats;r++){
        const swap = (r % 2 === 1);
        const a = swap ? playerIds[j] : playerIds[i];
        const b = swap ? playerIds[i] : playerIds[j];
        ms.push({ id:`g_${id++}`, stage:"Grundspel", group:"Alla",
          aId:a, bId:b,
          winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" });
      }
    }
  }
  return ms;
}

function makeGroupMatches(groups, repeats){
  repeats = repeats || 1;
  const ms=[];
  let id=0;

  function combos(arr){
    const out=[];
    for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) out.push([arr[i],arr[j]]);
    return out;
  }

  // St√∂d f√∂r 2 eller 4 grupper (utan att √§ndra befintligt beteende f√∂r 2 grupper)
  const letters = (state.numGroups===4 || (groups && groups.C) || (groups && groups.D))
    ? ["A","B","C","D"]
    : ["A","B"];

  letters.forEach((g)=>{
    const list = (groups && groups[g]) ? groups[g] : [];
    combos(list).forEach(([a0,b0])=>{
      for(let r=0;r<repeats;r++){
        const swap = (r % 2 === 1);
        const a = swap ? b0 : a0;
        const b = swap ? a0 : b0;
        ms.push({ id:`m_${g}_${id++}`, stage:"Gruppspel", group:g,
          aId:a, bId:b, winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" });
      }
    });
  });

  return ms;
}

function createTournament(){
  try{
    state.format = $("format").value;
    state.repeats = parseInt($("repeat").value || "1", 10) || 1;

    // Regler
    state.rules.game = $("game").value;
    state.rules.inRule = $("inRule").value;
    state.rules.outRule = $("outRule").value;
    state.rules.legsMode = $("legsMode").value;

    // Spelare: endast manuell inmatning
    state.playerSource = "manual"; // skydd mot gammalt sparat l√§ge
    const newPlayers = buildParticipantsFromInput();
    if(!newPlayers || newPlayers.length < 3){
      alert(state.mode==="team" ? "Minst 3 lag kr√§vs." : "Minst 3 spelare kr√§vs.");
      return;
    }
    state.players = newPlayers;

    // Nollst√§ll turneringsdata
    state.groups = {A:[], B:[]};
    state.playoffs = {started:false, matches:[]};
    state.startedAt = new Date().toISOString();


    const ids = state.players.map(p=>p.id);
    if(state.format === "round_robin" || state.format === "round_robin_playoffs"){
      state.matches = makeRoundRobinMatches(ids, state.repeats);
      state.step = getStepNums().matches;
    }else if(state.format === "knockout"){
      // Slutspel direkt: skapa tr√§d (inkl. kval vid behov) men l√•t anv√§ndaren starta n√§r man √§r n√∂jd.
      state.groups = null;
      var po = buildKnockoutBracket(ids);
      if(!po || po.length===0){
        alert("Kunde inte skapa slutspel. Kontrollera att du har tillr√§ckligt m√•nga spelare/lag.");
        return;
      }
      // Viktigt: samma matchobjekt anv√§nds i Match-fliken och i slutspels-tr√§det (synk).
      state.matches = po;
      state.playoffs = { started:false, matches: po };
      // Final fylls f√∂rst n√§r semifinaler √§r spelade (och slutspel √§r startat).
      state.step = getStepNums().playoffs;
    }else{
      state.groups = suggestGroups(ids, state.numGroups);
      state.matches = [];
      state.step = getStepNums().groups;
    }

    // Autospar vid skapande (skydd mot reload)
    autosaveTournament();

    saveState();
    renderAll();
  }
  catch(e){
    alert("Fel n√§r turneringen skulle skapas: " + (e && e.message ? e.message : e));
    console.error(e);
  }
}

function reshuffleGroups(){
  state.groups = suggestGroups(state.players.map(p=>p.id), state.numGroups);
  saveState();
  renderGroups();
}

function renderGroups(){
  const A = (state.groups && state.groups.A) ? state.groups.A : [];
  const B = (state.groups && state.groups.B) ? state.groups.B : [];
  const C = (state.groups && state.groups.C) ? state.groups.C : [];
  const D = (state.groups && state.groups.D) ? state.groups.D : [];

  $("groupAList").innerHTML = A.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";
  $("groupBList").innerHTML = B.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";

  // Visa/d√∂lj Grupp C/D beroende p√• valt antal grupper
  var show4 = (state.numGroups===4);
  try{
    var cds = document.querySelectorAll('.groupCD');
    for(var i=0;i<cds.length;i++){
      cds[i].classList.toggle('hidden', !show4);
    }
  }catch(e){}

  var cEl = $("groupCList");
  var dEl = $("groupDList");
  if(cEl){
    cEl.innerHTML = C.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";
  }
  if(dEl){
    dEl.innerHTML = D.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";
  }
}

function confirmGroups(){
  state.matches = makeGroupMatches(state.groups, state.repeats);
  state.step = 5;
  saveState();
  renderAll();
}

function groupStageComplete(){
  if(!state.matches || state.matches.length===0) return false;

  var letters = (state.numGroups===4) ? ["A","B","C","D"] : ["A","B"];

  // Endast gruppmatcher r√§knas (A/B och ev. C/D)
  for(var i=0;i<state.matches.length;i++){
    var mm = state.matches[i];
    if(letters.indexOf(mm.group) !== -1){
      if(!mm.winnerId) return false;
    }
  }
  return true;
}

function top2FromGroup(groupLetter){
  var ids = (state.groups && state.groups[groupLetter]) ? (state.groups[groupLetter] || []) : [];
  var st = computeStandings(ids, state.matches, function(m){ return m.group===groupLetter; });
  return st.slice(0,2).map(function(x){ return x.pid; });
}


function buildPlayoffsPreview(){
  // Bygger ett f√∂rhands-slutspel baserat p√• NUVARANDE tabell (√§ven om grundspelet inte √§r klart).
  // Detta sparas inte f√∂rr√§n du trycker "Starta slutspel".

  // 1) Gruppspel + slutspel (befintligt beteende)
  if(state.format==="group_playoffs"){
    var is4 = (state.numGroups===4);

    if(!is4){
      var A = top2FromGroup("A");
      var B = top2FromGroup("B");

      // Semis: A1 vs B2, B1 vs A2 (om saknas -> tomma platser)
      var sf1 = { id:"po_sf1", stage:"Slutspel", round:"Semifinal 1", group:"SF",
        aId:(A[0]||""), bId:(B[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      var sf2 = { id:"po_sf2", stage:"Slutspel", round:"Semifinal 2", group:"SF",
        aId:(B[0]||""), bId:(A[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      var fin = { id:"po_f", stage:"Slutspel", round:"Final", group:"F",
        aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

      return [sf1, sf2, fin];
    }

    // 4 grupper -> topp 2 fr√•n varje -> kvartsfinaler -> semifinaler -> final
    var A2 = top2FromGroup("A");
    var B2 = top2FromGroup("B");
    var C2 = top2FromGroup("C");
    var D2 = top2FromGroup("D");

    // Kvartsfinaler: A1-B2, B1-A2, C1-D2, D1-C2
    var qf1 = { id:"po_qf1", stage:"Slutspel", round:"Kvartsfinal 1", group:"QF",
      aId:(A2[0]||""), bId:(B2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var qf2 = { id:"po_qf2", stage:"Slutspel", round:"Kvartsfinal 2", group:"QF",
      aId:(B2[0]||""), bId:(A2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var qf3 = { id:"po_qf3", stage:"Slutspel", round:"Kvartsfinal 3", group:"QF",
      aId:(C2[0]||""), bId:(D2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var qf4 = { id:"po_qf4", stage:"Slutspel", round:"Kvartsfinal 4", group:"QF",
      aId:(D2[0]||""), bId:(C2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

    // Semifinaler fylls n√§r kvartsfinalerna √§r spelade (kan vara tomt i f√∂rhandsvisning)
    var sf1x = { id:"po_sf1", stage:"Slutspel", round:"Semifinal 1", group:"SF",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var sf2x = { id:"po_sf2", stage:"Slutspel", round:"Semifinal 2", group:"SF",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var finx = { id:"po_f", stage:"Slutspel", round:"Final", group:"F",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

    return [qf1, qf2, qf3, qf4, sf1x, sf2x, finx];
  }

  // 2) Serie + slutspel (NYTT)
  if(state.format==="round_robin_playoffs"){
    var ids = (state.players||[]).map(function(p){return p.id;});
    if(ids.length < 4) return null;

    // Tabell baserat p√• alla matcher i grundspelet
    var st = computeStandings(ids, state.matches || [], function(m){ return m && m.stage==="Grundspel"; });
    var seeds = st.map(function(x){ return x.pid; });

    // Beh√•ll bara de som g√•r vidare:
    // - 4‚Äì7 deltagare -> topp 4 (semis)
    // - 8+ deltagare -> topp 8 (kvarts)
    var take = (ids.length >= 8) ? 8 : 4;
    seeds = seeds.slice(0, take);

    // Semis direkt
    if(take===4){
      var sf1r = { id:"po_sf1", stage:"Slutspel", round:"Semifinal 1", group:"SF",
        aId:(seeds[0]||""), bId:(seeds[3]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      var sf2r = { id:"po_sf2", stage:"Slutspel", round:"Semifinal 2", group:"SF",
        aId:(seeds[1]||""), bId:(seeds[2]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      var finr = { id:"po_f", stage:"Slutspel", round:"Final", group:"F",
        aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      return [sf1r, sf2r, finr];
    }

    // Kvartsfinaler (topp 8): 1-8, 4-5, 2-7, 3-6
    var q1 = { id:"po_qf1", stage:"Slutspel", round:"Kvartsfinal 1", group:"QF",
      aId:(seeds[0]||""), bId:(seeds[7]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var q2 = { id:"po_qf2", stage:"Slutspel", round:"Kvartsfinal 2", group:"QF",
      aId:(seeds[3]||""), bId:(seeds[4]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var q3 = { id:"po_qf3", stage:"Slutspel", round:"Kvartsfinal 3", group:"QF",
      aId:(seeds[1]||""), bId:(seeds[6]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var q4 = { id:"po_qf4", stage:"Slutspel", round:"Kvartsfinal 4", group:"QF",
      aId:(seeds[2]||""), bId:(seeds[5]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

    var s1 = { id:"po_sf1", stage:"Slutspel", round:"Semifinal 1", group:"SF",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var s2 = { id:"po_sf2", stage:"Slutspel", round:"Semifinal 2", group:"SF",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var fr = { id:"po_f", stage:"Slutspel", round:"Final", group:"F",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

    return [q1,q2,q3,q4,s1,s2,fr];
  }

  return null;
}

function buildKnockoutBracket(playerIds){
  // Knockout direkt med KVAL n√§r antal inte √§r en 2-potens.
  // Vi kvalar ner till n√§rmaste l√§gre 2-potens: 4 / 8 / 16 / 32 (max 32).
  var ids = Array.isArray(playerIds) ? playerIds.slice() : [];
  if(ids.length < 2) return null;

  ids = shuffle(ids);

  var n = ids.length;
  var max = 32;
  if(n > max) ids = ids.slice(0, max), n = ids.length;

  function largestPow2LE(x){
    var p = 1;
    while(p*2 <= x) p *= 2;
    return p;
  }

  var target = largestPow2LE(n);
  // Vi st√∂djer matchgenerering upp till 32, men tr√§d-vyn i UI √§r prim√§rt byggd f√∂r 4/8.
  // Matchfliken + schema fungerar √§ven vid fler.
  var qualMatches = n - target;

  var nowIso = new Date().toISOString();

  function mkBase(id, round, group, aId, bId){
    return { id:id, stage:"Slutspel", round:round, group:group,
      aId:(aId||""), bId:(bId||""), winnerId:"", result:"",
      avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"",
      createdAt: nowIso
    };
  }

  // 1) Bygg Kval-matcher (po_k1..)
  var kval = [];
  var idx = 0;
  for(var k=1; k<=qualMatches; k++){
    var a = ids[idx++] || "";
    var b = ids[idx++] || "";
    kval.push(mkBase("po_k"+k, "Kval "+k, "K", a, b));
  }

  // Resterande g√•r direkt
  var direct = ids.slice(idx);

  // 2) Bygg huvudrundor
  var matches = [];
  matches = matches.concat(kval);

  // Helper: pool med kval-platser + direkt
  var pool = [];
  for(var k2=1; k2<=qualMatches; k2++) pool.push({fromQual:k2});
  for(var di=0; di<direct.length; di++) pool.push(direct[di]);
  pool = shuffle(pool);

  function takeSlot(){
    return pool.shift() || "";
  }
  function applySlot(m, side, slot){
    if(typeof slot === "object" && slot && slot.fromQual){
      m[side] = "";
      if(side==="aId") m._aFromQual = slot.fromQual;
      if(side==="bId") m._bFromQual = slot.fromQual;
    }else{
      m[side] = slot || "";
    }
  }

  // target 4: Semis + Final
  if(target === 4){
    var sf1 = mkBase("po_sf1","Semifinal 1","SF","","");
    var sf2 = mkBase("po_sf2","Semifinal 2","SF","","");
    var fin = mkBase("po_f","Final","F","","");

    var s1a = takeSlot(), s1b = takeSlot(), s2a = takeSlot(), s2b = takeSlot();
    applySlot(sf1, "aId", s1a); applySlot(sf1, "bId", s1b);
    applySlot(sf2, "aId", s2a); applySlot(sf2, "bId", s2b);

    matches.push(sf1, sf2, fin);
    return matches;
  }

  // target 8: Kvarts + Semis + Final
  if(target === 8){
    var qf1 = mkBase("po_qf1","Kvartsfinal 1","QF","","");
    var qf2 = mkBase("po_qf2","Kvartsfinal 2","QF","","");
    var qf3 = mkBase("po_qf3","Kvartsfinal 3","QF","","");
    var qf4 = mkBase("po_qf4","Kvartsfinal 4","QF","","");
    var sf1x = mkBase("po_sf1","Semifinal 1","SF","","");
    var sf2x = mkBase("po_sf2","Semifinal 2","SF","","");
    var finx = mkBase("po_f","Final","F","","");

    var slots = [takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot()];
    applySlot(qf1,"aId",slots[0]); applySlot(qf1,"bId",slots[1]);
    applySlot(qf2,"aId",slots[2]); applySlot(qf2,"bId",slots[3]);
    applySlot(qf3,"aId",slots[4]); applySlot(qf3,"bId",slots[5]);
    applySlot(qf4,"aId",slots[6]); applySlot(qf4,"bId",slots[7]);

    matches.push(qf1,qf2,qf3,qf4,sf1x,sf2x,finx);
    return matches;
  }

  // target 16/32: skapa rundor i matches-listan (schema/matchflik), tr√§dvyn kan senare ut√∂kas.
  // Vi skapar d√• bara en "f√∂rsta runda" + placeholders f√∂r n√§sta (i schema).
  // H√§r f√∂renklar vi: anv√§nd samma id-m√∂nster i schema, men utan tr√§dvisning.
  var rounds = [];
  if(target === 16) rounds = ["√Öttondelsfinal"];
  if(target === 32) rounds = ["Sextondelsfinal"];
  var firstName = rounds[0] || "Runda";
  var firstCount = target/2;
  for(var i=1;i<=firstCount;i++){
    var m = mkBase("po_r1_"+i, firstName+" "+i, "R1","","");
    var aS = takeSlot(), bS = takeSlot();
    applySlot(m,"aId",aS); applySlot(m,"bId",bS);
    matches.push(m);
  }
  return matches;
}


function canStartPlayoffsNow(){
  // Styr UI f√∂r "Starta slutspel".
  if(state.format==="group_playoffs"){
    var letters = (state.numGroups===4) ? ["A","B","C","D"] : ["A","B"];
    for(var i=0;i<letters.length;i++){
      var g = letters[i];
      var c = (state.groups && state.groups[g]) ? state.groups[g].length : 0;
      if(c < 2){
        return {ok:false, msg:"F√∂r att starta slutspel beh√∂vs minst 2 spelare i varje grupp."};
      }
    }

    if(!groupStageComplete()){
      return {ok:true, msg:"Gruppspelet √§r inte klart √§nnu. Slutspel visas som f√∂rhandsvisning. N√§r alla gruppmatcher √§r spelade kan du starta/l√•sa slutspelet."};
    }
    return {ok:true, msg:""};
  }

  if(state.format==="round_robin_playoffs"){
    var n = (state.players||[]).length;
    if(n < 4) return {ok:false, msg:"Slutspel kr√§ver minst 4 deltagare."};

    // Grundspel klart?
    var complete = true;
    for(var i2=0;i2<(state.matches||[]).length;i2++){
      var m = state.matches[i2];
      if(m && m.stage==="Grundspel" && !m.winnerId){ complete = false; break; }
    }
    if(!complete){
      return {ok:true, msg:"Grundspelet (serien) √§r inte klart √§nnu. Slutspel visas som f√∂rhandsvisning. N√§r alla seriematcher √§r spelade kan du starta/l√•sa slutspelet."};
    }
    return {ok:true, msg:""};
  }

  return {ok:false, msg:"Slutspel finns bara n√§r du valt Gruppspel + slutspel eller Serie + slutspel."};
}

function ensurePlayoffs(){
  // Skapar (och l√•ser) slutspel n√§r det √§r dags.
  if(state.format!=="group_playoffs" && state.format!=="round_robin_playoffs") return false;

  // Om redan startat/l√•st ‚Äì beh√•ll.
  if(state.playoffs && state.playoffs.started && state.playoffs.matches && state.playoffs.matches.length>0) return true;

  var chk = canStartPlayoffsNow();
  if(!chk.ok) return false;

  var preview = buildPlayoffsPreview();
  if(!preview) return false;

  state.playoffs = { started:true, matches: preview };
  saveState();
  return true;
}


function updateFinalFromSemis(){
  // Uppdatera deltagare i SF/Final baserat p√• spelade slutspelsmatcher.
  // K√∂rs efter att en slutspelsmatch f√•tt vinnare och vid rendering,
  // s√• att vinnare automatiskt g√•r vidare i tr√§det.
  if(!state.playoffs || !state.playoffs.matches) return;
  var ms = state.playoffs.matches;

  // H√§mta matcher (kan saknas beroende p√• uppl√§gg)
  function byId(id){ return ms.find(function(x){ return x.id===id; }); }

  var qf1 = byId("po_qf1"), qf2 = byId("po_qf2"), qf3 = byId("po_qf3"), qf4 = byId("po_qf4");
  var sf1 = byId("po_sf1"), sf2 = byId("po_sf2");
  var fin = byId("po_f");
  if(!fin) return;

  function clearMatchIfParticipantsChanged(m, newA, newB){
    if(!m) return;
    var a = newA || "";
    var b = newB || "";
    var changed = (m.aId !== a) || (m.bId !== b);
    if(!changed) return;

    m.aId = a;
    m.bId = b;

    // Om match redan hade vinnare/resultat men deltagare √§ndras -> nollst√§ll.
    if(m.winnerId && (m.winnerId !== m.aId && m.winnerId !== m.bId)){
      m.winnerId = "";
      m.result = "";
      m.avgA = ""; m.avgB = "";
      m.f9A = ""; m.f9B = "";
      m.coA = ""; m.coB = "";
      m.notes = "";
      m.finishedAt = "";
    }
  }

  // Om vi har kvartsfinaler: semifinaler fylls av kvartsfinalvinnare.
  var hasQF = !!(qf1 || qf2 || qf3 || qf4);
  if(hasQF){
    var sf1A = (qf1 && qf1.winnerId) ? qf1.winnerId : "";
    var sf1B = (qf2 && qf2.winnerId) ? qf2.winnerId : "";
    var sf2A = (qf3 && qf3.winnerId) ? qf3.winnerId : "";
    var sf2B = (qf4 && qf4.winnerId) ? qf4.winnerId : "";

    clearMatchIfParticipantsChanged(sf1, sf1A, sf1B);
    clearMatchIfParticipantsChanged(sf2, sf2A, sf2B);
  }

  // Final: vinnarna fr√•n semifinalerna (oavsett om SF kom fr√•n QF eller var seedade direkt)
  var fA = (sf1 && sf1.winnerId) ? sf1.winnerId : "";
  var fB = (sf2 && sf2.winnerId) ? sf2.winnerId : "";
  clearMatchIfParticipantsChanged(fin, fA, fB);

  try{ saveState(); }catch(e){}
}

// redraw lines on resize (lightweight)
window.addEventListener('resize', function(){
  try{
    if(state && state.ui && state.ui.showPlayoffsBracket) drawPlayoffsBracketLines();
  }catch(e){}
});



function renderPlayoffs(){
  applyStartStamp();

  // Visa/d√∂lj kvartsfinalkolumn beroende p√• om f√∂rhandsvisningen/slutspelet inneh√•ller QF.
  ensureKnockoutSync();

  // F√∂rhandsvisning: knockout visar alltid det skapade tr√§det (inkl. kval) √§ven innan start.
  var hasPO = !!(state.playoffs && state.playoffs.matches && state.playoffs.matches.length>0);
  var preview = (state.format === "knockout" && hasPO) ? state.playoffs.matches
              : ((state.playoffs && state.playoffs.started) ? (state.playoffs.matches||[]) : (buildPlayoffsPreview()||[]));
  var hasQF = !!(preview && preview.find && preview.find(function(x){ return x.id==="po_qf1"; }));
  var hasQUAL = !!(preview && preview.find && preview.find(function(x){ return x.id==="po_k1"; }));

  try{
    var _inner = $("playoffsBracketInner");
    if(_inner && _inner.classList) _inner.classList.toggle("hasQF", hasQF);
    if(_inner && _inner.classList) _inner.classList.toggle("hasQUAL", hasQUAL);
    var _qfs = document.querySelectorAll("#playoffsBracketContent .groupCD");
    for(var _i=0; _i<_qfs.length; _i++) _qfs[_i].classList.toggle("hidden", !hasQF);

    var _quals = document.querySelectorAll("#playoffsBracketContent .bracketCell.qual");
    for(var _k=0; _k<_quals.length; _k++) _quals[_k].classList.toggle("hidden", !hasQUAL);

    // Snabbnav
    var navBtns = document.querySelectorAll('.bracketNavBtn');
    if(navBtns && navBtns.length>=3){
      navBtns[0].disabled = !hasQF; // Kvartsfinal-knappen
    }
  }catch(e){}

  // Synka vy (schema vs tr√§d)
  if(!state.ui) state.ui = {};
  var _showBracket = !!state.ui.showPlayoffsBracket;
  try{
    var _bv = $("playoffsBracketView");
    var _sv = $("playoffsScheduleView");
    if(_bv) _bv.classList.toggle("hidden", !_showBracket);
    if(_sv) _sv.classList.toggle("hidden", _showBracket);
    var _btn = $("btnPlayoffsBracketToggle");
    if(_btn) _btn.textContent = _showBracket ? "Visa slutspelsschema" : "Visa slutspelstr√§d";
  }catch(e){}

  var btnStart = $("btnStartPlayoffs");
  if(btnStart){
    if(state.format==="knockout") btnStart.classList.add('hidden');
    else btnStart.classList.remove('hidden');
  }

  var isPlayoffFormat = (state.format==="group_playoffs" || state.format==="round_robin_playoffs" || state.format==="knockout");
  if(!isPlayoffFormat){
    $("playoffsTable").innerHTML = '<tr><td class="muted" style="padding:10px">Slutspel anv√§nds n√§r du valt <b>Gruppspel + slutspel</b> eller <b>Serie + slutspel</b>.</td></tr>';
    if(btnStart) btnStart.classList.add('hidden');
    return;
  }

  var started = !!(state.playoffs && state.playoffs.started && state.playoffs.matches && state.playoffs.matches.length>0);
  var ms = started ? state.playoffs.matches : preview;

  // Styr startknappen
  if(btnStart){
    var chk = canStartPlayoffsNow();
    var complete = true;
    if(state.format==="group_playoffs") complete = groupStageComplete();
    if(state.format==="round_robin_playoffs"){
      for(var i=0;i<(state.matches||[]).length;i++){
        var m = state.matches[i];
        if(m && m.stage==="Grundspel" && !m.winnerId){ complete = false; break; }
      }
    }

    btnStart.disabled = started;
    btnStart.classList.toggle('ready', (!started && complete));
    btnStart.title = started ? "Slutspel √§r redan startat." : (complete ? "Grundspelet √§r klart ‚Äì tryck f√∂r att starta/l√•sa slutspelet." : (chk.msg || ""));
  }

  if(started && state.format!=="knockout"){
    updateFinalFromSemis();
  }

  if(!ms || ms.length===0){
    $("playoffsTable").innerHTML = '<tr><td class="muted" style="padding:10px">Det g√•r inte att skapa slutspel √§nnu.</td></tr>';
    return;
  }

  // Uppdatera hinttext
  try{
    var hintEl = document.querySelector('#playoffsScheduleView .hint');
    if(hintEl){
      if(state.format==="knockout"){
        hintEl.textContent = hasQF
          ? "Slutspelet √§r lottat: kvartsfinaler ‚Üí semifinaler ‚Üí final. Vid behov ges BYE automatiskt."
          : "Slutspelet √§r lottat: semifinaler ‚Üí final. Vid behov ges BYE automatiskt.";
      }else if(state.format==="round_robin_playoffs"){
        hintEl.textContent = hasQF
          ? "Kvartsfinaler baseras p√• serietabellen (topp 8): 1‚Äì8, 4‚Äì5, 2‚Äì7, 3‚Äì6. Vinnarna g√•r vidare till semifinal och final."
          : "Semifinaler baseras p√• serietabellen (topp 4): 1‚Äì4 och 2‚Äì3. Vinnarna m√∂ts i final.";
      }else{
        hintEl.textContent = hasQF
          ? "Kvartsfinaler: A1‚ÄìB2, B1‚ÄìA2, C1‚ÄìD2, D1‚ÄìC2. Vinnarna g√•r vidare till semifinal och final."
          : "Semifinaler: A1 vs B2 och B1 vs A2. Vinnarna m√∂ts i final.";
      }
    }
  }catch(e){}

  var html = "<tr><th>Rond</th><th>Match</th><th>Status</th></tr>";
  for(var j=0;j<ms.length;j++){
    var mm = ms[j];
    var aName = mm.aId ? playerName(mm.aId) : (mm.id==='po_f' ? 'Vinnare SF1' : (mm.id==='po_sf1' ? 'Vinnare QF1' : (mm.id==='po_sf2' ? 'Vinnare QF3' : '‚Äî')));
    var bName = mm.bId ? playerName(mm.bId) : (mm.id==='po_f' ? 'Vinnare SF2' : (mm.id==='po_sf1' ? 'Vinnare QF2' : (mm.id==='po_sf2' ? 'Vinnare QF4' : '‚Äî')));

    var played = !!mm.winnerId;
    var status;
    if(!started){
      status = '<span class="tag todo">F√∂rhandsvisning</span>';
    }else{
      status = played
        ? '<span class="tag ok">'+escapeHtml(playerName(mm.winnerId))+' vann '+(mm.result ? '('+escapeHtml(mm.result)+')' : '')+'</span>'
        : '<span class="tag todo">Ej spelad</span>';
    }

    var clickable = started;
    if(mm.id==="po_f" && (!mm.aId || !mm.bId)) clickable = false;

    html += '<tr class="matchRow '+(played?'played':'')+'" '+(clickable?'onclick="openPlayoffMatch(\''+mm.id+'\')"':'')+'>'
         +  '<td><strong>'+escapeHtml(mm.round)+'</strong></td>'
         +  '<td>'
         +  '<div class="row" style="align-items:center;gap:8px">'
         +    _avatarBtnViewHtml(mm.aId||'', aName, 'small')
         +    '<strong>'+escapeHtml(aName)+'</strong><span class="muted">vs</span>'
         +    _avatarBtnViewHtml(mm.bId||'', bName, 'small')
         +    '<strong>'+escapeHtml(bName)+'</strong>'
         +  '</div>'
         +  '</td>'
         +  '<td>'+status+'</td>'
         + '</tr>';
  }

  $("playoffsTable").innerHTML = html;
  try{ hydrateAvatarsIn($("playoffsTable")); }catch(e){}

  applyPlayoffView();
  // Se till att r√§tt vy (schema/tr√§d) faktiskt renderas varje g√•ng vi g√•r in i slutspelet.
  // Viktigt f√∂r knockout: annars kan man bli kvar med default-platsh√•llare (Spelare A1/B2).
  try{ applyPlayoffView(); }catch(e){}

}


function goToPlayoffs(){
  // Navigera till slutspelsfliken. Slutspel f√∂rhandsgranskas automatiskt.
  if(state.format!=="group_playoffs" && state.format!=="round_robin_playoffs"){
    alert("Slutspel finns bara n√§r du valt Gruppspel + slutspel eller Serie + slutspel.");
    return;
  }
  var nums = getStepNums();
  state.step = nums.playoffs;
  saveState();
  renderAll();
  try{ window.scrollTo(0,0); }catch(e){}
}

function startPlayoffsFromCurrent(){
  // L√•s slutspel baserat p√• nuvarande tabell.
  if(state.format!=="group_playoffs" && state.format!=="round_robin_playoffs"){
    alert("Slutspel finns bara n√§r du valt Gruppspel + slutspel eller Serie + slutspel.");
    return;
  }

  var chk = canStartPlayoffsNow();
  if(!chk.ok){
    alert(chk.msg || "Slutspel kan inte startas √§nnu.");
    return;
  }

  if(state.format==="group_playoffs"){
    if(!groupStageComplete()){
      alert(chk.msg || "Gruppspelet √§r inte klart √§nnu.");
      return;
    }
  }

  if(state.format==="round_robin_playoffs"){
    var complete = true;
    for(var i=0;i<(state.matches||[]).length;i++){
      var m = state.matches[i];
      if(m && m.stage==="Grundspel" && !m.winnerId){ complete = false; break; }
    }
    if(!complete){
      alert(chk.msg || "Grundspelet (serien) √§r inte klart √§nnu.");
      return;
    }
  }

  var ok = ensurePlayoffs();
  if(!ok){
    alert("Kunde inte starta slutspel. Kontrollera att grundspelet √§r klart.");
    return;
  }

  try{ state.step = getStepNums().playoffs; }catch(e){}
  saveState();
  renderAll();
}


function openPlayoffMatch(matchId){
  if(!state.playoffs || !state.playoffs.started){
    alert("Slutspel √§r inte startat √§nnu. N√§r gruppspelet √§r klart, tryck 'Starta slutspel'.");
    return;
  }

  var m = (state.playoffs && state.playoffs.matches) ? state.playoffs.matches.find(function(x){return x.id===matchId;}) : null;
  if(!m) return;

  // Kvartsfinal/semifinal/final kan kr√§va deltagare beroende p√• uppl√§gg
  if((m.id==="po_sf1" || m.id==="po_sf2") && (!m.aId || !m.bId)){
    alert("Semifinalen blir tillg√§nglig n√§r relevanta kvartsfinaler √§r klara.");
    return;
  }
  if(m.id==="po_f" && (!m.aId || !m.bId)){
    alert("Finalen blir tillg√§nglig n√§r b√•da semifinalerna √§r klara.");
    return;
  }

  modal.source = "playoffs";
  openMatchInternal(m);
}



function ruleSummary(){
  const r = state.rules;
  const inT = r.inRule==="single" ? "Enkel in" : "Dubbel in";
  const outT = r.outRule==="single" ? "Enkel ut" : "Dubbel ut";
  const legs = r.legsMode==="single" ? "1 leg" : "B√§st av 3";
  return `${r.game} ‚Ä¢ ${inT} ‚Ä¢ ${outT} ‚Ä¢ ${legs}`;
}

function renderMatches(){
  applyStartStamp();
  const ms = state.matches || [];
  const rows=[];
  rows.push(`<tr><th>Match</th><th>Status</th></tr>`);
  ms.forEach(m=>{
    const played = !!m.winnerId;
    const status = played
      ? `<span class="tag ok">${escapeHtml(playerName(m.winnerId))} vann ${m.result?`(${escapeHtml(m.result)})`:``}</span>`
      : `<span class="tag todo">Ej spelad</span>`;
    rows.push(`
      <tr class="matchRow ${played?'played':''}" onclick="openMatch('${m.id}')">
        <td>
          <div class='row' style='align-items:center;gap:8px'>${_avatarBtnViewHtml(m.aId, playerName(m.aId), 'small')}<strong>${escapeHtml(playerName(m.aId))}</strong><span class='muted'>vs</span>${_avatarBtnViewHtml(m.bId, playerName(m.bId), 'small')}<strong>${escapeHtml(playerName(m.bId))}</strong></div>
          <div class="matchMeta">
            <span class="tag">${m.group==='Alla' ? 'Serie' : 'Grupp '+escapeHtml(m.group)}</span>
            ${m.finishedAt ? `<span class="tag">Avsl: ${escapeHtml(formatDateTimeShort(m.finishedAt))}</span>` : ``}
            ${m.avgA || m.avgB ? `<span class="tag">Avg: ${escapeHtml(m.avgA||'‚Äì')} / ${escapeHtml(m.avgB||'‚Äì')}</span>` : ``}
          </div>
        </td>
        <td>${status}</td>
      </tr>
    `);
  });
  $("matchesTable").innerHTML = rows.join("");
  try{ hydrateAvatarsIn($("matchesTable")); }catch(e){}
}

function computeStandings(playerIds, matches, filterFn){
  const st = {};
  playerIds.forEach(pid => st[pid] = {
    pid,
    played: 0, w: 0, l: 0, pts: 0,
    legsWon: 0, legsLost: 0,
    avgSum: 0, avgCount: 0,
    f9Sum: 0, f9Count: 0,
    coSum: 0, coCount: 0
  });

  (matches || []).forEach(m => {
    if(filterFn && !filterFn(m)) return;

    // Averages
    if(m.avgA !== "" && !isNaN(parseFloat(m.avgA))){
      st[m.aId].avgSum += parseFloat(m.avgA);
      st[m.aId].avgCount += 1;
    }
    if(m.avgB !== "" && !isNaN(parseFloat(m.avgB))){
      st[m.bId].avgSum += parseFloat(m.avgB);
      st[m.bId].avgCount += 1;
    }

    // First 9
    if(m.f9A !== "" && !isNaN(parseFloat(m.f9A))){
      st[m.aId].f9Sum += parseFloat(m.f9A);
      st[m.aId].f9Count += 1;
    }
    if(m.f9B !== "" && !isNaN(parseFloat(m.f9B))){
      st[m.bId].f9Sum += parseFloat(m.f9B);
      st[m.bId].f9Count += 1;
    }

    // Checkout %
    if(m.coA !== "" && !isNaN(parseFloat(m.coA))){
      st[m.aId].coSum += parseFloat(m.coA);
      st[m.aId].coCount += 1;
    }
    if(m.coB !== "" && !isNaN(parseFloat(m.coB))){
      st[m.bId].coSum += parseFloat(m.coB);
      st[m.bId].coCount += 1;
    }

    if(!m.winnerId) return;

    const loserId = (m.winnerId === m.aId) ? m.bId : m.aId;

    // Match bookkeeping
    st[m.winnerId].played += 1;
    st[loserId].played += 1;
    st[m.winnerId].w += 1;
    st[loserId].l += 1;
    st[m.winnerId].pts += 2;

    // Legs bookkeeping (winner score stored first in m.result, e.g. "2-1")
    let wLegs = 0, lLegs = 0;
    if(m.result){
      const mm = String(m.result).match(/(\d+)\s*-\s*(\d+)/);
      if(mm){
        wLegs = parseInt(mm[1], 10);
        lLegs = parseInt(mm[2], 10);
      }
    }else{
      // Fallback for single-leg if result wasn't stored
      try{
        if(state && state.rules && state.rules.legsMode === "single"){
          wLegs = 1; lLegs = 0;
        }
      }catch(e){}
    }

    st[m.winnerId].legsWon  += wLegs;
    st[m.winnerId].legsLost += lLegs;
    st[loserId].legsWon     += lLegs;
    st[loserId].legsLost    += wLegs;
  });

  const arr = Object.values(st).map(x => ({
    ...x,
    avg: x.avgCount ? (x.avgSum / x.avgCount) : null,
    f9:  x.f9Count  ? (x.f9Sum  / x.f9Count)  : null,
    co:  x.coCount  ? (x.coSum  / x.coCount)  : null,
    legDiff: x.legsWon - x.legsLost
  }));

  arr.sort((a,b)=>{
    if(b.pts!==a.pts) return b.pts-a.pts;
    if(b.w!==a.w) return b.w-a.w;
    if(b.legDiff!==a.legDiff) return b.legDiff-a.legDiff;
    if(b.legsWon!==a.legsWon) return b.legsWon-a.legsWon;
    if(a.l!==b.l) return a.l-b.l;
    return playerName(a.pid).localeCompare(playerName(b.pid));
  });

  return arr;
}



function formatDateTimeIso(iso){
  if(!iso) return "";
  const d = new Date(iso);
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
}


function formatDateTimeShort(iso){
  if(!iso) return "";
  const d = new Date(iso);
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  return `${dd}/${mm} ${hh}:${mi}`;
}

function applyStartStamp(){
  const stamp = (state && state.startedAt) ? `Start: ${formatDateTimeIso(state.startedAt)}` : "";
  const ids = ["uiDateMatches","uiDateTable","uiDatePlayoffs","printDate","printDateFinals","printDateMatches","printDateTable"];
  ids.forEach(function(id){
    const el = document.getElementById(id);
    if(el) el.textContent = stamp;
  });
}

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }






function standingsTableHtml(standings, opts){
  opts = opts || {};
  var qualifyTop = opts.qualifyTop || 0;
  var title = opts.title || "";
  var sub = opts.sub || "";
  var rows = standings.map(function(s,i){
    var avg = s.avg==null ? "‚Äì" : (Math.round(s.avg*10)/10).toFixed(1);
    var f9 = s.f9==null ? "‚Äì" : (Math.round(s.f9*10)/10).toFixed(1);
    var co = s.co==null ? "‚Äì" : (Math.round(s.co*10)/10).toFixed(1);
    var qual = (qualifyTop && i < qualifyTop);
    var badge = "";
    var cls = qual ? " class='qual'" : "";
    return `<tr${cls}><td>`+
      `<div class='row standingsPlayerCell'>`
      + `${i+1}.`
      + `${_avatarBtnViewHtml(s.pid, playerName(s.pid), 'small')}`
      /* Viktigt f√∂r PDF-export: print-CSS d√∂ljer knappar om de inte har .clickableName */
      + `<button type="button" class="linkbtn clickableName standingsNameBtn" onclick="event.stopPropagation(); openPlayerModal('${s.pid}')">${escapeHtml(playerName(s.pid))}</button>`
      + `</div>`+
      `</td><td>${s.played}</td><td>${s.w}</td><td>${s.l}</td><td>${s.pts}</td><td>${s.legsWon}</td><td>${avg}</td><td>${f9}</td><td>${co}</td></tr>`;
  }).join("");

  var head = `<tr><th>Spelare</th><th>Sp</th><th>V</th><th>F</th><th>P</th><th>Legs</th><th>Avg</th><th>F9</th><th>Utg %</th></tr>`;
  var info = sub ? `<div class="small">${sub}</div>` : "";
  return `${title?`<div class="row" style="justify-content:space-between;align-items:end"><strong>${escapeHtml(title)}</strong>${info}</div>`:""}<table>${head}${rows}</table>`;
}

function renderStandings(){
  applyStartStamp();
  var hint = "Po√§ng: 2 f√∂r vinst ‚Ä¢ Vid lika po√§ng: Vinster ‚Üí Legskillnad ‚Üí Vunna legs ‚Üí Avg ‚Üí Utg% ‚Üí F9 ‚Üí F√§rre f√∂rluster ‚Üí Namn";
  var leg = document.getElementById("tableLegendBody");
  if(leg){
    leg.innerHTML = `<div><strong>${escapeHtml(hint)}</strong></div>` +
      `<div style="margin-top:4px">F√∂rkortningar: <strong>Sp</strong>=spelade, <strong>V</strong>=vunna, <strong>F</strong>=f√∂rlorade, <strong>P</strong>=po√§ng, <strong>Legs</strong>=vunna‚Äìf√∂rlorade, <strong>Avg</strong>=snitt, <strong>F9</strong>=f√∂rsta 9, <strong>Utg %</strong>=uttag</div>`;
  }
  if(state.format==="round_robin" || state.format==="round_robin_playoffs"){
    var idsRR = (state.players||[]).map(function(p){return p.id;});
    // Grundspel/serie: alla matcher i state.matches √§r "Grundspel" f√∂r round robin.
    var stRR = computeStandings(idsRR, state.matches, function(m){ return m && m.stage==="Grundspel"; });

    var qualifyTopRR = 0;
    var subRR = "";
    if(state.format==="round_robin_playoffs"){
      var nRR = idsRR.length;
      qualifyTopRR = (nRR >= 8) ? 8 : 4;
      subRR = (qualifyTopRR===8)
        ? "Topp 8 g√•r till slutspel (kvartsfinal: 1‚Äì8, 4‚Äì5, 2‚Äì7, 3‚Äì6)"
        : "Topp 4 g√•r till slutspel (semifinal: 1‚Äì4, 2‚Äì3)";
    }

    $("standingsWrap").innerHTML = standingsTableHtml(stRR, {title:"Serie", qualifyTop:qualifyTopRR, sub:subRR});
    try{ hydrateAvatarsIn($("standingsWrap")); }catch(e){}
    return;
  }
  // Group formats
  var A = computeStandings(state.groups.A||[], state.matches, function(m){ return m.group==="A"; });
  var B = computeStandings(state.groups.B||[], state.matches, function(m){ return m.group==="B"; });
  var C = computeStandings(state.groups.C||[], state.matches, function(m){ return m.group==="C"; });
  var D = computeStandings(state.groups.D||[], state.matches, function(m){ return m.group==="D"; });

  var q = (state.format==="group_playoffs") ? 2 : 0;

  if(state.numGroups===4){
    $("standingsWrap").innerHTML =
      standingsTableHtml(A, {title:"Grupp A", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(B, {title:"Grupp B", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(C, {title:"Grupp C", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(D, {title:"Grupp D", qualifyTop:q});
  }else{
    $("standingsWrap").innerHTML =
      standingsTableHtml(A, {title:"Grupp A", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(B, {title:"Grupp B", qualifyTop:q});
  }
  try{ hydrateAvatarsIn($("standingsWrap")); }catch(e){};
}


function renderFormatLegend(){
  var el = $("formatLegendBody");
  if(!el) return;

  var html = "";
  html += "<div style='margin-bottom:10px'><strong>S√• funkar uppl√§ggen</strong><br>";
  html += "V√§lj spelform p√• <em>Uppl√§gg</em>. N√§r du har lagt till spelare och skapat turneringen f√•r du en matchlista d√§r ni fyller i resultat. Tabellen uppdateras automatiskt n√§r spelformen anv√§nder tabell.</div>";

  html += "<div style='margin:10px 0'><strong>Spelformer</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";

  html += "<li><strong>Slutspel</strong>: direkt enkel-eliminering (f√∂rlust = utslagen). Vid 5‚Äì6 spelare skapas <strong>kval</strong> automatiskt s√• att tr√§det blir 4/8/16/32. Vinnare f√∂rs vidare till n√§sta runda n√§r matchen sparas.</li>";

  html += "<li><strong>Alla m√∂ter alla (serie)</strong>: alla m√∂ter alla. Passar n√§r ni vill ha en ren tabell och ingen final.</li>";

  html += "<li><strong>Alla m√∂ter alla (serie) + slutspel</strong>: f√∂rst spelar ni en serie. Sedan g√•r de b√§sta vidare till slutspel:<br>";
  html += "&nbsp;&nbsp;‚Ä¢ Vid <strong>4‚Äì7</strong> deltagare g√•r <strong>topp 4</strong> vidare ‚Üí semifinaler (1‚Äì4, 2‚Äì3).<br>";
  html += "&nbsp;&nbsp;‚Ä¢ Vid <strong>8+</strong> deltagare g√•r <strong>topp 8</strong> vidare ‚Üí kvartsfinaler (1‚Äì8, 4‚Äì5, 2‚Äì7, 3‚Äì6).</li>";

  html += "<li><strong>Gruppspel</strong>: deltagarna delas i 2 eller 4 grupper. Alla m√∂ter alla inom sin grupp.</li>";

  html += "<li><strong>Gruppspel + slutspel</strong>: som Gruppspel, men topp 2 i varje grupp g√•r vidare till slutspel.</li>";

  html += "</ul>";

  html += "<div style='margin:12px 0 6px 0'><strong>S√• visas matcherna</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";
  html += "<li>I matchlistan ser du status (t.ex. <em>‚ÄòBamse vann (1‚Äì0)‚Äô</em>), avslutstid och valfri statistik (avg m.m.).</li>";
  html += "<li>I slutspelstr√§det visas resultat i rutorna och vinnaren markeras gr√∂nt.</li>";
  html += "</ul>";

  html += "<div style='margin:12px 0 6px 0'><strong>Det h√§r finns inte √§nnu</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";
  html += "<li>Ingen dubbel-eliminering, tr√∂stfinal eller placeringsmatcher.</li>";
  html += "<li>Matchformat k√∂rs i legs. Set-st√∂d finns inte.</li>";
  html += "<li>Slutspel lottas/seedas automatiskt (i serie/grupp utifr√•n tabell, annars slumpat). Du kan inte √§ndra seedningen manuellt √§nnu.</li>";
  html += "<li>Grupper skapas automatiskt (ingen manuell gruppdragning √§nnu).</li>";
  html += "</ul>";

  html += "<div style='margin:12px 0 6px 0'><strong>Det h√§r kan du g√∂ra</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";
  html += "<li>K√∂r b√•de Singel och Lag (2-mot-2).</li>";
  html += "<li>V√§lj 301/501, enkel/dubbel in/ut och hur m√•nga g√•nger man m√∂ts i serie/grupp.</li>";
  html += "<li>Tabellen visar placering och markerar vilka som g√•r vidare n√§r slutspel ing√•r.</li>";
  html += "<li>P√• <em>Spelare</em> kan du anv√§nda <strong>V√§lj flera‚Ä¶</strong> f√∂r att l√§gga till flera sparade spelare i ett svep.</li>";
  html += "</ul>";

  el.innerHTML = html;
}


function openFormatLegend(){
  try{ renderFormatLegend(); }catch(e){}
  var ov = $("overlayFormatLegend");
  if(ov) ov.classList.remove("hidden");
}
function closeFormatLegend(){
  var ov = $("overlayFormatLegend");
  if(ov) ov.classList.add("hidden");
}

function onFormatChange(){
  var f = $("format") ? $("format").value : (state.format||"");
  var wrap = $("numGroupsWrap");
  if(wrap){
    var show = (f==="group_only" || f==="group_playoffs");
    wrap.style.display = show ? "" : "none";
  }
  // Om man inte k√∂r gruppspel: spara √§nd√• v√§rdet men l√•t det vara dolt.
  // Vi beh√•ller state.numGroups som senast valda s√• det finns kvar om man byter tillbaka.
  try{ saveState(); }catch(e){}
}

function openTableLegend(){
  // Ensure content is up-to-date
  try{ if(!$("tableLegendBody") || !$("tableLegendBody").innerHTML) renderStandings(); }catch(e){}
  var ov = $("overlayTableLegend");
  if(ov) ov.classList.remove("hidden");
}
function closeTableLegend(){
  var ov = $("overlayTableLegend");
  if(ov) ov.classList.add("hidden");
}

function updateProgress(){
  const total = (state.matches||[]).length;
  const done = (state.matches||[]).filter(m=>!!m.winnerId).length;
  const _pp = $("progressPill"); if(_pp){ _pp.innerHTML = `<strong>${done}</strong> / ${total} klara`; }
  $("rulesPill").innerHTML = `<strong>${escapeHtml(state.rules.game)}</strong> ‚Ä¢ ${escapeHtml(ruleSummary())}`;
  if ($("rulesPillTable")) $("rulesPillTable").innerHTML = $("rulesPill").innerHTML;
}

function playWalkon(pid){
  var p = playerById(pid); if(!p) return;
  openSpotifyAuto(p.walkonUrl||"");
}

/* Modal */
var modalSidesSwapped = false;
var modalStatsOrderSwapped = false;

function updateModalTitleOrder(){
  // Matchrubriken ska spegla aktuell v√§nster/h√∂ger-ordning i modalen
  var m = (state.matches||[]).find(function(x){return x.id===modal.id;});
  if(!m) return;
  var leftId  = modalSidesSwapped ? m.bId : m.aId;
  var rightId = modalSidesSwapped ? m.aId : m.bId;
  var t = $("modalTitle");
  if(t) t.textContent = playerName(leftId) + " vs " + playerName(rightId);
}

function toggleSides(){
  modalSidesSwapped = !modalSidesSwapped;
  var mm = $("matchModal");
  if(mm) mm.classList.toggle("swapped", modalSidesSwapped);

  // P√• smala sk√§rmar staplas A/B ofta vertikalt. D√• vill vi att den som st√•r f√∂rst i rubriken
  // ocks√• kommer f√∂rst i reglageordningen (utan att byta vad A/B betyder i datan).
  ensureStatsOrder(modalSidesSwapped);

  updateModalTitleOrder();
}

function _swapTwoChildren(parent){
  if(!parent) return;
  var kids = Array.prototype.slice.call(parent.children || []);
  if(kids.length < 2) return;
  parent.insertBefore(kids[1], kids[0]);
}

function ensureStatsOrder(swapped){
  // Vi vill att den som st√•r f√∂rst (v√§nster) ocks√• kommer f√∂rst n√§r reglagen staplas vertikalt.
  // F√∂r att inte riskera att A/B-datan blandas ihop byter vi bara DOM-ordning, inte id:n.
  if(!!swapped === !!modalStatsOrderSwapped) return;
  _swapTwoChildren($("avgSplit"));
  _swapTwoChildren($("f9Split"));
  _swapTwoChildren($("coSplit"));
  modalStatsOrderSwapped = !!swapped;
}

function openMatch(matchId){
  // Huvudmatcher + robust fallback f√∂r slutspelsmatcher
  if(matchId && String(matchId).indexOf("po_")===0){
    // Om detta √§r en slutspelsmatch, f√∂rs√∂k √∂ppna via slutspelslogiken.
    try{
      if(state && state.playoffs && Array.isArray(state.playoffs.matches)){
        var pm = state.playoffs.matches.find(function(x){ return x && x.id===matchId; });
        if(pm){
          modal.source = "playoffs";
          openMatchInternal(pm);
          return;
        }
      }
    }catch(e){}
  }

  var m = (state.matches||[]).find(function(x){return x.id===matchId;});
  if(!m) return;
  modal.source = "main";
  openMatchInternal(m);
}

function openMatchInternal(m){
  modal.id = m.id;

  // √Öterst√§ll sidbyte n√§r du √∂ppnar en match
  modalSidesSwapped = false;
  var mm = $("matchModal");
  if(mm) mm.classList.remove("swapped");

  // S√§kerst√§ll att reglageordningen √§r √•terst√§lld n√§r en ny match √∂ppnas
  ensureStatsOrder(false);

  var aName = playerName(m.aId);
  var bName = playerName(m.bId);
  
  var pidA = resolvePlayerId(m.aId) || m.aId;
  var pidB = resolvePlayerId(m.bId) || m.bId;
var titleEl = $("modalTitle");
  if(titleEl){
    titleEl.innerHTML =
      "<span class='matchTitleRow'>"
      + _avatarBtnViewHtml(pidA, aName, 'small')
      + "<span class='matchTitleName'>"+escapeHtml(aName)+"</span>"
      + "<span class='matchTitleVs'>vs</span>"
      + _avatarBtnViewHtml(pidB, bName, 'small')
      + "<span class='matchTitleName'>"+escapeHtml(bName)+"</span>"
      + "</span>";
    setTimeout(function(){ try{ hydrateAvatarsIn(titleEl); }catch(e){} }, 0);
  }
  var ctx = (m.group==='Alla'?'Serie':(m.group==='A' || m.group==='B' ? 'Grupp '+m.group : (m.round||m.group||'')));
  $("modalMeta").textContent = ctx + " ‚Ä¢ " + ruleSummary();
  try{ hydrateAvatarsIn($("matchModal")); }catch(e){}
  $("winA").textContent = "Vinnare: " + playerName(m.aId);
  $("winB").textContent = "Vinnare: " + playerName(m.bId);
  $("avgALabel").textContent = "Average (" + playerName(m.aId) + ") ‚Äì manuellt";
  $("avgBLabel").textContent = "Average (" + playerName(m.bId) + ") ‚Äì manuellt";
  $("f9ALabel").textContent = "First 9 (" + playerName(m.aId) + ") ‚Äì manuellt";
  $("f9BLabel").textContent = "First 9 (" + playerName(m.bId) + ") ‚Äì manuellt";
  $("coALabel").textContent = "Utg√•ng % (" + playerName(m.aId) + ") ‚Äì manuellt";
  $("coBLabel").textContent = "Utg√•ng % (" + playerName(m.bId) + ") ‚Äì manuellt";

  $("avgA").value = (m.avgA!=null && m.avgA!=="" ? m.avgA : 70.0);
  $("avgB").value = (m.avgB!=null && m.avgB!=="" ? m.avgB : 70.0);
  $("f9A").value = (m.f9A!=null && m.f9A!=="" ? m.f9A : 85.0);
  $("f9B").value = (m.f9B!=null && m.f9B!=="" ? m.f9B : 85.0);
  $("coA").value = (m.coA!=null && m.coA!=="" ? m.coA : 50.0);
  $("coB").value = (m.coB!=null && m.coB!=="" ? m.coB : 50.0);
  $("notes").value = m.notes || "";
  syncStatSliders();
  try{ resetStatsImportUi(); }catch(e){}

  // Per-match override f√∂r utg√•ng (enkel->dubbel). Visas bara n√§r turneringen √§r Enkel ut.
  const gOut = (state.rules && state.rules.outRule) || "single";
  const wrap = $("outOverrideWrap");
  const chk = $("outOverrideDouble");
  if(wrap && chk){
    if(gOut === "double"){
      wrap.style.display = "none";
      chk.checked = false;
    } else {
      wrap.style.display = "block";
      chk.checked = (m.outRule === "double");
    }
  }

  $("winA").classList.toggle("primary", m.winnerId===m.aId);
  $("winB").classList.toggle("primary", m.winnerId===m.bId);

  renderResultButtons(m);
  renderWalkonInfo(m);

  // L√•s om matchen redan √§r sparad
  var played = !!m.winnerId;
  setModalLocked(played);

  $("overlay").classList.remove("hidden");
document.body.classList.add("modal-open");
  try{ document.querySelector("#overlay .modal").scrollTop = 0; }catch(e){}
  // Synka bubblor efter att modalen blivit synlig (mobil-webview kan annars ge 0px-bredd)
  requestAnimationFrame(function(){
    syncStatSliders();
    requestAnimationFrame(syncStatSliders);
  });

}

function renderWalkonInfo(m){
  var pa = playerById(m.aId) || {};
  var pb = playerById(m.bId) || {};
  function detectUrl(p){
    // If walkonUrl is empty but label looks like a spotify link, treat it as url
    var u = (p.walkonUrl||"").trim();
    if(!u){
      var lab = (p.walkonLabel||"").trim();
      if(lab.indexOf("open.spotify.com/")>=0 || lab.indexOf("https://open.spotify.com/")===0 || lab.indexOf("spotify:")===0){
        u = lab;
      }
    }
    return u;
  }
  function detectLabel(p){
    var lab = (p.walkonLabel||"").trim();
    // If label is a URL, show a generic label
    if(lab.indexOf("open.spotify.com/")>=0 || lab.indexOf("https://open.spotify.com/")===0 || lab.indexOf("spotify:")===0){
      return "Walk-on";
    }
    return lab || "Walk-on";
  }
  function line(pid, p){
    if(!(p.walkonLabel || p.walkonUrl)) return "";
    var label = escapeHtml(detectLabel(p));
    var url = detectUrl(p);
    var who = "<strong>"+escapeHtml(playerName(pid))+"</strong>";
    if(url){
      var urlEsc = escapeHtml(url);
      return "üéµ "+who+": "+label+"<br><a class='link' href='"+urlEsc+"' target='_blank' rel='noopener' onclick=\"stopPropagation(event)\">√ñppna i Spotify</a>";
    }
    return "üéµ "+who+": "+label;
  }
  var lines = [];
  var la = line(m.aId, pa); if(la) lines.push(la);
  var lb = line(m.bId, pb); if(lb) lines.push(lb);
  $("walkonInfo").innerHTML = lines.length ? lines.join("<hr style='border:none;border-top:1px solid var(--border);margin:10px 0'>")
                                           : "<span class='small'>Inga walk-on songs sparade f√∂r den h√§r matchen.</span>";
}

function renderResultButtons(m){
  const wrap = $("resultButtons");
  const hint = $("resultHint");
  wrap.innerHTML = "";
  hint.textContent = "";

  if(state.rules.legsMode === "single"){
    hint.innerHTML = "1 leg: Resultat blir automatiskt <strong>1-0</strong> f√∂r vinnaren.";
    return;
  }

  const opts = ["2-0","2-1"];
  opts.forEach(res=>{
    const btn = document.createElement("button");
    btn.className = "btn secondary";
    btn.textContent = res;
    btn.onclick = function(){
      m.result = res;
      saveState();
      Array.from(wrap.querySelectorAll("button")).forEach(b=>{ b.className="btn secondary"; });
      btn.className = "btn";
      hint.innerHTML = "Valt resultat: <strong>"+res+"</strong>";
    };
    if(m.result === res){
      btn.className = "btn";
      hint.innerHTML = "Valt resultat: <strong>"+res+"</strong>";
    }
    wrap.appendChild(btn);
  });

  if(!m.result) hint.textContent = "B√§st av 3: V√§lj 2-0 eller 2-1.";
}

function closeModal(){
  try{ setModalLocked(false); }catch(e){}
  $("overlay").classList.add("hidden");
  document.body.classList.remove("modal-open");
}
function getCurrentMatch(){
  // Robust match lookup: fungerar √§ven om modal.source saknas eller om match-id finns i b√•da listor.
  var id = (modal && modal.id) ? modal.id : null;
  if(!id) return null;

  var fromMain = null;
  try{
    fromMain = (state.matches||[]).find(function(x){ return x && x.id===id; }) || null;
  }catch(e){ fromMain = null; }

  var fromPlayoffs = null;
  try{
    if(state && state.playoffs && Array.isArray(state.playoffs.matches)){
      fromPlayoffs = state.playoffs.matches.find(function(x){ return x && x.id===id; }) || null;
    }
  }catch(e){ fromPlayoffs = null; }

  // Respektera explicit k√§lla ‚Äì men fall back om den inte hittar matchen.
  if(modal && modal.source==="playoffs") return fromPlayoffs || fromMain;
  if(modal && modal.source==="main") return fromMain || fromPlayoffs;

  // Om k√§llan inte √§r satt: v√§lj efter id-prefix eller vad som finns.
  if(String(id).indexOf("po_")===0) return fromPlayoffs || fromMain;

  return fromMain || fromPlayoffs;
}

function pickWinner(side){
  var mm = getCurrentMatch();
  if(!mm) return;

  mm.winnerId = (side==="A") ? mm.aId : mm.bId;

  var winA = document.getElementById("winA");
  var winB = document.getElementById("winB");
  if(winA) winA.classList.toggle("primary", mm.winnerId===mm.aId);
  if(winB) winB.classList.toggle("primary", mm.winnerId===mm.bId);

  saveState();
  try{
    if(modal && modal.source==="playoffs"){
      if(state && state.format==="knockout") advancePlayoffWinners();
      else updateFinalFromSemis();
    }
  }catch(e){}
}

function clearMatch(){
  const m = getCurrentMatch();
  if(!m) return;
  m.winnerId = "";
  m.result = "";
  m.avgA = "";
  m.avgB = "";
  m.f9A = "";
  m.f9B = "";
  m.coA = "";
  m.coB = "";
  m.notes = "";
  $("avgA").value = 70.0;
  $("avgB").value = 70.0;
  $("f9A").value = 85.0;
  $("f9B").value = 85.0;
  $("coA").value = 50.0;
  $("coB").value = 50.0;
  $("notes").value = "";
  $("winA").classList.remove("primary");
  $("winB").classList.remove("primary");
  try{
    if(modal && modal.source==="playoffs" && state && state.format==="knockout"){
      // Rensa nedstr√∂ms deltagare d√§r denna vinnare tidigare kan ha g√•tt vidare
      advancePlayoffWinners();
    }
  }catch(e){}

  saveState();
  renderResultButtons(m);
  syncStatSliders();
}

function saveMatch(){
  if(state.modalLocked){ alert("Matchen √§r l√•st. Tryck p√• Redigera om du vill √§ndra."); return; }

  const m = getCurrentMatch();
  if(!m) return;

  if(!m.winnerId){ alert("V√§lj vinnare f√∂rst."); return; }

  const a = $("avgA").value.trim();
  const b = $("avgB").value.trim();
  const f9a = $("f9A").value.trim();
  const f9b = $("f9B").value.trim();
  const coa = $("coA").value.trim();
  const cob = $("coB").value.trim();
  if(a && isNaN(parseFloat(a))) { alert("Average f√∂r " + playerName(m.aId) + " m√•ste vara ett tal."); return; }
  if(b && isNaN(parseFloat(b))) { alert("Average f√∂r " + playerName(m.bId) + " m√•ste vara ett tal."); return; }
  if(f9a && isNaN(parseFloat(f9a))) { alert("First 9 f√∂r " + playerName(m.aId) + " m√•ste vara ett tal."); return; }
  if(f9b && isNaN(parseFloat(f9b))) { alert("First 9 f√∂r " + playerName(m.bId) + " m√•ste vara ett tal."); return; }
  if(coa && isNaN(parseFloat(coa))) { alert("Utg√•ng % f√∂r " + playerName(m.aId) + " m√•ste vara ett tal."); return; }
  if(cob && isNaN(parseFloat(cob))) { alert("Utg√•ng % f√∂r " + playerName(m.bId) + " m√•ste vara ett tal."); return; }

  m.avgA = a;
  m.avgB = b;
  m.f9A = f9a;
  m.f9B = f9b;
  m.coA = coa;
  m.coB = cob;
  m.notes = $("notes").value.trim();

  // Vilket utg√•ngsl√§ge anv√§ndes faktiskt i matchen?
  // Standard = turneringsvalet, men vid Enkel ut kan man override till Dubbel ut.
  let usedOut = (state.rules && state.rules.outRule) || "single";
  const override = $("outOverrideDouble") && $("outOverrideDouble").checked;
  if(usedOut !== "double" && override){ usedOut = "double"; }
  m.outRule = usedOut;

  if(state.rules.legsMode === "single"){
    m.result = "1-0";
  }else{
    if(!m.result){ alert("V√§lj resultat (2-0 eller 2-1)."); return; }
  }
  m.finishedAt = new Date().toISOString();
  recordHistoryForMatch(m);

  // === FIX: S√§kra att sparning av po_* alltid skrivs till state.playoffs.matches (inte bara en lokal referens) ===
  try{
    if(m && m.id && String(m.id).indexOf("po_")===0 && state && state.playoffs && Array.isArray(state.playoffs.matches)){
      const pm = state.playoffs.matches.find(x => x && x.id===m.id) || null;
      if(pm && pm !== m){
        // Kopiera centrala f√§lt som p√•verkar status/propagering/rendering
        const keys = ["aId","bId","winnerId","result","avgA","avgB","f9A","f9B","coA","coB","notes","outRule","finishedAt"];
        for(const k of keys){
          if(Object.prototype.hasOwnProperty.call(m,k)) pm[k] = m[k];
        }
      }
      // Om modalen √∂ppnades via fel k√§lla: tvinga playoffs som k√§lla s√• √∂vrig logik k√∂rs r√§tt.
      try{ if(typeof modal!=="undefined") modal.source = "playoffs"; }catch(e){}
    }
  }catch(e){}

  try{
    if(modal && modal.source==="playoffs" && m.id && String(m.id).indexOf("po_")===0){
      if(state && state.format==="knockout"){
        advancePlayoffWinners();
      }else{
        // Grupp/serie-slutspel: fyll final (och ev. semifinaler om kvarts finns) fr√•n spelade matcher
        updateFinalFromSemis();
      }
      // Spegla ev. po_* som kan finnas i state.matches s√• tr√§det alltid f√•r senaste data
      ensurePlayoffsSync();
    }
  }catch(e){}

  autosaveTournament();
  saveState();
  closeModal();
  renderAll();
}

function recordHistoryForMatch(m){
  try{
    if(!m || !m.winnerId) return;
    // just nu: spara historik bara f√∂r singel-l√§ge (spelareprofiler)
    if(state.mode && state.mode !== "single") return;
    var res = m.result || (state.rules && state.rules.legsMode==="single" ? "1-0" : "");
    var parts = String(res||"").split("-");
    var aW = parseInt(parts[0]||"0",10) || 0;
    var bW = parseInt(parts[1]||"0",10) || 0;

    function perSide(pid, isA){
      var won = (m.winnerId === pid);
      var legsFor = isA ? aW : bW;
      var legsAgainst = isA ? bW : aW;
      if(!won){ // om denna sida f√∂rlorade, byt om s√• legsFor alltid √§r dennes legs
        // i res-str√§ngen representerar aW-bW antal l√§gg f√∂r A respektive B oavsett vinnare
      }
      var avg = parseFloat(isA ? m.avgA : m.avgB);
      var f9  = parseFloat(isA ? m.f9A : m.f9B);
      var co  = parseFloat(isA ? m.coA : m.coB);
      if(isNaN(avg)) avg = null;
      if(isNaN(f9)) f9 = null;
      if(isNaN(co)) co = null;
      var opp = isA ? playerName(m.bId) : playerName(m.aId);
      upsertHistoryMatch(pid, {
        matchId: (state.startedAt||'') + '::' + m.id,
        finishedAt: m.finishedAt,
        opponent: opp,
        won: won,
        result: res,
        legsFor: legsFor,
        legsAgainst: legsAgainst,
        avg: avg,
        f9: f9,
        co: co,
        outRule: m.outRule || ((state.rules && state.rules.outRule) ? state.rules.outRule : 'single')
      });
    }
    perSide(m.aId, true);
    perSide(m.bId, false);
  }catch(e){}
}




function renderPlayersStep(){
  // Synka val
  if($("playerSource3")){
    $("playerSource3").value = state.playerSource || "manual";
  }
  const isFile = (false);
  const fileWrap = $("fileImportWrap");
  const manualWrap = $("manualPlayersWrap");
  if(fileWrap && manualWrap){
    if(isFile){
      fileWrap.classList.remove("hidden");
      manualWrap.classList.add("hidden");
    }else{
      fileWrap.classList.add("hidden");
      manualWrap.classList.remove("hidden");
    }
  }

  // F√∂rhandsvisning
  if($("playersPreview3")){
    if(state.importedPlayers && state.importedPlayers.length){
      const rows = state.importedPlayers.slice(0,20).map(p => `
        <tr>
          <td>${escapeHtml(p.name||"")}</td>
          <td class="small">${escapeHtml(p.walkonLabel||"")}</td>
          <td class="small">${p.walkonUrl ? `<a href="${escapeHtml(p.walkonUrl)}" target="_blank" rel="noopener">Spotify</a>` : "-"}</td>
          <td class="small">${escapeHtml(p.darts||"")}</td>
        </tr>`).join("");
      $("playersPreview3").innerHTML = `
        <div class="small" style="margin-bottom:8px"><strong>${state.importedPlayers.length}</strong> spelare hittade . F√∂rhandsvisar upp till 20.</div>
        <div class="tablewrap">
          <table>
            <thead><tr><th>Namn</th><th>Walk-on</th><th>L√§nk</th><th>Pilar</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }else{
      $("playersPreview3").innerHTML = `<div class="small">Ingen fil inl√§st √§nnu.</div>`;
    }
  }

  // V√§xla UI f√∂r import/kiosk + singel/lag
  if(!state.entryMode) state.entryMode = "import";
  if(!state.mode) state.mode = "single";
  var ms = document.getElementById("mode");
  if(ms && ms.value) state.mode = ms.value;
  try{ applyEntryUI(); }catch(e){}
}

function onPlayerSource3Change(){
  state.playerSource = $("playerSource3") ? $("playerSource3").value : "manual";
  saveState();
  renderPlayersStep();
}

// Enkel manuella f√§lt-parser (st√∂d f√∂r citattecken)
function parseCSV(text){
  const lines = (text||"").split(/\r?\n/).filter(l => l.trim().length>0);
  if(lines.length===0) return { headers: [], rows: [] };

  function parseLine(line){
    const out=[];
    let cur="", inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch==='"'){
        if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
        else inQ=!inQ;
      }else if(ch===',' && !inQ){
        out.push(cur);
        cur="";
      }else{
        cur+=ch;
      }
    }
    out.push(cur);
    return out.map(s=>s.trim());
  }

  const headers = parseLine(lines[0]).map(h => h.replace(/^\uFEFF/, "").trim().toLowerCase());
  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols = parseLine(lines[i]);
    const row={};
    headers.forEach((h,idx)=> row[h]= (cols[idx]!==undefined ? cols[idx].trim() : ""));
    rows.push(row);
  }
  return { headers, rows };
}

function buildPlayersFromCSV(text){
  const { headers, rows } = parseCSV(text);
  const col = (name)=> headers.includes(name) ? name : null;

  const cDelta = col("delta");
  const cName = col("namn") || col("name");
  const cWalk = col("walkon_visning") || col("walkon") || col("walk-on") || col("walkon_namn");
  const cUrl  = col("spotify_link") || col("spotify") || col("spotify_l√§nk") || col("link");
  const cDarts= col("pilar") || col("darts");

  if(!cName){
    throw new Error("manuella f√§lt saknar kolumnen 'namn'.");
  }

  const out=[];
  const seen=new Set();
  rows.forEach(r=>{
    const delta = (cDelta ? (r[cDelta]||"") : "1").trim();
    if(cDelta && !(delta==="1" || delta.toLowerCase()==="ja" || delta.toLowerCase()==="true")) return;

    const name=(r[cName]||"").trim();
    if(!name) return;
    const key=name.toLowerCase();
    if(seen.has(key)) return;
    seen.add(key);

    const walkonLabel = (cWalk ? (r[cWalk]||"") : "").trim();
    const walkonUrl   = (cUrl  ? (r[cUrl]||"")  : "").trim();
    const darts       = (cDarts? (r[cDarts]||"") : "").trim();

    out.push({ id: uuid(), name, walkonLabel, walkonUrl, darts });
  });
  return out;
}

// ===== XLSX import (minimal, offline) =====
// L√§ser f√∂rsta bladet (sheet1.xml) och tolkar rubrikerna p√• rad 1.
async 

// (XLSX-import borttagen)

function looksLikeUrl(s){
  s = (s||"").trim();
  return /^https?:\/\//i.test(s) || /^spotify:/i.test(s);
}

function normalizeDelta(v){
  v = (v==null?"":String(v)).trim().toLowerCase();
  if(!v) return false;
  return (v==="1" || v==="ja" || v==="true" || v==="x" || v==="‚úÖ" || v==="y" || v==="yes");
}

function toRawCsvUrl(url){
  url = (url||"").trim();
  // Drive file view -> direct download (kan fortfarande kr√§va att filen √§r delad publikt)
  var m = url.match(/drive\.google\.com\/file\/d\/([^\/]+)\//);
  if(m){
    return "https://drive.google.com/uc?export=download&id=" + m[1];
  }
  // Google Sheets share URL -> export csv (gid unknown). We'll keep as-is if already contains export=csv.
  if(url.indexOf("docs.google.com/spreadsheets")>=0 && url.indexOf("export?format=csv")<0 && url.indexOf("gviz/tq")<0){
    // Best effort: use gviz (works without gid for first sheet in many cases)
    var idm = url.match(/spreadsheets\/d\/([^\/]+)/);
    if(idm){
      return "https://docs.google.com/spreadsheets/d/" + idm[1] + "/gviz/tq?tqx=out:csv";
    }
  }
  return url;
}

// Minimal manuella f√§lt parser with quotes support
function parseCsv(text){
  var rows=[];
  var row=[], cur="", inQ=false;
  for(var i=0;i<text.length;i++){
    var ch=text[i];
    if(inQ){
      if(ch === '"'){
        if(text[i+1] === '"'){ cur+='"'; i++; }
        else { inQ=false; }
      }else cur+=ch;
    }else{
      if(ch === '"'){ inQ=true; }
      else if(ch === ','){ row.push(cur); cur=""; }
      else if(ch === '\n'){
        row.push(cur); rows.push(row); row=[]; cur="";
      }else if(ch === '\r'){
        // ignore
      }else cur+=ch;
    }
  }
  if(cur.length || row.length){ row.push(cur); rows.push(row); }
  return rows;
}

// ===== Snabbimport (klistra in tabell) =====
function bulkClear(){
  var ta = document.getElementById('bulkPaste');
  if(ta) ta.value='';
  var st = document.getElementById('bulkStatus');
  if(st) st.textContent = '';
}

function bulkParse(){
  var ta = document.getElementById('bulkPaste');
  var st = document.getElementById('bulkStatus');
  var raw = (ta ? ta.value : '').trim();
  if(!raw){
    if(st) st.textContent = 'Klistra in n√•gra rader f√∂rst.';
    alert('Klistra in n√•gra rader f√∂rst.');
    return;
  }
  var delim = '\t';
  if(raw.indexOf('\t')<0 && raw.indexOf('|')>=0) delim = '|';
  var lines = raw.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  // hoppa √∂ver rubrikrad om den finns
  if(lines.length && /\b(delta|namn|walkon|spotify|pilar)\b/i.test(lines[0])) lines.shift();

  var names=[], walkon=[], links=[], darts=[];
  var used=0;
  for(var i=0;i<lines.length;i++){
    var parts = lines[i].split(delim).map(p=>p.trim());
    if(parts.length===1) continue;

    var hasDelta = parts.length>=5 && /^(0|1|ja|nej|true|false|x|‚úÖ)$/i.test(parts[0]||'');
    var delta = hasDelta ? parts[0] : '1';
    var name  = hasDelta ? parts[1] : parts[0];
    var w     = hasDelta ? (parts[2]||'') : (parts[1]||'');
    var link  = hasDelta ? (parts[3]||'') : (parts[2]||'');
    var pil   = hasDelta ? (parts[4]||'') : (parts[3]||'');

    if(hasDelta && !normalizeDelta(delta)) continue;
    if(!name) continue;

    // om n√•gon kopierar en klickbar text fr√•n Sheets kan den inneh√•lla extra saker ‚Äì beh√•ll bara URL om vi hittar en
    var m = (link||'').match(/(https?:\/\/[^\s]+|spotify:[^\s]+)/i);
    link = m ? m[1].trim() : (looksLikeUrl(link) ? link.trim() : '');

    names.push(name);
    walkon.push(w);
    links.push(link);
    darts.push(pil);
    used++;
  }

  document.getElementById('players').value = names.join('\n');
  document.getElementById('walkonLabels').value = walkon.join('\n');
  document.getElementById('spotifyLinks').value = links.join('\n');
  document.getElementById('darts').value = darts.join('\n');

  if(st) st.textContent = used ? ('Importerade '+used+' spelare till f√§lten nedan.') : 'Hittade inga spelare (kolla formatet).';
  // uppdatera ev. f√∂rhandsvisning om sidan redan visar spelare
  try{ renderPlayersPreview && renderPlayersPreview(); }catch(e){}
}









// Auto-fetch on load if configured
window.addEventListener("DOMContentLoaded", ()=>{
  // Kiosk-knappar
  try{
    var bs = document.getElementById('btnOpenSpotify');
    if(bs) bs.addEventListener('click', function(){ openSpotify(); });
    var ba = document.getElementById('btnKioskAdd');
    if(ba) ba.addEventListener('click', function(){ kioskAddSingle(); });
    var bat = document.getElementById('btnKioskAddTeam');
    if(bat) bat.addEventListener('click', function(){ kioskAddTeam(); });
  }catch(e){}
  // Enter-tangent sparar i kiosk-l√§ge
  try{
    ['kName','kSpotify','kDarts'].forEach(function(id){
      var el=document.getElementById(id);
      if(el) el.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); kioskAddSingle(); }});
    });
    ['kTeamName','kTeamP1','kTeamP2','kTeamSpotify','kTeamDarts'].forEach(function(id){
      var el=document.getElementById(id);
      if(el) el.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); kioskAddTeam(); }});
    });
  }catch(e){}

  // Ladda ev. sparat l√§ge och rendera p√• ett s√§kert s√§tt (mobil-webbl√§sare kan annars tyst sv√§lja fel)
  let loaded=false;
  try{ if(typeof loadState === "function") loaded = !!loadState(); }catch(e){ console.error(e); }
  // Om inget vanligt sparat l√§ge finns, f√∂rs√∂k √•terst√§ll fr√•n autospar
  if(!loaded){
    try{ if(typeof loadAutosaveTournament === "function") loaded = !!loadAutosaveTournament(); }catch(e){ console.error(e); }
    if(loaded){
      try{ saveState(); }catch(e){}
    }
  }
  try{ if(typeof renderAll === "function") renderAll(); }catch(e){ console.error(e); }

  // Kiosk/Import ‚Äì koppla knappar
  try{
    var bi = document.getElementById('btnEntryImport');
    if(bi) bi.addEventListener('click', function(){ try{ setEntryMode('import'); }catch(e){} });
    var bk = document.getElementById('btnEntryKiosk');
    if(bk) bk.addEventListener('click', function(){ try{ setEntryMode('kiosk'); }catch(e){} });

    var s1 = document.getElementById('btnOpenSpotify');
    if(s1) s1.addEventListener('click', function(){ try{ openSpotify(); }catch(e){} });
    var s2 = document.getElementById('btnOpenSpotify2');
    if(s2) s2.addEventListener('click', function(){ try{ openSpotify(); }catch(e){} });

    var add1 = document.getElementById('btnKioskAdd');
    if(add1) add1.addEventListener('click', function(){ try{ kioskAddSingle(); }catch(e){} });
    var add2 = document.getElementById('btnKioskAddTeam');
    if(add2) add2.addEventListener('click', function(){ try{ kioskAddTeam(); }catch(e){} });
    // Se till att r√§tt vy syns efter laddning
    try{ applyEntryUI(); }catch(e){}
  }catch(e){ console.error(e); }

  // Om sidan √∂ppnas via content:// p√• Android kan lagring rensas vid uppdatering.
  // Erbjud d√• √•terst√§llning via backupfil.
  try{
    const proto = (location && typeof location.protocol==="string") ? location.protocol : "";
    const isContent = proto.startsWith("content");
    if(!loaded && isContent){
      setTimeout(()=>{
        try{
          if(confirm("Ingen sparad session hittades (Android kan rensa lokal lagring n√§r du uppdaterar).\n\nVill du √•terst√§lla fr√•n en backupfil?")){
            const inp = document.getElementById("importBackup");
            if(inp) inp.click();
          }
        }catch(e){}
      }, 50);
    }
  }catch(e){}
  // Autospara: viktigt p√• Android/content:// d√§r man l√§tt r√•kar uppdatera/flippa flikar
  // F√∂rb√§ttring (utan att √§ndra funktion): debounce p√• √§ndringar + backup-intervall, och skydd mot samtidiga spar.
  try{
    const doSave = ()=>{
      try{
        if(window.__LH_SAVING__) return; // undvik re-entrance om flera triggers kommer samtidigt
        window.__LH_SAVING__ = true;
        if(typeof saveState==="function") saveState();
      }catch(e){
        // l√§mna tyst som tidigare (vill du fels√∂ka kan du logga h√§r)
      }finally{
        window.__LH_SAVING__ = false;
      }
    };

    // Spara alltid vid navigation/avslut
    window.addEventListener("beforeunload", doSave);
    window.addEventListener("pagehide", doSave);

    // Debounce spara n√§r anv√§ndaren g√∂r √§ndringar (input/change/click f√•ngar de flesta UI-interaktioner)
    let saveTimer = null;
    const scheduleSave = ()=>{
      try{
        if(saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(doSave, 800);
      }catch(e){}
    };

    document.addEventListener("input", scheduleSave, {passive:true, capture:true});
    document.addEventListener("change", scheduleSave, {passive:true, capture:true});
    document.addEventListener("click", scheduleSave, {passive:true, capture:true});

    // Backup-intervall (f√§rre writes √§n 5s men samma s√§kerhet)
    setInterval(doSave, 30000);
  }catch(e){}
  // === T√§vlingsform + kiosk-l√§ge (v34) ===

  if(window.__LH_V34_INIT_DONE__) {
    // Init redan gjort ‚Äì undvik dubbla event listeners
  } else {
    window.__LH_V34_INIT_DONE__ = true;

    try{
    // knappar import/kiosk
    var bI=document.getElementById('btnEntryImport');
    var bK=document.getElementById('btnEntryKiosk');
    if(bI) bI.addEventListener('click', function(){ setEntryMode('import'); });
    if(bK) bK.addEventListener('click', function(){ setEntryMode('kiosk'); });

    // spotify knappar
    var s1=document.getElementById('btnOpenSpotify');
    var s2=document.getElementById('btnOpenSpotify2');
    if(s1) s1.addEventListener('click', openSpotify);
    if(s2) s2.addEventListener('click', openSpotify);

    // spara
    var a1=document.getElementById('btnKioskAdd');
    var a2=document.getElementById('btnKioskAddTeam');
    if(a1) a1.addEventListener('click', kioskAddSingle);
    if(a2) a2.addEventListener('click', kioskAddTeam);
    // mode selector
    var ms=document.getElementById('mode');
    if(ms){
      ms.addEventListener('change', function(){
        state.mode = ms.value;
        if(state.mode!=='single' && state.mode!=='team') state.mode='single';
        applyEntryUI();
        var ks=document.getElementById('kioskStatus'); if(ks) ks.textContent='';
        saveState();
      });
    }
  }catch(e){}
  }

  applyEntryUI();
  setEntryMode(state.entryMode || 'import');

});


// Export/Import av hela turneringen (JSON)
// Export/Import av hela turneringen (JSON) ‚Äì turneringsfil som √§r stabil mellan telefoner
// - Beh√•ller legacyformat: hela state p√• toppniv√• (players/matches m.m.)
// - Skickar med profilbilder (IndexedDB) i _avatars som dataURL per avatarKey
// - R√∂r INTE globala sparade profiler/historik (minskar risken f√∂r "fel info" och extra spelare)
function autosaveExportTournament(){
  (async ()=>{
    try{
      saveState(); // spara f√∂rst

      // Legacy: hela state p√• toppniv√•
      const payload = deepClone(state);
      if(!Array.isArray(payload.players)) payload.players = [];
      if(!Array.isArray(payload.matches)) payload.matches = [];

      payload._exportedAt = new Date().toISOString();
      payload._app = "turneringsapp";
      payload._format = "tournament_v9_state_plus_avatars";

      // Avatars: exportera som dataURL per "avatarKey" (samma nyckel som UI anv√§nder)
      payload._avatars = {};
      try{
        if(typeof _idbGet === "function" && typeof _blobToDataURL === "function"){
          for(const p of payload.players){
            if(!p) continue;
            const rawId = p.id || null;
            const rawName = p.name || "";
            const key = resolvePlayerId(rawId) || resolvePlayerId(rawName) || rawId;
            if(!key) continue;

            try{
              const rec = await _idbGet(String(key)); // {blob,mime,updatedAt}
              if(!rec || !rec.blob) continue;
              const url = await _blobToDataURL(rec.blob).catch(()=>null);
              if(url) payload._avatars[String(key)] = url;
            }catch(e){}
          }
        }
      }catch(e){}

      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = (payload && payload.tournamentName ? payload.tournamentName : ("turnering_" + payload.players.length + "spelare")) + ".json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} }, 2000);
    }catch(e){
      alert("Kunde inte exportera turneringen: " + (e && e.message ? e.message : e));
    }
  })();
}

function autosaveHandleImportJsonFile(file){
  if(!file) return;
  const name = (file.name||"").toLowerCase();
  if(!(name.endsWith(".json"))){
    alert("V√§lj en JSON-fil (.json) som exporterats fr√•n appen.");
    return;
  }
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const obj = JSON.parse(String(ev.target.result||""));
      if(!obj || typeof obj !== "object") throw new Error("Ogiltigt inneh√•ll.");
      if(!Array.isArray(obj.players) || !Array.isArray(obj.matches)) throw new Error("Filen ser inte ut som en turnering.");

      // Normalisera/fyll p√• f√§lt som kan saknas mellan versioner
      state = obj;
      if(!state.rules) state.rules = { game:"301", inRule:"single", outRule:"single", legsMode:"single" };
      if(!state.step) state.step = 1;
      if(!state.format) state.format = "round_robin";
      if(!state.repeats) state.repeats = 1;
      if(!state.numGroups){
        try{
          var keys = state.groups ? Object.keys(state.groups) : [];
          state.numGroups = (keys && keys.length >= 4) ? 4 : 2;
        }catch(e){
          state.numGroups = 2;
        }
      }
      if(!state.groups){
        state.groups = (state.numGroups===4) ? { A: [], B: [], C: [], D: [] } : { A: [], B: [] };
      }else{
        if(state.numGroups===4){
          if(!state.groups.C) state.groups.C = [];
          if(!state.groups.D) state.groups.D = [];
        }
      }
      if(!state.playoffs) state.playoffs = { started:false, matches: [] };
      if(!state.matches) state.matches = [];
      if(!state.players) state.players = [];

      // Vi k√∂r alltid manuell spelark√§lla i denna version
      state.playerSource = "manual";

      // √Öterst√§ll profilbilder om filen inneh√•ller dem
      (async ()=>{
        try{
          const av = obj._avatars;
          if(av && typeof av === "object" && typeof _idbPut === "function"){
            const entries = Object.entries(av);
            for(const [key, dataUrl] of entries){
              if(!key || !dataUrl) continue;
              try{
                const res = await fetch(dataUrl);
                const blob = await res.blob();
                const mime = blob && blob.type ? blob.type : "image/jpeg";
                await _idbPut(String(key), { blob: blob, mime: mime, updatedAt: Date.now() }).catch(()=>null);
                try{ avatarCache[String(key)] = String(dataUrl); }catch(e){}
              }catch(e){}
            }
          }
          try{ hydrateAvatarsIn(document.body); }catch(e){}
        }catch(e){}
      })();

      saveState();
      renderAll();
      alert("Turnering importerad.");
    }catch(e){
      alert("Kunde inte importera: " + (e && e.message ? e.message : e));
    }
  };
  reader.readAsText(file);
}



// Backup (fil) ‚Äì anv√§nds som extra s√§kerhet p√• Android/content:// d√§r lokal lagring kan rensas vid uppdatering
function downloadAutosaveBackup(){
  try{
    saveState();
    const payload = deepClone(state);
    payload._exportedAt = new Date().toISOString();
    payload._app = "turneringsapp";
    payload._kind = "backup";
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "turnering_autosave.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} }, 2000);
  }catch(e){
    alert("Kunde inte spara backup: " + (e && e.message ? e.message : e));
  }
}

function handleBackupImportFile(file){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const obj = JSON.parse(String(ev.target.result||""));
      if(!obj || typeof obj !== "object") throw new Error("Ogiltigt inneh√•ll.");
      if(!Array.isArray(obj.players) || !Array.isArray(obj.matches)) throw new Error("Filen ser inte ut som en turnering.");

      state = obj;

      // Normalisera/fyll p√• f√§lt som kan saknas mellan versioner
      if(!state.rules) state.rules = { game:"301", inRule:"single", outRule:"single", legsMode:"single" };
      if(!state.step) state.step = 1;
      if(!state.format) state.format = "round_robin";
      if(!state.repeats) state.repeats = 1;
      // Antal grupper (2 = standard, 4 = ut√∂kat)
      if(!state.numGroups){
        try{
          var keys = state.groups ? Object.keys(state.groups) : [];
          state.numGroups = (keys && keys.length >= 4) ? 4 : 2;
        }catch(e){
          state.numGroups = 2;
        }
      }
      if(!state.groups){
        state.groups = (state.numGroups===4) ? { A: [], B: [], C: [], D: [] } : { A: [], B: [] };
      }else{
        // S√§kerst√§ll att nycklar finns n√§r man byter/√∂ppnar √§ldre turneringar
        if(state.numGroups===4){
          if(!state.groups.C) state.groups.C = [];
          if(!state.groups.D) state.groups.D = [];
        }
      }
      if(!state.playoffs) state.playoffs = { started:false, matches: [] };
      if(!state.matches) state.matches = [];
      if(!state.players) state.players = [];

      // Vi k√∂r alltid manuell spelark√§lla i denna version
      state.playerSource = "manual";

      saveState();
      renderAll();
      alert("Backup √•terst√§lld.");
    }catch(e){
      alert("Kunde inte √•terst√§lla backup: " + (e && e.message ? e.message : e));
    }
  };
  reader.readAsText(file);
}


/* Datumst√§mplar (sk√§rm + PDF) */
(function(){
  function formatDateLong(d){
    try{
      return d.toLocaleDateString('sv-SE', { year:'numeric', month:'long', day:'numeric' });
    }catch(e){
      // fallback
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${yyyy}-${mm}-${dd}`;
    }
  }
  function setText(id, text){
    const el = document.getElementById(id);
    if(el) el.textContent = text;
  }
  function applyDates(){
    const stamp = (typeof state !== 'undefined' && state && state.startedAt)
      ? `Start: ${formatDateTimeIso(state.startedAt)}`
      : '';

    setText('uiDateMatches', stamp);
    setText('uiDateTable', stamp);
    setText('uiDatePlayoffs', stamp);

    // PDF
    setText('printDate', stamp);
    setText('printDateFinals', stamp);
    setText('printDateMatches', stamp);
    setText('printDateTable', stamp);
  }
  window.applyDates = applyDates;

  // initial
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyDates);
  } else {
  if (window.applyDates) window.applyDates();
  }
  // ensure before print (some browsers re-evaluate DOM)
  window.addEventListener('beforeprint', applyDates);
})();


</script>
<!-- PRINT-ONLY: sammanst√§llning f√∂r PDF -->
<div aria-hidden="true" id="printRoot">
<div class="print-header">
<div class="print-title">Turnering</div>
<div class="print-meta"><span id="printDate"></span></div>
</div>
<section class="print-section">
<h1>Slutspel <span class="print-date-inline" id="printDateFinals"></span></h1>
<div id="print-finals-content"></div>
</section>
<section class="print-section page-break">
<h1>Matcher <span class="print-date-inline" id="printDateMatches"></span></h1>
<div id="print-matches-content"></div>
</section>
<section class="print-section page-break">
<h1>Tabell <span class="print-date-inline" id="printDateTable"></span></h1>
<div id="print-table-content"></div>
</section>
</div>
<!-- Anti pull-to-refresh + varning (n√∂dl√•s) -->
<script id="antiPullToRefreshScript">
(function () {
  // N√∂dl√•s f√∂r att minska risken f√∂r "pull-to-refresh" p√• Android/Chrome
  // Viktigt: f√•r INTE blockera klick p√• knappar (t.ex. "N√§sta").
  // D√§rf√∂r blockerar vi endast en tydlig ned√•tdrag-gest som startar p√• "tom yta"
  // och bara n√§r man √§r l√§ngst upp p√• sidan.

  function ensureBanner() {
    let el = document.getElementById('ptrWarningBanner');
    if (el) return el;
    el = document.createElement('div');
    el.id = 'ptrWarningBanner';
    el.setAttribute('role', 'status');
    el.style.position = 'fixed';
    el.style.left = '12px';
    el.style.right = '12px';
    el.style.top = '10px';
    el.style.zIndex = '99999';
    el.style.padding = '10px 12px';
    el.style.borderRadius = '12px';
    el.style.boxShadow = '0 8px 20px rgba(0,0,0,.18)';
    el.style.background = 'rgba(20, 20, 20, .92)';
    el.style.color = '#fff';
    el.style.fontSize = '14px';
    el.style.display = 'none';
    el.style.alignItems = 'center';
    el.style.justifyContent = 'space-between';
    el.style.gap = '12px';
    el.style.pointerEvents = 'none'; // <-- aldrig blockera klick under bannern

    const msg = document.createElement('div');
    msg.textContent = 'Undvik att dra ned√•t f√∂r att uppdatera. Anv√§nd Exportera f√∂r permanent backup.';
    msg.style.lineHeight = '1.2';

    el.appendChild(msg);
    document.body.appendChild(el);
    return el;
  }

  let lastWarnAt = 0;
  function maybeWarn() {
    const now = Date.now();
    if (now - lastWarnAt < 2000) return;
    lastWarnAt = now;
    const b = ensureBanner();
    b.style.display = 'flex';
    window.clearTimeout(b._hideT);
    b._hideT = window.setTimeout(() => { b.style.display = 'none'; }, 3000);
  }

  // CSS-hj√§lp: stoppa overscroll-bounce d√§r det st√∂ds
  try {
    document.documentElement.style.overscrollBehaviorY = 'none';
    document.body.style.overscrollBehaviorY = 'none';
  } catch (e) {}

  let startY = 0;
  let startX = 0;
  let startTargetIsInteractive = false;

  function isInteractiveTarget(t) {
    if (!t || !t.closest) return false;
    return !!t.closest('button, a, input, select, textarea, label, [role="button"]');
  }

  window.addEventListener('touchstart', function (e) {
    if (!e.touches || e.touches.length !== 1) return;
    startY = e.touches[0].clientY;
    startX = e.touches[0].clientX;
    startTargetIsInteractive = isInteractiveTarget(e.target);
  }, { passive: true });

  window.addEventListener('touchmove', function (e) {
    // Om gesten b√∂rjade p√• en knapp/input ska vi aldrig blockera (f√∂r att inte d√∂da klick)
    if (startTargetIsInteractive) return;

    if (!e.touches || e.touches.length !== 1) return;

    const y = e.touches[0].clientY;
    const x = e.touches[0].clientX;
    const dy = y - startY;
    const dx = Math.abs(x - startX);

    // Bara n√§r vi √§r l√§ngst upp
    const atTop = (window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0) <= 0;

    // Kr√§v en TYDLIG ned√•tdrag-gest (stor tr√∂skel s√• "tap + mikror√∂relse" inte p√•verkas)
    // Samt begr√§nsa sidled s√• vi inte st√∂r andra gester.
    if (atTop && dy > 60 && dx < 30) {
      e.preventDefault(); // f√∂rs√∂k blockera refresh
      maybeWarn();
    }
  }, { passive: false });
})();
</script>
<script id="backButtonGuardScript">
(function () {
  function showPtrBanner() {
    const b = document.getElementById('ptrWarningBanner');
    if (!b) return;
    b.style.display = 'flex';
    window.clearTimeout(b._hideT);
    b._hideT = window.setTimeout(() => { b.style.display = 'none'; }, 3000);
  }

  function safeSaveAll() {
    // F√∂rs√∂k spara allt som redan st√∂ds av sidan.
    try { if (typeof saveState === 'function') saveState(); } catch (e) {}
    try { if (typeof autosaveTournament === 'function') autosaveTournament(); } catch (e) {}}

  // OBS: Det g√•r inte att 100% garantera att bak√•t aldrig l√§mnar sidan i alla mobill√§gen.
  // D√§rf√∂r: 1) blockera s√• l√•ngt webbl√§saren till√•ter, 2) autospara aggressivt vid varje "l√§mna"-signal.

  const LOCK_PREFIX = '#__stay__';
  const GUARD_DEPTH = 80;

  function setLockHash() {
    const next = LOCK_PREFIX + Date.now().toString(36);
    try { location.hash = next; } catch (e) {}
  }

  function pushGuards() {
    try {
      for (let i = 0; i < GUARD_DEPTH; i++) {
        history.pushState({ __backGuard: true, i }, '', location.href);
      }
    } catch (e) {}
  }

  function arm() {
    if (!location.hash || !location.hash.startsWith(LOCK_PREFIX)) setLockHash();
    pushGuards();
  }

  // Init
  arm();

  // Spara n√§r sidan riskerar att l√§mnas / tappas ur minnet
  window.addEventListener('pagehide', safeSaveAll, { capture: true });
  window.addEventListener('beforeunload', safeSaveAll, { capture: true });
  document.addEventListener('visibilitychange', function () {
    if (document.hidden) safeSaveAll();
  }, { capture: true });

  // bfcache-retur
  window.addEventListener('pageshow', function () {
    safeSaveAll();
    arm();
  });

  // Back/forward
  window.addEventListener('popstate', function () {
    showPtrBanner();
    // F√∂rs√∂k hoppa fram igen
    try { history.go(1); } catch (e) {}
    arm();
  });

  // Hash-bak√•t (t.ex. n√§r historiken annars hade l√§mnat sidan)
  window.addEventListener('hashchange', function () {
    if (!location.hash || !location.hash.startsWith(LOCK_PREFIX)) {
      safeSaveAll();
      showPtrBanner();
      arm();
    }
  });
})();
</script>
<!-- Back-overlay (visas n√§r anv√§ndaren f√∂rs√∂ker g√• bak√•t) -->
<style>
  
html, body { height: 100%; }
body { padding-bottom: 1px; }
#backGuardOverlay{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.92);
    color: #fff;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 999999;
    padding: 24px;
    text-align: center;
  }
  #backGuardOverlay .panel{
    max-width: 720px;
    width: 100%;
  }
  #backGuardOverlay .title{
    font-size: clamp(22px, 4vw, 34px);
    font-weight: 800;
    margin: 0 0 12px 0;
    line-height: 1.1;
  }
  #backGuardOverlay .msg{
    font-size: clamp(16px, 2.6vw, 22px);
    margin: 0 0 18px 0;
    line-height: 1.35;
  }
  #backGuardOverlay .hint{
    opacity: .9;
    font-size: clamp(14px, 2.2vw, 18px);
    margin: 0 0 22px 0;
    line-height: 1.35;
  }
  #backGuardOverlay .actions{
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }
  #backGuardOverlay button{
    appearance: none;
    border: 0;
    border-radius: 14px;
    padding: 14px 18px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
  }
  #backGuardOverlay .stay{
    background: #ffffff;
    color: #000000;
    min-width: 200px;
  }
  #backGuardOverlay .stay:active{ transform: scale(.99); }
  #backGuardOverlay .export{
    background: transparent;
    color: #ffffff;
    border: 2px solid #ffffff;
    min-width: 200px;
  }
  #backGuardOverlay .export:active{ transform: scale(.99); }
</style>
<div aria-labelledby="backGuardTitle" aria-modal="true" id="backGuardOverlay" role="dialog">
<div class="panel">
<h2 class="title" id="backGuardTitle">Du √§r p√• v√§g att g√• bak√•t</h2>
<p class="msg">Tryck inte p√• bak√•t-knappen ‚Äì d√• kan du f√∂rlora data.</p>
<p class="hint">Anv√§nd knapparna i sidan och <strong>Exportera</strong> f√∂r permanent backup.</p>
<div class="actions">
<button class="stay" id="backGuardStayBtn" type="button">Okej, jag stannar kvar</button>
<button class="export" id="backGuardExportBtn" type="button">Exportera nu</button>
</div>
</div>
</div>
<script>
(function () {
  // Visar pull-to-refresh-bannern (om den finns)
  function showPtrBanner() {
    const b = document.getElementById("ptrWarningBanner");
    if (!b) return;
    b.style.display = "flex";
    clearTimeout(b._hideTimer);
    b._hideTimer = setTimeout(() => { b.style.display = "none"; }, 3000);
  }

  // Visar v√•r stora svarta overlay
  const overlay = document.getElementById("backGuardOverlay");
  const stayBtn = document.getElementById("backGuardStayBtn");
  const exportBtn = document.getElementById("backGuardExportBtn");

  function showOverlay() {
    if (!overlay) return;
    overlay.style.display = "flex";
  }

  function hideOverlay() {
    if (!overlay) return;
    overlay.style.display = "none";
  }

  if (stayBtn) {
    stayBtn.addEventListener("click", function () {
      hideOverlay();
    });
  }

  if (exportBtn) {
    exportBtn.addEventListener("click", function () {
      // St√§ng overlayn s√• att nedladdningsdialogen syns tydligt
      hideOverlay();

      // Anropa befintlig export-funktion om den finns
      if (typeof autosaveExportTournament === "function") {
        autosaveExportTournament();
      } else if (typeof exportTournament === "function") {
        exportTournament();
      } else if (typeof exportData === "function") {
        exportData();
      } else {
        // Fallback: visa PTR-banner som p√•minnelse
        showPtrBanner();
        alert("Hittade ingen export-funktion i sidan. Kontrollera att Exportera-knappen finns i Verktyg.");
      }
    });
  }


  // F√∂rs√∂k att "h√•lla kvar" anv√§ndaren n√§r de trycker bak√•t, och visa tydlig varning.
  // OBS: vissa mobil-l√§gen kan fortfarande l√§mna sidan direkt, men d√• hj√§lper overlayn inte.
  function armBackGuard() {
    // L√§gg flera guard-steg, s√• snabb-dubbeltryck inte r√§cker.
    try {
      for (let i = 0; i < 8; i++) {
        history.pushState({ __backGuard: true, i }, "", location.href);
      }
    } catch (e) {}
  }

  armBackGuard();

  window.addEventListener("popstate", function () {
    // Visa b√•de overlay och PTR-banner (samma visuella signal som du redan har)
    showOverlay();
    showPtrBanner();

    // F√∂rs√∂k stanna kvar
    try { history.go(1); } catch (e) {}
    armBackGuard();
  });

  // Extra: vissa milj√∂er triggar hashchange snarare √§n popstate
  window.addEventListener("hashchange", function () {
    showOverlay();
    showPtrBanner();
    armBackGuard();
  });

  // Om sidan kommer tillbaka fr√•n bfcache, arma om
  window.addEventListener("pageshow", function (e) {
    if (e && e.persisted) {
      armBackGuard();
    }
  });
})();


// Auto-l√§gg till n√§r man v√§ljer i rullistan (Steg 5-justering)
function savedAutoAddFromSelect(kind){
  kind = (kind==="team") ? "team" : "single";
  var sel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
  if(!sel) return;
  var v = sel.value;
  if(v==null || v==="") return;
  try{
    // √Öteranv√§nd befintlig logik f√∂r snabb-l√§gg-till
    savedQuickAdd(kind);
  }finally{
    // √Öterst√§ll till placeholder s√• man tydligt kan v√§lja igen
    try{ sel.value=""; }catch(e){}
  }
}

// ===== Steg 3: Multi-v√§ljare f√∂r sparade spelare (s√• rullistan inte st√§nger mellan val) =====
var __multiPickState = { open:false, kind:"single" };

function openSavedMultiPicker(kind){
  try{
    kind = (kind==="team") ? "team" : "single";
    __multiPickState.open = true;
    __multiPickState.kind = kind;

    var overlay = document.getElementById("overlayMultiPick");
    var listEl  = document.getElementById("multiPickList");
    if(!overlay || !listEl) return;

    var sel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    if(!sel){
      toast("Hittar inte rullistan.");
      return;
    }

    // Bygg lista fr√•n befintliga <option> (exkl. tom/disabled)
    listEl.innerHTML = "";
    var any = false;
    for(var i=0;i<sel.options.length;i++){
      var o = sel.options[i];
      if(!o) continue;
      var id = (o.value||"").trim();
      if(!id) continue;
      if(o.disabled) continue;

      any = true;
      var row = document.createElement("label");
      row.className = "multiPickItem";

      var cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = id;

      var textWrap = document.createElement("div");
      var nm = document.createElement("div");
      nm.className = "name";
      nm.textContent = o.textContent || id;
      textWrap.appendChild(nm);

      row.appendChild(cb);
      row.appendChild(textWrap);
      listEl.appendChild(row);
    }
    if(!any){
      var empty = document.createElement("div");
      empty.className = "small muted";
      empty.textContent = "Inga sparade spelare √§n. L√§gg till en via Ny / √Ñndra.";
      listEl.appendChild(empty);
    }

    overlay.classList.remove("hidden");
    document.body.classList.add("modal-open");
  }catch(e){
    console.error(e);
  }
}

function closeSavedMultiPicker(apply){
  try{
    var overlay = document.getElementById("overlayMultiPick");
    if(!overlay) return;
    if(apply) applySavedMultiPicker();
    overlay.classList.add("hidden");
    document.body.classList.remove("modal-open");
    __multiPickState.open = false;
  }catch(e){
    console.error(e);
  }
}

function applySavedMultiPicker(){
  try{
    var kind = (__multiPickState && __multiPickState.kind==="team") ? "team" : "single";
    var listEl = document.getElementById("multiPickList");
    if(!listEl) return;
    var checks = listEl.querySelectorAll('input[type="checkbox"]');
    var ids = [];
    checks.forEach(function(cb){ if(cb && cb.checked && cb.value) ids.push(cb.value); });
    if(!ids.length) return;

    var sel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    if(!sel) return;

    // L√§gg till en i taget men utan att anv√§ndaren beh√∂ver √∂ppna listan igen
    ids.forEach(function(id){
      try{
        sel.value = id;
      }catch(e){}
      try{
        savedQuickAdd(kind);
      }catch(e){
        console.error(e);
      }
    });
    try{ sel.value = ""; }catch(e){}
  }catch(e){
    console.error(e);
  }
}

// ===== Steg 5: Modal / popup f√∂r Ny spelare =====
var __newPlayerModalState = { open:false, kind:null, movedEl:null, placeholder:null, prevHidden:null };

function refreshNewPlayerModalSelect(kindOverride){
  try{
    var kind = (kindOverride==="team") ? "team" : "single";
    if(!kindOverride){
      try{ kind = (__newPlayerModalState && __newPlayerModalState.kind==="team") ? "team" : "single"; }catch(e){}
    }
    var modalSel = document.getElementById(kind==="team" ? "modalSavedTeamSelect" : "modalSavedPlayerSelect");
    var mainSel  = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    if(!modalSel || !mainSel) return;

    // Klona alternativen fr√•n huvudrullistan
    modalSel.innerHTML = "";
    for(var i=0;i<mainSel.options.length;i++){
      var o = mainSel.options[i];
      if(!o) continue;
      var c = document.createElement("option");
      c.value = o.value;
      c.textContent = o.textContent;
      if(o.disabled) c.disabled = true;
      modalSel.appendChild(c);
    }
    try{ modalSel.value = ""; }catch(e){}
  }catch(e){}
}



function selectModalSavedByName(kind, name){
  try{
    kind = (kind==="team") ? "team" : "single";
    name = (name||"").trim();
    if(!name) return;
    var sel = document.getElementById(kind==="team" ? "modalSavedTeamSelect" : "modalSavedPlayerSelect");
    if(!sel) return;
    // f√∂rs√∂k matcha mot option-text (namn)
    var targetVal = null;
    for(var i=0;i<sel.options.length;i++){
      var o = sel.options[i];
      if(!o) continue;
      if(((o.textContent||"").trim().toLowerCase()) === name.toLowerCase()){
        targetVal = o.value;
        break;
      }
    }
    if(targetVal!=null){ sel.value = targetVal; }
  }catch(e){}
}
function openNewPlayerModal(kind){
  kind = (kind==="team") ? "team" : "single";
  var overlay = document.getElementById("newPlayerModal");
  var body = document.getElementById("newPlayerModalBody");
  var title = document.getElementById("newPlayerModalTitle");
  if(!overlay || !body) return;

  // Flytta r√§tt formul√§r in i modalen (utan att duplicera ID:n)
  var formId = (kind==="team") ? "kioskTeamFields" : "kioskSingleFields";
  var formEl = document.getElementById(formId);
  if(!formEl) return;

  // L√§gg en placeholder d√§r formul√§ret stod s√• vi kan stoppa tillbaka det exakt
  var ph = document.createComment("modal-placeholder");
  formEl.parentNode.insertBefore(ph, formEl);

  // Om formul√§ret r√•kar vara dolt (t.ex. lag-formen), visa det i modalen
  var prevHidden = formEl.classList.contains("hidden");
  if(prevHidden) formEl.classList.remove("hidden");

  // S√§tt modalrubrik
  title.textContent = (kind==="team") ? "Ny / √Ñndra lag" : "Ny / √Ñndra spelare";

  
  // F√∂r nya profiler: skapa ett tempor√§rt ID direkt s√• att profilbild kan kopplas innan "Spara"
  try{
    if(kind==="team"){ if(!savedEditingTeamId) savedEditingTeamId = cryptoId(); }
    else{ if(!savedEditingPlayerId) savedEditingPlayerId = cryptoId(); }
    // √§ven om savedEditing* nollst√§lls vid Spara vill vi ha ett stabilt id f√∂r avatar
    window.__modalAvatarPid[kind] = (kind==="team" ? savedEditingTeamId : savedEditingPlayerId) || window.__modalAvatarPid[kind] || null;
  }catch(e){}

  // Profilbild-rad i modalen (v√§lj/√§ndra bild)
  var avatarRow = document.createElement("div");
  avatarRow.className = "row";
  avatarRow.style.cssText = "justify-content:flex-start;align-items:center;gap:12px;margin:8px 0 10px 0";
  var avatarBtn = document.createElement("button");
  avatarBtn.type = "button";
  avatarBtn.className = "avatarBtn";
  avatarBtn.id = (kind==="team") ? "modalAvatarBtnTeam" : "modalAvatarBtnSingle";
  avatarRow.id = (kind==="team") ? "modalAvatarRowTeam" : "modalAvatarRowSingle";
  // Koppla avatar till ett stabilt id i modalen
  var _pidInit = (kind==="team" ? (savedEditingTeamId||"") : (savedEditingPlayerId||""));
  try{ window.__modalAvatarPid[kind] = _pidInit || window.__modalAvatarPid[kind] || null; }catch(e){}
  avatarBtn.setAttribute("data-avatar-pid", (window.__modalAvatarPid[kind]||""));
  avatarBtn.setAttribute("data-avatar-name", "");
  avatarBtn.innerHTML = "<span></span><img alt='' style='display:none'>";
  var avatarTxt = document.createElement("div");
  avatarTxt.innerHTML = "<div style='font-weight:800'>Profilbild</div><div class='small'>Tryck p√• avataren f√∂r att v√§lja/√§ndra bild</div>";
  avatarRow.appendChild(avatarBtn);
  avatarRow.appendChild(avatarTxt);
  avatarBtn.addEventListener("click", function(){
    try{
      var nm = (kind==="team" ? (document.getElementById("kTeamName") ? document.getElementById("kTeamName").value : "") : (document.getElementById("kName") ? document.getElementById("kName").value : ""));
      nm = (nm||"").trim();
      var pid = null;
      try{ pid = window.__modalAvatarPid[kind] || (kind==="team" ? savedEditingTeamId : savedEditingPlayerId) || null; }catch(e){}
      // Om vi saknar id (t.ex. helt ny modal), skapa ett direkt s√• avatar kan kopplas innan Spara
      if(!pid){
        try{ pid = cryptoId(); }catch(e){ pid = ("p_"+Date.now()+"_"+Math.random().toString(16).slice(2)); }
        try{ if(kind==="team") savedEditingTeamId = pid; else savedEditingPlayerId = pid; }catch(e){}
        try{ window.__modalAvatarPid[kind] = pid; }catch(e){}
      }
      // S√§tt namn s√• initialer/canvas f√•r r√§tt
      try{ avatarBtn.setAttribute("data-avatar-pid", pid||""); avatarBtn.setAttribute("data-avatar-name", nm||""); }catch(e){}
      openAvatarModal(pid, nm || (kind==="team" ? "Lag" : "Spelare"));
      // Efter ev. spar: uppdatera direkt
      setTimeout(function(){ try{ hydrateAvatarsIn(avatarRow); }catch(e){} }, 50);
    }catch(e){}
  });
// Flytta in i modalen
  body.innerHTML = "";

  try{ body.appendChild(avatarRow); }catch(e){}
// Rullista + ladda (f√∂r att redigera en vald sparad profil) i modalen
var loadRow = document.createElement("div");
loadRow.style.cssText = "display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:0 0 10px 0;position:relative;z-index:4;pointer-events:auto";

var modalSel = document.createElement("select");
modalSel.id = (kind==="team") ? "modalSavedTeamSelect" : "modalSavedPlayerSelect";
modalSel.style.cssText = "flex:1;min-width:220px";
loadRow.appendChild(modalSel);

var btnLoad = document.createElement("button");
btnLoad.className = "btn secondary";
btnLoad.type = "button";
btnLoad.textContent = "Ladda";
btnLoad.addEventListener("click", function(){
  try{
    var v = modalSel.value || "";
    if(!v){ alert("V√§lj en profil att ladda."); return; }
    // √Öteranv√§nd befintlig logik: s√§tt tillf√§lligt huvudrullistan och k√∂r savedLoad()
    var mainSel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    var prev = mainSel ? mainSel.value : "";
    if(mainSel) mainSel.value = v;
    try{ savedLoad(kind); }catch(e){}
    // Uppdatera profilbild-koppling efter laddning
    try{
      var pid2 = (kind==="team" ? savedEditingTeamId : savedEditingPlayerId);
      try{ window.__modalAvatarPid[kind] = pid2 || window.__modalAvatarPid[kind] || null; }catch(e){}
      var nm2 = (kind==="team" ? (document.getElementById("kTeamName")?document.getElementById("kTeamName").value:"") : (document.getElementById("kName")?document.getElementById("kName").value:""));
      nm2=(nm2||"").trim();
      avatarBtn.setAttribute("data-avatar-pid", pid2 || "");
      avatarBtn.setAttribute("data-avatar-name", nm2);
      var spn2 = avatarBtn.querySelector("span"); if(spn2) spn2.textContent = _avatarInitials(nm2||"") || "?";
      hydrateAvatarsIn(avatarRow);
    }catch(e){}
    if(mainSel) mainSel.value = prev;
  }catch(e){}
});
loadRow.appendChild(btnLoad);

// === Import/Export profil (i samma rad som "Ladda") ===
var btnDlProfile = document.createElement("button");
btnDlProfile.className = "btn secondary";
btnDlProfile.type = "button";
btnDlProfile.textContent = "Ladda ner profil";
btnDlProfile.style.cssText = "position:relative;z-index:5;pointer-events:auto";

var btnUlProfile = document.createElement("button");
btnUlProfile.className = "btn secondary";
btnUlProfile.type = "button";
btnUlProfile.textContent = "Ladda upp profil";
btnUlProfile.style.cssText = "position:relative;z-index:5;pointer-events:auto";

// dold filv√§ljare f√∂r import
var ulInput = document.createElement("input");
ulInput.type = "file";
ulInput.accept = "application/json";
ulInput.style.display = "none";
ulInput.id = (kind==="team") ? "modalProfileUploadTeam" : "modalProfileUploadSingle";

loadRow.appendChild(btnDlProfile);
loadRow.appendChild(btnUlProfile);
loadRow.appendChild(ulInput);

// Hj√§lpare: dataURL -> Blob
function __dataURLToBlob(dataURL){
  try{
    var parts = String(dataURL).split(",");
    if(parts.length < 2) return null;
    var mime = (parts[0].match(/data:([^;]+)/)||[])[1] || "application/octet-stream";
    var bstr = atob(parts[1]);
    var n = bstr.length;
    var u8 = new Uint8Array(n);
    for(var i=0;i<n;i++) u8[i] = bstr.charCodeAt(i);
    return new Blob([u8], {type:mime});
  }catch(e){ return null; }
}

// Hj√§lpare: h√§mta "aktuellt" id f√∂r profilen i modalen (skapa vid behov)
function __ensureModalPid(){
  var pid = null;
  try{ pid = window.__modalAvatarPid[kind] || (kind==="team" ? savedEditingTeamId : savedEditingPlayerId) || null; }catch(e){}
  if(!pid){
    try{ pid = cryptoId(); }catch(e){ pid = ("p_"+Date.now()+"_"+Math.random().toString(16).slice(2)); }
    try{ if(kind==="team") savedEditingTeamId = pid; else savedEditingPlayerId = pid; }catch(e){}
    try{ window.__modalAvatarPid[kind] = pid; }catch(e){}
    try{
      var ab = document.getElementById(kind==="team" ? "modalAvatarBtnTeam" : "modalAvatarBtnSingle");
      if(ab) ab.setAttribute("data-avatar-pid", pid);
    }catch(e){}
  }
  return pid;
}

function __getModalFieldValues(){
  var nmEl = document.getElementById(kind==="team" ? "kTeamName" : "kName");
  var spEl = document.getElementById(kind==="team" ? "kTeamSpotify" : "kSpotify");
  // OBS: team-formen kan anv√§nda samma id f√∂r spotify/darts beroende p√• version; fall tillbaka.
  if(!spEl) spEl = document.getElementById(kind==="team" ? "kSpotifyTeam" : "kSpotify");
  var dartsEl = document.getElementById(kind==="team" ? "kTeamDarts" : "kDarts");

  return {
    name: (nmEl ? nmEl.value : "") || "",
    spotifyUrl: (spEl ? spEl.value : "") || "",
    darts: (dartsEl ? dartsEl.value : "") || ""
  };
}

function __setModalFieldValues(p){
  var nmEl = document.getElementById(kind==="team" ? "kTeamName" : "kName");
  var spEl = document.getElementById(kind==="team" ? "kTeamSpotify" : "kSpotify");
  if(!spEl) spEl = document.getElementById(kind==="team" ? "kSpotifyTeam" : "kSpotify");
  var dartsEl = document.getElementById(kind==="team" ? "kTeamDarts" : "kDarts");

  if(nmEl) nmEl.value = (p.name||"");
  if(spEl) spEl.value = (p.spotifyUrl||"");
  if(dartsEl) dartsEl.value = (p.darts||"");
}

function __isEmptyModalProfile(){
  var v = __getModalFieldValues();
  return !(String(v.name).trim() || String(v.spotifyUrl).trim() || String(v.darts).trim());
}

async function __downloadJSON(obj, filename){
  filename = filename || "profil.profil.json";
  try{
    var json = JSON.stringify(obj, null, 2);

    // 1) File System Access API (b√§st p√• Chromium/Android om tillg√§ngligt)
    try{
      if(window.showSaveFilePicker){
        const handle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(new Blob([json], {type:"application/json"}));
        await writable.close();
        try{ if(typeof toast==="function") toast("Profil sparad."); }catch(e){}
        return;
      }
    }catch(e){ /* fallthrough */ }

    var blob = new Blob([json], {type:"application/json"});

    // 2) Web Share API (mobil "Spara i filer"/Dela)
    try{
      if(navigator && navigator.canShare){
        var f = new File([blob], filename, {type:"application/json"});
        if(navigator.canShare({files:[f]})){
          await navigator.share({files:[f], title:"Profil", text:"Profil-export"});
          try{ if(typeof toast==="function") toast("Profil delad/sparad."); }catch(e){}
          return;
        }
      }
    }catch(e){ /* fallthrough */ }

    // 3) Klassisk nedladdning via <a download>
    try{
      var url = URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.rel = "noopener";
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        try{ document.body.removeChild(a); }catch(e){}
        try{ URL.revokeObjectURL(url); }catch(e){}
      }, 1200);
      try{ if(typeof toast==="function") toast("F√∂rs√∂ker ladda ner profil..."); }catch(e){}
      return;
    }catch(e){ /* fallthrough */ }

    // 4) Sista fallback: visa JSON i en liten ruta + Kopiera
    try{
      __showExportFallback(json, filename);
    }catch(e){
      alert("Kunde inte exportera profilen.");
    }
  }catch(e){
    alert("Kunde inte skapa fil.");
  }
}

// Fallback UI: visar JSON + kopiera-knapp (om nedladdning blockeras i webview/content://)
function __showExportFallback(json, filename){
  // √•teranv√§nd befintlig newPlayerModal om m√∂jligt
  var overlay = document.getElementById("newPlayerModal");
  var host = overlay ? overlay.querySelector(".modalCard") : null;

  var wrap = document.createElement("div");
  wrap.style.cssText = "margin-top:10px;padding:12px;border:1px solid #e5e7eb;border-radius:12px;background:#fff";
  wrap.innerHTML =
    "<div style='display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap'>" +
      "<div style='font-weight:900'>Export (fallback)</div>" +
      "<button class='btn secondary' type='button' id='__expClose'>St√§ng</button>" +
    "</div>" +
    "<div class='small' style='margin-top:6px'>Din webbl√§sare blockerar nedladdning. Kopiera JSON-texten nedan och spara som <b>"+filename+"</b>.</div>" +
    "<textarea id='__expTa' style='width:100%;margin-top:8px;min-height:160px;border:1px solid #e5e7eb;border-radius:12px;padding:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;font-size:12px;'></textarea>" +
    "<div style='display:flex;gap:10px;flex-wrap:wrap;margin-top:10px'>" +
      "<button class='btn secondary' type='button' id='__expCopy'>Kopiera</button>" +
      "<button class='btn secondary' type='button' id='__expOpenTab'>√ñppna i ny flik</button>" +
    "</div>";

  var parent = host || document.body;
  parent.appendChild(wrap);

  wrap.querySelector("#__expTa").value = json;

  wrap.querySelector("#__expClose").onclick = function(){ try{ parent.removeChild(wrap);}catch(e){} };

  wrap.querySelector("#__expCopy").onclick = async function(){
    try{
      await navigator.clipboard.writeText(json);
      try{ if(typeof toast==="function") toast("Kopierat!"); }catch(e){}
    }catch(e){
      // fallback: select + execCommand
      var ta = wrap.querySelector("#__expTa");
      ta.focus(); ta.select();
      try{ document.execCommand("copy"); }catch(e2){}
      try{ if(typeof toast==="function") toast("Kopierat!"); }catch(e3){}
    }
  };

  wrap.querySelector("#__expOpenTab").onclick = function(){
    try{
      var dataUrl = "data:application/json;charset=utf-8," + encodeURIComponent(json);
      window.open(dataUrl, "_blank");
    }catch(e){}
  };
}

btnDlProfile.addEventListener("click", async function(ev){
  try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){}

  try{
    var v = __getModalFieldValues();
    var pid = __ensureModalPid();

    // F√∂r "ny" profil utan namn: till√•t export √§nd√• men ge standardnamn
    var safeName = (String(v.name||"profil").trim() || "profil")
      .toLowerCase().replace(/\s+/g,"-").replace(/[^a-z0-9\-√•√§√∂]/gi,"");

    var avatarData = null;
    try{
      if(typeof getAvatarDataURL === "function"){
        avatarData = await getAvatarDataURL(pid);
      }
    }catch(e){ avatarData = null; }

    var payload = {
      version: 1,
      kind: kind,
      profile: {
        id: pid,
        name: v.name || "",
        spotifyUrl: v.spotifyUrl || "",
        darts: v.darts || "",
        avatar: avatarData ? { type:"dataUrl", data: avatarData } : null
      }
    };

    await __downloadJSON(payload, (safeName||"profil") + ".profil.json");
    try{ if(typeof toast==="function") toast("Profil nedladdad."); }catch(e){}
  }catch(e){
    alert("Kunde inte ladda ner profilen.");
  }
});

btnUlProfile.addEventListener("click", function(ev){
  try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){}

  try{
    // Enligt √∂nskem√•l: n√§r allt √§r tomt ska man kunna ladda upp och fylla f√§lt.
    // Om det redan finns data, fr√•ga om man vill skriva √∂ver.
    if(!__isEmptyModalProfile()){
      var ok = confirm("F√§lten √§r inte tomma. Vill du skriva √∂ver med en uppladdad profil?");
      if(!ok) return;
    }
    ulInput.value = "";
    ulInput.click();
  }catch(e){}
});

ulInput.addEventListener("change", async function(ev){
  try{ ev.stopPropagation(); }catch(e){}

  var file = ulInput.files && ulInput.files[0];
  if(!file) return;
  try{
    var txt = await file.text();
    var data = JSON.parse(txt);

    // Grundvalidering
    if(!data || data.version !== 1 || !data.profile){
      alert("Fel format p√• profilfilen.");
      return;
    }
    if(data.kind && data.kind !== kind){
      alert("Profilen √§r av typen \"" + data.kind + "\" men modalen √§r \"" + kind + "\".");
      return;
    }

    var p = data.profile || {};
    if(typeof p.name !== "string"){
      alert("Profilen saknar giltigt namn.");
      return;
    }

    // S√§tt f√§lt
    __setModalFieldValues({
      name: p.name || "",
      spotifyUrl: p.spotifyUrl || "",
      darts: p.darts || ""
    });

    // === PID-strategi ===
    // - Om modalen √§r "tom" (ny profil) och filen har ett id: anv√§nd filens id s√• att avatar f√∂ljer med exakt mellan enheter.
    // - Om modalen redan har ett id (t.ex. du redigerar en sparad profil): beh√•ll det och importera avatar till det id:t.
    var currentPid = null;
    try{ currentPid = window.__modalAvatarPid[kind] || (kind==="team" ? savedEditingTeamId : savedEditingPlayerId) || null; }catch(e){}
    var filePid = (p.id!=null ? String(p.id) : "");
    filePid = filePid.trim();

    if(!currentPid && filePid){
      // adoptera filens id
      currentPid = filePid;
      try{
        if(kind==="team") savedEditingTeamId = currentPid;
        else savedEditingPlayerId = currentPid;
      }catch(e){}
      try{ window.__modalAvatarPid[kind] = currentPid; }catch(e){}
      try{
        var ab = document.getElementById(kind==="team" ? "modalAvatarBtnTeam" : "modalAvatarBtnSingle");
        if(ab) ab.setAttribute("data-avatar-pid", currentPid);
      }catch(e){}
    }

    // s√§kerst√§ll att vi alltid har ett pid
    var pid = __ensureModalPid();

    // Importera profilbild om den finns
    if(p.avatar && p.avatar.type === "dataUrl" && typeof p.avatar.data === "string" && p.avatar.data.startsWith("data:")){
      var blob = __dataURLToBlob(p.avatar.data);
      if(blob && typeof _idbPut === "function"){
        try{
          await _idbPut(pid, { blob: blob, updatedAt: Date.now(), source: "profile-import" });
          try{ avatarCache[pid] = p.avatar.data; }catch(e){}
        }catch(e){}
      }
    }

    // Uppdatera avatar-rendering i modalen
    try{
      var scope = document.getElementById("newPlayerModal") || document;
      if(typeof hydrateAvatarsIn === "function") hydrateAvatarsIn(scope);
    }catch(e){}

    try{ if(typeof toast==="function") toast("Profil inl√§st. Tryck Spara."); }catch(e){}
  }catch(e){
    alert("Kunde inte l√§sa profilfilen.");
  }
});


// Export-knappen: till√•t export √§ven om endast avatar finns (eller om allt √§r tomt)
try{
  btnDlProfile.disabled = false;
}catch(e){}
// Flytta "Ta bort vald profil" in i modalen (b√§ttre plats f√∂r profil-hantering)
try{
  var delId = (kind==="team") ? "btnDeleteTeamTop" : "btnDeleteProfileTop";
  var delBtn = document.getElementById(delId);
  if(delBtn){
    // spara platsen d√§r knappen stod s√• vi kan stoppa tillbaka den vid st√§ngning
    var delPh = document.createComment("modal-delete-placeholder");
    delBtn.parentNode.insertBefore(delPh, delBtn);
    loadRow.appendChild(delBtn);
    // se till att knappen anv√§nder modalens val (inte gamla)
    delBtn.onclick = function(){
      try{
        var v = modalSel.value || "";
        if(!v){ alert("V√§lj en profil att ta bort."); return; }
        var mainSel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
        var prev = mainSel ? mainSel.value : "";
        if(mainSel) mainSel.value = v;
        try{ savedDelete(kind); }catch(e){}
        if(mainSel) mainSel.value = prev;
        // uppdatera direkt s√• listan i modalen st√§mmer
        try{ refreshNewPlayerModalSelect(kind); }catch(e){}
      }catch(e){}
    };
    // spara placeholder i state
    __newPlayerModalState_deletePlaceholder = delPh;
  }
}catch(e){}

body.appendChild(loadRow);

// Fyll modalens rullista med aktuella sparade profiler
try{ refreshNewPlayerModalSelect(kind); }catch(e){} body.appendChild(formEl);

  // Rensa f√§lt f√∂r ny inmatning (utan att f√∂rst√∂ra saved-l√§get i √∂vrigt)
  try{
    if(kind==="team"){
      document.getElementById("kTeamName").value = "";
      document.getElementById("kTeamP1").value = "";
      document.getElementById("kTeamP2").value = "";
      document.getElementById("kTeamSpotify").value = "";
      document.getElementById("kTeamDarts").value = "";
      savedEditingTeamOriginalName = null;
try{ document.getElementById("kTeamName").focus(); }catch(e){}
    }else{
      savedEditingPlayerId = null;
      savedEditingPlayerOriginalName = null;
      document.getElementById("kName").value = "";
      document.getElementById("kSpotify").value = "";
      document.getElementById("kDarts").value = "";
try{ document.getElementById("kName").focus(); }catch(e){}
    }
  try{
    var nm0 = (kind==="team" ? (document.getElementById("kTeamName")?document.getElementById("kTeamName").value:"") : (document.getElementById("kName")?document.getElementById("kName").value:""));
    nm0 = (nm0||"").trim();
    avatarBtn.setAttribute("data-avatar-name", nm0);
    var spn = avatarBtn.querySelector("span"); if(spn) spn.textContent = _avatarInitials(nm0||"") || "?";
    hydrateAvatarsIn(avatarRow);
  }catch(e){}
}catch(e){}

  // Visa
  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden","false");

  __newPlayerModalState = { open:true, kind:kind, movedEl:formEl, placeholder:ph, prevHidden:prevHidden };

  // Klick utanf√∂r st√§nger
  overlay.onclick = function(ev){
    if(ev.target === overlay){ closeNewPlayerModal(); }
  };
}

function openEditPlayerModal(kind){
  kind = (kind==="team") ? "team" : "single";
  var overlay = document.getElementById("newPlayerModal");
  var body = document.getElementById("newPlayerModalBody");
  var title = document.getElementById("newPlayerModalTitle");
  if(!overlay || !body) return;

  var formId = (kind==="team") ? "kioskTeamFields" : "kioskSingleFields";
  var formEl = document.getElementById(formId);
  if(!formEl) return;

  var ph = document.createComment("modal-placeholder");
  formEl.parentNode.insertBefore(ph, formEl);

  var prevHidden = formEl.classList.contains("hidden");
  if(prevHidden) formEl.classList.remove("hidden");

  title.textContent = (kind==="team") ? "Redigera lag" : "Redigera spelare";

  body.innerHTML = "";
  body.appendChild(formEl);

  // Fokusera ett rimligt f√§lt, men rensa inte (det √§r "Ladda"-l√§get)
  try{
    if(kind==="team"){
      try{ document.getElementById("kTeamName").focus(); }catch(e){}
    }else{
      try{ document.getElementById("kName").focus(); }catch(e){}
    }
  }catch(e){}

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden","false");

  __newPlayerModalState = { open:true, kind:kind, movedEl:formEl, placeholder:ph, prevHidden:prevHidden };

  overlay.onclick = function(ev){
    if(ev.target === overlay){ closeNewPlayerModal(); }
  };
  document.onkeydown = function(ev){
    if(ev.key === "Escape"){ closeNewPlayerModal(); }
  };
}

function closeNewPlayerModal(){
  var overlay = document.getElementById("newPlayerModal");
  if(!overlay) return;
  if(!__newPlayerModalState.open) { overlay.classList.add("hidden"); overlay.setAttribute("aria-hidden","true"); return; }

  var formEl = __newPlayerModalState.movedEl;
  var ph = __newPlayerModalState.placeholder;

  try{
    if(ph && ph.parentNode && formEl){
      ph.parentNode.insertBefore(formEl, ph);
      ph.parentNode.removeChild(ph);
    }
    if(formEl && __newPlayerModalState.prevHidden){
      formEl.classList.add("hidden");
    }

  // Parkera "Ta bort vald profil"-knappen utanf√∂r vyn (den ska bara synas i modalen)
  try{
    var delPh = (typeof __newPlayerModalState_deletePlaceholder!=="undefined") ? __newPlayerModalState_deletePlaceholder : null;
    if(delPh){
      var delBtn1 = document.getElementById("btnDeleteProfileTop");
      var delBtn2 = document.getElementById("btnDeleteTeamTop");
      var parking = document.getElementById("modalButtonParking");
      if(parking){
        if(delBtn1) parking.appendChild(delBtn1);
        if(delBtn2) parking.appendChild(delBtn2);
      }
      if(delPh.parentNode){ delPh.parentNode.removeChild(delPh); }
    }
    __newPlayerModalState_deletePlaceholder = null;
  }catch(e){}
  }catch(e){}

  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden","true");
  __newPlayerModalState = { open:false, kind:null, movedEl:null, placeholder:null, prevHidden:null };
}

// Wrapper: spara profil och st√§ng popupen om det lyckas
function modalSavedSaveNewFromForm(kind){
  try{
    var ok = savedSaveNewFromForm(kind);
    if(ok){ closeNewPlayerModal(); }
  }catch(e){}
}

// Wrapper: l√§gg till spelare/lag och st√§ng popupen om det lyckas
function modalKioskAddSingle(){
  try{
    var nm = (document.getElementById('kName') ? (document.getElementById('kName').value||'').trim() : '');

    // Om vi har laddat en sparad profil i modalen: uppdatera profilen ist√§llet f√∂r att f√∂rs√∂ka l√§gga till igen
    if(savedEditingPlayerId){
      var oldNm = savedEditingPlayerOriginalName || nm;
      var sp = (document.getElementById('kSpotify') ? (document.getElementById('kSpotify').value||'').trim() : '');
      var da = (document.getElementById('kDarts') ? (document.getElementById('kDarts').value||'').trim() : '');
      var okU = savedUpsertFromForm('single');
      if(okU){
        // Uppdatera ev. redan tillagda rader
        try{ _updateAddedSingleLines(oldNm, nm, sp, da); }catch(e){}
        savedEditingPlayerOriginalName = nm;
        // Synka modalens dropdown och avatar-koppling
        try{ refreshNewPlayerModalSelect(); }catch(e){}
        try{ selectModalSavedByName('single', nm); }catch(e){}
        try{
          window.__modalAvatarPid.single = savedEditingPlayerId;
          var btn = document.getElementById('modalAvatarBtnSingle');
          if(btn){ btn.setAttribute('data-avatar-pid', savedEditingPlayerId||''); btn.setAttribute('data-avatar-name', nm||''); hydrateAvatarsIn(btn); }
        }catch(e){}
        // St√§ng modalen n√§r uppdateringen lyckas
        try{ closeNewPlayerModal(); }catch(e){}
      }
      return;
    }

    // Annars: normalfl√∂de = spara + l√§gg till i turneringen
    var ok = kioskAddSingle();
    if(ok){
      try{ refreshNewPlayerModalSelect(); }catch(e){}
      try{ selectModalSavedByName('single', nm); }catch(e){}
      try{
        var pidSaved = (typeof findSavedPlayerIdByName==="function") ? findSavedPlayerIdByName(nm, "single") : null;
        if(pidSaved){ window.__modalAvatarPid.single = pidSaved; }
        var btn = document.getElementById("modalAvatarBtnSingle");
        if(btn){
          btn.setAttribute("data-avatar-pid", (window.__modalAvatarPid.single||""));
          btn.setAttribute("data-avatar-name", nm||"");
          try{ hydrateAvatarsIn(btn); }catch(e){}
        }
      }catch(e){}
    }
  }catch(e){}
}
function modalKioskAddTeam(){
  try{
    var nm = (document.getElementById('kTeamName') ? (document.getElementById('kTeamName').value||'').trim() : '');

    // Uppdateringsl√§ge f√∂r lag (laddad profil)
    if(savedEditingTeamId){
      var oldNm = savedEditingTeamOriginalName || nm;
      var p1 = (document.getElementById('kTeamP1') ? (document.getElementById('kTeamP1').value||'').trim() : '');
      var p2 = (document.getElementById('kTeamP2') ? (document.getElementById('kTeamP2').value||'').trim() : '');
      var sp = (document.getElementById('kTeamSpotify') ? (document.getElementById('kTeamSpotify').value||'').trim() : '');
      var da = (document.getElementById('kTeamDarts') ? (document.getElementById('kTeamDarts').value||'').trim() : '');
      var okU = savedUpsertFromForm('team');
      if(okU){
        try{ _updateAddedTeamLines(oldNm, nm, p1, p2, sp, da); }catch(e){}
        savedEditingTeamOriginalName = nm;
        try{ refreshNewPlayerModalSelect(); }catch(e){}
        try{ selectModalSavedByName('team', nm); }catch(e){}
        try{
          window.__modalAvatarPid.team = savedEditingTeamId;
          var btn = document.getElementById('modalAvatarBtnTeam');
          if(btn){ btn.setAttribute('data-avatar-pid', savedEditingTeamId||''); btn.setAttribute('data-avatar-name', nm||''); hydrateAvatarsIn(btn); }
        }catch(e){}
        try{ closeNewPlayerModal(); }catch(e){}
      }
      return;
    }

    var ok = kioskAddTeam();
    if(ok){
      try{ refreshNewPlayerModalSelect(); }catch(e){}
      try{ selectModalSavedByName('team', nm); }catch(e){}
      try{
        var pidSaved = (typeof findSavedPlayerIdByName==="function") ? findSavedPlayerIdByName(nm, "team") : null;
        if(pidSaved){ window.__modalAvatarPid.team = pidSaved; }
        var btn = document.getElementById("modalAvatarBtnTeam");
        if(btn){
          btn.setAttribute("data-avatar-pid", (window.__modalAvatarPid.team||""));
          btn.setAttribute("data-avatar-name", nm||"");
          try{ hydrateAvatarsIn(btn); }catch(e){}
        }
      }catch(e){}
    }
  }catch(e){}
}


// Se till att "Ta bort vald profil" inte ligger i huvudvyn (den hanteras i modalen)
document.addEventListener("DOMContentLoaded", function(){
  try{
    var parking = document.getElementById("modalButtonParking");
    if(!parking) return;
    var b1 = document.getElementById("btnDeleteProfileTop");
    var b2 = document.getElementById("btnDeleteTeamTop");
    if(b1) parking.appendChild(b1);
    if(b2) parking.appendChild(b2);
  }catch(e){}
});

// Fallback: enkel toast om den inte redan finns
if(typeof window.toast !== "function"){
  window.toast = function(msg){
    try{
      var el = document.getElementById("___toast");
      if(!el){
        el = document.createElement("div");
        el.id = "___toast";
        el.style.position = "fixed";
        el.style.left = "50%";
        el.style.bottom = "18px";
        el.style.transform = "translateX(-50%)";
        el.style.background = "rgba(17,24,39,0.92)";
        el.style.color = "#fff";
        el.style.padding = "10px 12px";
        el.style.borderRadius = "12px";
        el.style.fontSize = "14px";
        el.style.zIndex = "999999";
        el.style.maxWidth = "92vw";
        el.style.textAlign = "center";
        el.style.boxShadow = "0 10px 30px rgba(0,0,0,0.25)";
        el.style.opacity = "0";
        el.style.pointerEvents = "none";
        document.body.appendChild(el);
      }
      el.textContent = msg;
      el.style.transition = "opacity 120ms ease";
      el.style.opacity = "1";
      clearTimeout(window.___toastT);
      window.___toastT = setTimeout(function(){ el.style.opacity = "0"; }, 1600);
    }catch(e){
      alert(msg);
    }
  };
}


// ---- Avatars (profilbilder): IndexedDB store 'avatars' keyed by playerId ----
const AVATAR_DB_NAME = "dart_avatars_db_v1";
const AVATAR_STORE = "avatars";
const avatarCache = {}; // playerId -> dataURL

let __avatar = {
  open:false,
  playerId:null,
  playerName:"",
  img:null,
  zoom:1,
  offsetX:0,
  offsetY:0,
  dragging:false,
  dragStartX:0,
  dragStartY:0,
  baseOffsetX:0,
  baseOffsetY:0
};
// H√•ller koll p√• vilket playerId som avatar-modalen ska kopplas till i "Ny / √Ñndra"-modalen.
// Viktigt: savedEditingPlayerId nollst√§lls efter Spara, s√• vi beh√∂ver en separat k√§lla f√∂r avatar-kopplingen.
window.__modalAvatarPid = window.__modalAvatarPid || { single:null, team:null };


function avatarOverlayClick(e){
  // st√§ng vid klick utanf√∂r
  closeAvatarModal();
}

function _avatarInitials(name){
  name = (name||"").trim();
  if(!name) return "?";
  const parts = name.split(/\s+/).filter(Boolean);
  const a = (parts[0]||"").charAt(0).toUpperCase();
  const b = (parts.length>1 ? (parts[parts.length-1]||"").charAt(0).toUpperCase() : "");
  return (a + b) || a || "?";
}

function _avatarBtnHtml(pid, name){
  pid = (pid==null? "" : String(pid));
  name = (name==null? "" : String(name));
  const init = _avatarInitials(name) || "?";
  return "<button class='avatarBtn small' type='button'"
    + " data-avatar-pid='" + escapeAttr(pid) + "'"
    + " data-avatar-name='" + escapeAttr(name) + "'"
    + " onclick=\"openAvatarModalResolved('" + escapeJs(pid) + "', '" + escapeJs(name) + "')\">"
    + "<span class='avatarInitials'>" + escapeHtml(init) + "</span>"
    + "<img alt='' style='display:none'>"
    + "</button>";
}


function _avatarBtnViewHtml(pid, name, sizeClass){
  // Read-only avatar for matches (shows profile picture / initials but never opens picker)
  pid = (pid==null? "" : String(pid));
  name = (name==null? "" : String(name));
  sizeClass = sizeClass || "small";
  const init = _avatarInitials(name) || "?";
  return "<div class='avatarBtn " + escapeAttr(sizeClass) + " avatarReadOnly'"
    + " data-avatar-pid='" + escapeAttr(pid) + "'"
    + " data-avatar-name='" + escapeAttr(name) + "'>"
    + "<span class='avatarInitials'>" + escapeHtml(init) + "</span>"
    + "<img alt='' style='display:none'>"
    + "</div>";
}


function _findSavedPlayerByName(name){
  const list = _loadSaved(SAVED_PLAYERS_KEY);
  const low = (name||"").trim().toLowerCase();
  return list.find(p => ((p.name||"").trim().toLowerCase()===low)) || null;
}
function _findSavedTeamByName(name){
  const list = _loadSaved(SAVED_TEAMS_KEY);
  const low = (name||"").trim().toLowerCase();
  return list.find(p => ((p.teamName||"").trim().toLowerCase()===low)) || null;
}

function _avatarPlayerIdFromAddedTitle(title){
  // F√∂r "Tillagda"-listan (som har namn): mappa via sparade profiler om m√∂jligt
  if(state.mode==='team'){
    const t=_findSavedTeamByName(title);
    return t ? t.id : null;
  }else{
    const p=_findSavedPlayerByName(title);
    return p ? p.id : null;
  }
}

function _idbOpen(){
  return new Promise((resolve,reject)=>{
    try{
      const req = indexedDB.open(AVATAR_DB_NAME, 1);
      req.onupgradeneeded = function(ev){
        const db = req.result;
        if(!db.objectStoreNames.contains(AVATAR_STORE)){
          db.createObjectStore(AVATAR_STORE);
        }
      };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error || new Error("IndexedDB error"));
    }catch(e){ reject(e); }
  });
}
function _idbGet(playerId){
  return _idbOpen().then(db=>{
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(AVATAR_STORE, "readonly");
        const st = tx.objectStore(AVATAR_STORE);
        const rq = st.get(playerId);
        rq.onsuccess = ()=>resolve(rq.result || null);
        rq.onerror = ()=>reject(rq.error);
      }catch(e){ reject(e); }
    });
  });
}
function _idbPut(playerId, record){
  return _idbOpen().then(db=>{
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(AVATAR_STORE, "readwrite");
        const st = tx.objectStore(AVATAR_STORE);
        st.put(record, playerId);
        tx.oncomplete = ()=>resolve(true);
        tx.onerror = ()=>reject(tx.error);
      }catch(e){ reject(e); }
    });
  });
}
function _idbDel(playerId){
  return _idbOpen().then(db=>{
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(AVATAR_STORE, "readwrite");
        const st = tx.objectStore(AVATAR_STORE);
        st.delete(playerId);
        tx.oncomplete = ()=>resolve(true);
        tx.onerror = ()=>reject(tx.error);
      }catch(e){ reject(e); }
    });
  });
}

function _blobToDataURL(blob){
  return new Promise((resolve,reject)=>{
    try{
      const r = new FileReader();
      r.onload = ()=>resolve(r.result);
      r.onerror = ()=>reject(r.error);
      r.readAsDataURL(blob);
    }catch(e){ reject(e); }
  });
}


function resolvePlayerId(anyIdOrName){
  // Return the best avatar key (playerId) for a reference that may be:
  // - a saved profile id
  // - a tournament/runtime id
  // - a player name
  //
  // We *prefer* saved profile ids (because avatars are stored per saved profile).
  if(!anyIdOrName) return null;

  // Helper: find saved profile id by id or name (single/team)
  function _findSavedId(ref){
    try{
      const sp = (typeof loadSavedProfiles==="function") ? loadSavedProfiles() : null;
      if(sp && Array.isArray(sp.single)){
        for(const p of sp.single){
          if(p && (p.id===ref || p.name===ref)) return p.id || null;
        }
      }
      if(sp && Array.isArray(sp.team)){
        for(const p of sp.team){
          if(p && (p.id===ref || p.name===ref)) return p.id || null;
        }
      }
    }catch(e){}
    return null;
  }

  // 1) If it's already a saved id or matches a saved profile by name, use that.
  const savedHit = _findSavedId(anyIdOrName);
  if(savedHit) return savedHit;

  // 2) If it's a runtime/tournament id, try to map via the runtime player's name -> saved profile id.
  try{
    if(state && Array.isArray(state.players)){
      const runtime = state.players.find(p=>p && p.id===anyIdOrName);
      if(runtime && runtime.name){
        const byName = _findSavedId(runtime.name);
        if(byName) return byName;
        // No saved profile match, fallback to runtime id
        return runtime.id;
      }
    }
  }catch(e){}

  // 3) If it's a name, try runtime players by name (fallback)
  try{
    if(state && Array.isArray(state.players)){
      const runtimeByName = state.players.find(p=>p && p.name===anyIdOrName);
      if(runtimeByName) return runtimeByName.id;
    }
  }catch(e){}

  return null;
}

function getAvatarDataURL(playerId){
  if(!playerId) return Promise.resolve(null);
  if(avatarCache[playerId]) return Promise.resolve(avatarCache[playerId]);
  return _idbGet(playerId).then(rec=>{
    if(!rec || !rec.blob) return null;
    return _blobToDataURL(rec.blob).then(url=>{
      avatarCache[playerId]=url;
      return url;
    });
  }).catch(()=>null);
}

function hydrateAvatarsIn(root){
  root = root || document;
  const nodes = root.querySelectorAll ? root.querySelectorAll("[data-avatar-pid]") : [];
  nodes.forEach(node=>{
    const rawPid = node.getAttribute("data-avatar-pid");
    const name = node.getAttribute("data-avatar-name") || "";
    // Resolve to the best key for avatar storage (prefer saved profile id)
    const resolvedPid = resolvePlayerId(rawPid) || resolvePlayerId(name) || rawPid;

    // If we resolved to something better, update the node so future clicks use the right key
    if(resolvedPid && resolvedPid !== rawPid){
      node.setAttribute("data-avatar-pid", resolvedPid);
    }

    const img = node.querySelector("img");
    const initialsSpan = node.querySelector("span");

    // default initials
    if(initialsSpan){
      initialsSpan.textContent = _avatarInitials(name) || "?";
      initialsSpan.style.display = "";
    }
    if(img){ img.style.display = "none"; }

    if(!resolvedPid){
      if(img){ img.removeAttribute("src"); img.style.display="none"; }
      if(initialsSpan){ initialsSpan.style.display=""; }
      return;
    }

    getAvatarDataURL(resolvedPid).then(url=>{
      if(!url){
        // show initials, hide image
        if(img){ img.removeAttribute("src"); img.style.display="none"; }
        if(initialsSpan){ initialsSpan.style.display=""; }
        return;
      }
      // show image
      if(img){
        img.src = url;
        img.style.display = "block";
        if(initialsSpan){ initialsSpan.style.display="none"; }
      }else{
        const im = document.createElement("img");
        im.alt = "avatar";
        im.src = url;
        node.innerHTML = "";
        node.appendChild(im);
      }
    });
  });
}



function openAvatarModalResolved(playerIdOrName, playerName){
  const resolved = resolvePlayerId(playerIdOrName) || resolvePlayerId(playerName) || playerIdOrName || null;
  openAvatarModal(resolved, playerName || "");
}

function openAvatarModal(playerId, playerName){
  if(!playerId){
    if(typeof toast==="function") toast("Spara profilen f√∂rst f√∂r att kunna l√§gga till bild.");
    else alert("Spara profilen f√∂rst f√∂r att kunna l√§gga till bild.");
    return;
  }
  __avatar.open=true;
  __avatar.playerId=playerId;
  __avatar.playerName=playerName||"";
  __avatar.img=null;
  __avatar.zoom=1;
  __avatar.offsetX=0;
  __avatar.offsetY=0;

  const who = document.getElementById("avatarWho");
  if(who) who.textContent = (playerName||"");

  const overlay = document.getElementById("avatarOverlay");
  if(overlay) overlay.style.display="flex";

  const file = document.getElementById("avatarFile");
  if(file) file.value="";

  const zoom = document.getElementById("avatarZoom");
  if(zoom) zoom.value="1";

  // Ladda befintlig bild till canvas (om finns)
  getAvatarDataURL(playerId).then(url=>{
    if(url){
      const im = new Image();
      im.onload = ()=>{ __avatar.img=im; _avatarFitAndDraw(); };
      im.src = url;
    }else{
      _avatarDrawInitials();
    }
  });

  _avatarBindCanvas();
}

function closeAvatarModal(){
  __avatar.open=false;
  const overlay = document.getElementById("avatarOverlay");
  if(overlay) overlay.style.display="none";
  // uppdatera UI d√§r avatars syns
  try{ hydrateAvatarsIn(document); }catch(e){}
}

function _avatarCanvas(){
  return document.getElementById("avatarCanvas");
}

function _avatarDrawInitials(){
  const c=_avatarCanvas(); if(!c) return;
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle="#f3f4f6"; ctx.fillRect(0,0,c.width,c.height);
  ctx.fillStyle="#111827";
  ctx.font="900 84px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(_avatarInitials(__avatar.playerName), c.width/2, c.height/2);
}

function _avatarFitAndDraw(){
  const c=_avatarCanvas(); if(!c) return;
  const im=__avatar.img;
  if(!im){ _avatarDrawInitials(); return; }

  // Fit image to cover the square at zoom 1
  const cw=c.width, ch=c.height;
  const scaleBase = Math.max(cw/im.width, ch/im.height);
  const scale = scaleBase * (__avatar.zoom||1);

  const drawW = im.width*scale;
  const drawH = im.height*scale;

  // Default center if offsets not set
  let x = (cw - drawW)/2 + (__avatar.offsetX||0);
  let y = (ch - drawH)/2 + (__avatar.offsetY||0);

  // clamp so we don't show empty space
  const minX = cw - drawW, maxX = 0;
  const minY = ch - drawH, maxY = 0;
  if(drawW <= cw){ x = (cw-drawW)/2; }
  else{ x = Math.min(maxX, Math.max(minX, x)); }
  if(drawH <= ch){ y = (ch-drawH)/2; }
  else{ y = Math.min(maxY, Math.max(minY, y)); }

  __avatar.offsetX = x - (cw - drawW)/2;
  __avatar.offsetY = y - (ch - drawH)/2;

  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,cw,ch);
  ctx.fillStyle="#f8fafc"; ctx.fillRect(0,0,cw,ch);
  ctx.drawImage(im, x, y, drawW, drawH);

  // subtle crop border
  ctx.strokeStyle="rgba(0,0,0,.15)";
  ctx.lineWidth=2;
  ctx.strokeRect(1,1,cw-2,ch-2);
}

function _avatarBindCanvas(){
  const c=_avatarCanvas(); if(!c || c.__bound) return;
  c.__bound=true;

  c.addEventListener("pointerdown", (e)=>{
    if(!__avatar.open) return;
    __avatar.dragging=true;
    __avatar.dragStartX=e.clientX;
    __avatar.dragStartY=e.clientY;
    __avatar.baseOffsetX=__avatar.offsetX||0;
    __avatar.baseOffsetY=__avatar.offsetY||0;
    c.setPointerCapture(e.pointerId);
  });
  c.addEventListener("pointermove", (e)=>{
    if(!__avatar.open || !__avatar.dragging) return;
    const dx = e.clientX - __avatar.dragStartX;
    const dy = e.clientY - __avatar.dragStartY;
    __avatar.offsetX = (__avatar.baseOffsetX||0) + dx;
    __avatar.offsetY = (__avatar.baseOffsetY||0) + dy;
    _avatarFitAndDraw();
  });
  c.addEventListener("pointerup", (e)=>{
    __avatar.dragging=false;
    try{ c.releasePointerCapture(e.pointerId); }catch(err){}
  });
  c.addEventListener("pointercancel", ()=>{
    __avatar.dragging=false;
  });
}

function avatarOnFile(files){
  if(!files || !files[0]) return;
  const f=files[0];
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = ()=>{
    try{ URL.revokeObjectURL(url); }catch(e){}
    __avatar.img = im;
    __avatar.zoom = 1;
    __avatar.offsetX = 0;
    __avatar.offsetY = 0;
    _avatarFitAndDraw();
  };
  im.src = url;
}

function avatarSetZoom(val){
  __avatar.zoom = parseFloat(val||"1") || 1;
  _avatarFitAndDraw();
}

function _canvasToBlob(canvas, type, quality){
  return new Promise((resolve)=>{
    try{
      canvas.toBlob((b)=>resolve(b), type, quality);
    }catch(e){ resolve(null); }
  });
}

async function saveAvatar(){
  if(!__avatar.playerId) return;
  if(!__avatar.img){
    // Spara "ingen" bild? Vi tolkar som rensa
    await clearAvatar();
    return;
  }
  const c = _avatarCanvas(); if(!c) return;

  // Rendera till 256x256
  const out = document.createElement("canvas");
  out.width = 256; out.height = 256;
  const octx = out.getContext("2d");
  // Vi vill anv√§nda samma transform som preview: √•terskapa draw i 260x260 och skala till 256
  // Rita preview-canvas och skala ner
  octx.drawImage(c, 0, 0, out.width, out.height);

  // WebP f√∂rst, annars JPEG
  let blob = await _canvasToBlob(out, "image/webp", 0.85);
  let mime = "image/webp";
  if(!blob){
    blob = await _canvasToBlob(out, "image/jpeg", 0.85);
    mime = "image/jpeg";
  }
  if(!blob){
    if(typeof toast==="function") toast("Kunde inte spara bilden.");
    else alert("Kunde inte spara bilden.");
    return;
  }

  await _idbPut(__avatar.playerId, { blob: blob, mime: mime, updatedAt: Date.now() }).catch(()=>null);
  avatarCache[__avatar.playerId] = await _blobToDataURL(blob).catch(()=>null);

  // uppdatera UI direkt
  try{ hydrateAvatarsIn(document); }catch(e){}
  if(typeof toast==="function") toast("Profilbild sparad.");
  closeAvatarModal();
}

async function clearAvatar(){
  if(!__avatar.playerId) return;
  await _idbDel(__avatar.playerId).catch(()=>null);
  delete avatarCache[__avatar.playerId];
  _avatarDrawInitials();
  try{ hydrateAvatarsIn(document); }catch(e){}
  if(typeof toast==="function") toast("Profilbild borttagen.");
}


</script>

<div id="modalButtonParking" class="hidden"></div>

<!-- ===== Steg 5: Modal f√∂r Ny spelare ===== -->
<div id="newPlayerModal" class="modalOverlay hidden" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modalSheet" id="newPlayerModalSheet">
    <div class="modalHeader">
      <h3 id="newPlayerModalTitle" style="margin-top:0">Ny spelare</h3>
    </div>
    <p class="modalSub" id="newPlayerModalSub">Fyll i uppgifter och spara.</p>
    <div id="newPlayerModalBody"></div>
  </div>
</div>


<!-- Avatar modal -->
<div id="avatarOverlay" onclick="avatarOverlayClick(event)">
  <div id="avatarModal" onclick="event.stopPropagation()">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
      <h3>Profilbild</h3>
      <button class="btn secondary" type="button" onclick="closeAvatarModal()">St√§ng</button>
    </div>
    <div id="avatarWho" class="muted" style="margin-top:-2px;margin-bottom:10px"></div>

    <div id="avatarCropWrap">
      <div>
        <div id="avatarCanvasWrap">
          <canvas id="avatarCanvas" width="260" height="260"></canvas>
        </div>
        <div class="muted" id="avatarHint" style="margin-top:8px">Dra f√∂r att flytta. Anv√§nd zoom.</div>
      </div>

      <div style="flex:1;min-width:200px">
        <label>V√§lj bild</label>
        <input id="avatarFile" type="file" accept="image/*" onchange="avatarOnFile(this.files)"/>
        <label style="margin-top:10px">Zoom</label>
        <input id="avatarZoom" type="range" min="1" max="3" step="0.01" value="1" oninput="avatarSetZoom(this.value)"/>
        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
          <button class="btn primary" type="button" onclick="saveAvatar()">Spara</button>
          <button class="btn danger secondary" type="button" onclick="clearAvatar()">Rensa bild</button>
        </div>
        <div class="muted" style="margin-top:10px">Bilden sparas lokalt p√• enheten.</div>
      </div>
    </div>
  </div>
</div>


<script>
// ===== v84 Patch: Knockout med kval (upp till 32), slumpa om + start-l√•s, matcher syns i Match-fliken =====
(function(){
  // ---- helpers ----
  function largestPowerOfTwoLE(n){ let p=1; while(p*2<=n) p*=2; return p; }
  function shuffle(a){ a=a.slice(); for(let i=a.length-1;i>0;i--){ let j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  // ---- build knockout incl qual, with explicit links for advancement ----
  // Returns flat list of match objects compatible with state.matches/openMatch/saveMatch:
  // {id, aId, bId, winnerId, result, round, nextId, nextSlot}
  function buildKnockoutWithQual(playerIds){
    const n = playerIds.length;
    if(n < 2) return [];

    const capped = playerIds.slice(0,32); // max 32
    const ids = shuffle(capped);

    const target = largestPowerOfTwoLE(ids.length);       // 4/8/16/32
    const qualCount = ids.length - target;                // number of play-in matches
    const out = [];

    // Decide round keys that will exist for main bracket (from target down to final)
    const mainRounds = [];
    if(target >= 32) mainRounds.push({key:"r16", label:"Sextondelsfinal", size:32});
    if(target >= 16) mainRounds.push({key:"r8",  label:"√Öttondelsfinal",  size:16});
    if(target >= 8)  mainRounds.push({key:"r4",  label:"Kvartsfinal",     size:8});
    if(target >= 4)  mainRounds.push({key:"r2",  label:"Semifinal",       size:4});
    mainRounds.push({key:"r1", label:"Final", size:2});

    // Map internal ids to the ids that playoffs-bracket view expects (po_*),
    // at least for 4/8 players. For 16/32 keep r*_i ids (no bracket view for those).
    function mapId(key, idx){
      if(target === 4){
        if(key === "r2") return `po_sf${idx+1}`;
        if(key === "r1") return `po_f`;
      }
      if(target === 8){
        if(key === "r4") return `po_qf${idx+1}`;
        if(key === "r2") return `po_sf${idx+1}`;
        if(key === "r1") return `po_f`;
      }
      return `${key}_${idx}`;
    }

    function mkMatch(id, roundLabel, group){
      return {
        id,
        stage:"Slutspel",
        group: group || "",
        round: roundLabel,
        aId:null, bId:null,
        winnerId:null,
        result:"",
        avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"",
        notes:"",
        nextId:null,
        nextSlot:null
      };
    }

    // Create main round match shells
    const roundMatches = {};
    mainRounds.forEach(r=>{
      const mcount = r.size/2;
      roundMatches[r.key]=[];
      for(let i=0;i<mcount;i++){
        const id = mapId(r.key, i);
        const group =
          (r.key==="r4") ? "QF" :
          (r.key==="r2") ? "SF" :
          (r.key==="r1") ? "F"  : r.key.toUpperCase();
        const label = (r.key==="r1") ? "Final" : `${r.label}${mcount>1 ? " "+(i+1) : ""}`;
        roundMatches[r.key].push(mkMatch(id, label.trim(), group));
      }
    });

    // Wire advancement between main rounds
    for(let ri=0; ri<mainRounds.length-1; ri++){
      const cur = mainRounds[ri].key;
      const nxt = mainRounds[ri+1].key;
      roundMatches[cur].forEach((m, idx)=>{
        const nextMatchIndex = Math.floor(idx/2);
        const slot = (idx%2===0) ? "aId" : "bId";
        m.nextId = mapId(nxt, nextMatchIndex);
        m.nextSlot = slot;
      });
    }

    // Qual matches (feed into FIRST main round): po_k1..po_kN
    const qual = [];
    for(let i=0;i<qualCount;i++){
      qual.push(mkMatch(`po_k${i+1}`, `Kval ${i+1}`, "K"));
      qual[i].aId = ids[i*2] || null;
      qual[i].bId = ids[i*2+1] || null;
    }

    // Participants that skip qual
    const direct = ids.slice(qualCount*2);

    // Build slots for first main round = target participants
    const firstKey = mainRounds[0].key;
    const slots = [];
    for(let i=0;i<qualCount;i++) slots.push({fromQual:true, idx:i});
    direct.forEach(pid => slots.push({pid}));

    const filled = shuffle(slots);

    // Fill first round matches
    roundMatches[firstKey].forEach(m=>{
      const s1 = filled.shift() || null;
      const s2 = filled.shift() || null;
      m.aId = s1 && s1.pid ? s1.pid : null;
      m.bId = s2 && s2.pid ? s2.pid : null;

      // store placeholders as metadata for rendering labels in playoffs view
      m._aFromQual = (s1 && s1.fromQual) ? s1.idx : null; // 0-based
      m._bFromQual = (s2 && s2.fromQual) ? s2.idx : null; // 0-based
    });

    // Wire qual -> first round: each qual winner will occupy a specific placeholder slot.
    const firstRound = roundMatches[firstKey];
    const placeholderSlots = [];
    firstRound.forEach(m=>{
      if(m._aFromQual!==null && m._aFromQual!==undefined) placeholderSlots.push({matchId:m.id, slot:"aId", qualIndex:m._aFromQual});
      if(m._bFromQual!==null && m._bFromQual!==undefined) placeholderSlots.push({matchId:m.id, slot:"bId", qualIndex:m._bFromQual});
    });
    placeholderSlots.sort((x,y)=>x.qualIndex-y.qualIndex);

    qual.forEach((qm, i)=>{
      const ps = placeholderSlots.find(s=>s.qualIndex===i);
      if(ps){
        qm.nextId = ps.matchId;
        qm.nextSlot = ps.slot;
      }
    });

    // Flatten in play-order: Qual first, then main rounds in order
    qual.forEach(m=>out.push(m));
    mainRounds.forEach(r=>{
      roundMatches[r.key].forEach(m=>out.push(m));
    });

    // Auto-advance BYE (if only one side present) repeatedly until stable
    function applyByes(){
      let changed=false;
      out.forEach(m=>{
        if(m.winnerId) return;

        // Only real BYE when opponent truly missing.
        // If slot is reserved for "Vinnare Kval X" (placeholder) we must NOT auto-decide.
        const aIsReal = !!m.aId;
        const bIsReal = !!m.bId;
        const aWaitingQual = (m._aFromQual !== null && m._aFromQual !== undefined);
        const bWaitingQual = (m._bFromQual !== null && m._bFromQual !== undefined);

        if(aIsReal && !bIsReal && !bWaitingQual){
          m.winnerId = m.aId;
          m.result = "BYE";
          changed = true;
        }else if(!aIsReal && bIsReal && !aWaitingQual){
          m.winnerId = m.bId;
          m.result = "BYE";
          changed = true;
        }
      });
      if(changed) advanceFromAllWinners();
      return changed;
    }

    function advanceFromAllWinners(){
      const byId = {};
      out.forEach(m=>byId[m.id]=m);
      out.forEach(m=>{
        if(!m.winnerId || !m.nextId || !m.nextSlot) return;
        const nm = byId[m.nextId];
        if(!nm) return;
        if(nm[m.nextSlot] !== m.winnerId){
          // If the slot is changing, clear downstream winners to avoid stale brackets
          nm[m.nextSlot] = m.winnerId;
          nm.winnerId = null;
          nm.result = "";
        }
      });
    }

    // initial propagate from any BYE winners
    advanceFromAllWinners();
    // loop BYEs a few times to settle
    for(let k=0;k<10;k++){
      if(!applyByes()) break;
    }

    return out;
  }

  // ---- override buildKnockoutBracket used by createTournament ----

  window.buildKnockoutBracket = function(playerIds){
    return buildKnockoutWithQual(playerIds);
  };

  // ---- Patch createTournament behavior for knockout: create but don't start, and show matches in Match-fliken ----
  const _origCreateTournament = window.createTournament;
  window.createTournament = function(){
    _origCreateTournament();
    try{
      if(state.format==="knockout"){
        // Ensure started=false initially and expose matches for Match-fliken
        if(!state.playoffs) state.playoffs = {started:false, matches:[]};
        state.playoffs.started = false;
        state.matches = state.playoffs.matches || state.matches || [];
        // Go to matches step by default? User wanted matches also there. We'll keep playoffs step but matches are available.
        saveState();
        renderAll();
      }
    }catch(e){}
  };

  // ---- Add controls in playoffs step (reuse existing container if present) ----
  function ensurePlayoffControls(){
    const host = document.querySelector("#playoffsStep .sectionHeader, #playoffsStep header, #playoffsStep h2, #playoffsStep h3, #playoffsStep .section-title, #playoffsStep") 
      || document.querySelector("#playoffsStep") || document.body;
    if(!host) return;

    // Visa bara "Slumpa om slutspel" n√§r formatet √§r rent slutspel (knockout).
    // I andra format (grupp/serie + slutspel) ska slutspelet styras av placeringar och inte slumpas om h√§r.
    if(state.format !== "knockout"){
      const b1 = document.getElementById("shufflePlayoffsBtn");
      if(b1){
        const w = b1.closest(".row") || b1.parentElement;
        if(w) w.remove();
      }
      const b2 = document.getElementById("startPlayoffsBtn");
      if(b2){
        const w2 = b2.closest(".row") || b2.parentElement;
        if(w2) w2.remove();
      }
      return;
    }

    // Undvik dubbla kontroller
    if(document.getElementById("shufflePlayoffsBtn")) return;

    const wrap = document.createElement("div");
    wrap.className = "row";
    wrap.style.cssText = "gap:8px;margin:8px 0;flex-wrap:wrap;";
    wrap.innerHTML = `<button id="shufflePlayoffsBtn" class="btn secondary">Slumpa om slutspel</button>`;
    host.appendChild(wrap);

    document.getElementById("shufflePlayoffsBtn").onclick = function(){
      if(state.playoffs && state.playoffs.started){
        alert("Slutspelet √§r startat och kan inte slumpas om.");
        return;
      }
      const ids = (state.players||[]).map(p=>p.id);
      const po = buildKnockoutWithQual(ids);
      state.playoffs = state.playoffs || {started:false, matches:[]};
      state.playoffs.matches = po;
      state.matches = po; // sync
      autosaveTournament(); saveState(); renderAll();
    };
  }

  // ---- Patch renderPlayoffs to keep your old bracket look, but also show kval in schema (already does) ----
  // We only ensure controls exist and that state.matches is synced.
  const _origRenderPlayoffs = window.renderPlayoffs;
  window.renderPlayoffs = function(){
    try{ ensurePlayoffControls(); }catch(e){}
    try{
      if(state.format==="knockout"){
        // keep matches in matchflik synced
        if(state.playoffs && state.playoffs.matches) state.matches = state.playoffs.matches;
      }
    }catch(e){}
    return _origRenderPlayoffs();
  };

  // ---- Patch renderMatches (knockout): keep SAME look as other formats, but use runda + v√§ntar/spelbar ----
  const _origRenderMatches = window.renderMatches;
  window.renderMatches = function(){
    if(state.format!=="knockout") return _origRenderMatches();

    applyStartStamp();
    const ms = state.matches || [];
    const rows=[];
    rows.push(`<tr><th>Match</th><th>Status</th></tr>`);
    ms.forEach(m=>{
      const started = !!(state.playoffs && state.playoffs.started);
      const ready = !!(m.aId && m.bId);
      const playable = started && ready;
      const played = !!m.winnerId;

      const labelA = m.aId ? playerName(m.aId) : (m._aFromQual!=null ? `Vinnare Kval ${m._aFromQual+1}` : "‚Äî");
      const labelB = m.bId ? playerName(m.bId) : (m._bFromQual!=null ? `Vinnare Kval ${m._bFromQual+1}` : "‚Äî");

      const status = played
        ? `<span class="tag ok">${escapeHtml(playerName(m.winnerId))} vann ${m.result?`(${escapeHtml(m.result)})`:``}</span>`
        : (playable ? `<span class="tag todo">Spelbar</span>` : `<span class="tag">V√§ntar</span>`);

      // "Runda"-tagg i meta, men samma meta-rad som √∂vriga format
      const roundTag = m.round ? escapeHtml(m.round) : "Slutspel";

      rows.push(`
        <tr class="matchRow ${played?'played':''} ${playable?'':'disabled'}" ${playable?`onclick="openMatch('${m.id}')"`:''}>
          <td>
            <div class='row' style='align-items:center;gap:8px'>
              ${m.aId ? _avatarBtnViewHtml(m.aId, playerName(m.aId), 'small') : `<span class="avatar small">${escapeHtml((labelA||'‚Äî').slice(0,2).toUpperCase())}</span>`}
              <strong>${escapeHtml(labelA)}</strong>
              <span class='muted'>vs</span>
              ${m.bId ? _avatarBtnViewHtml(m.bId, playerName(m.bId), 'small') : `<span class="avatar small">${escapeHtml((labelB||'‚Äî').slice(0,2).toUpperCase())}</span>`}
              <strong>${escapeHtml(labelB)}</strong>
            </div>
            <div class="matchMeta">
              <span class="tag">${roundTag}</span>
              ${m.finishedAt ? `<span class="tag">Avsl: ${escapeHtml(formatDateTimeShort(m.finishedAt))}</span>` : ``}
              ${m.avgA || m.avgB ? `<span class="tag">Avg: ${escapeHtml(m.avgA||'‚Äì')} / ${escapeHtml(m.avgB||'‚Äì')}</span>` : ``}
            </div>
          </td>
          <td>${status}</td>
        </tr>
      `);
    });
    $("matchesTable").innerHTML = rows.join("");
    try{ hydrateAvatarsIn($("matchesTable")); }catch(e){}
  };

  // ---- Lock openMatch before start for knockout, and also block if participants missing ----
  const _origOpenMatch = window.openMatch;
  window.openMatch = function(matchId){
    if(state.format==="knockout"){
      if(!state.playoffs || !state.playoffs.started){ alert("Tryck p√• 'Starta slutspel' innan du kan √∂ppna matcher."); return; }
      const m = (state.matches||[]).find(x=>x.id===matchId);
      if(!m || !m.aId || !m.bId){ alert("Matchen √§r inte redo √§nnu."); return; }
    }
    return _origOpenMatch(matchId);
  };

  // ---- Advance winners after saving match ----
  const _origSaveMatch = window.saveMatch;
  window.saveMatch = function(){
    _origSaveMatch();
    try{
      if(state.format!=="knockout") return;
      const ms = state.matches || [];
      const byId = {};
      ms.forEach(m=>byId[m.id]=m);
      // propagate winners
      ms.forEach(m=>{
        if(!m.winnerId || !m.nextId || !m.nextSlot) return;
        const nm = byId[m.nextId];
        if(!nm) return;
        if(nm[m.nextSlot] !== m.winnerId){
          nm[m.nextSlot] = m.winnerId;
          nm.winnerId = null;
          nm.result = "";
        }
      });
      // Apply BYE auto-wins and propagate a few times
      for(let k=0;k<10;k++){
        let changed=false;
        ms.forEach(m=>{
          if(m.winnerId) return;
          if(m.aId && !m.bId){ m.winnerId=m.aId; m.result="BYE"; changed=true; }
          else if(!m.aId && m.bId){ m.winnerId=m.bId; m.result="BYE"; changed=true; }
        });
        if(!changed) break;
        ms.forEach(m=>{
          if(!m.winnerId || !m.nextId || !m.nextSlot) return;
          const nm = byId[m.nextId];
          if(!nm) return;
          if(nm[m.nextSlot] !== m.winnerId){
            nm[m.nextSlot]=m.winnerId;
            nm.winnerId=null;
            nm.result="";
          }
        });
      }

      state.playoffs = state.playoffs || {started:true,matches:ms};
      state.playoffs.matches = ms;
      autosaveTournament(); saveState();
      renderAll();
    }catch(e){}
  };

  // ---- Keep manual player inputs stable when navigating back (avoid "forget tournament") ----
  const _origRenderPlayersStep = window.renderPlayersStep;
  window.renderPlayersStep = function(){
    _origRenderPlayersStep();
    try{
      // If a tournament already exists, prefill manual inputs from state.players (so Back doesn't "lose" it)
      if(!state.players || !state.players.length) return;
      // Find common player name inputs: ids like pName1.. or playerName1.. (best-effort)
      const inputs = Array.from(document.querySelectorAll("input[type='text'], textarea"))
        .filter(el=>/name/i.test(el.id||"") && (/(player|p)name/i.test(el.id||"")));
      if(!inputs.length) return;

      const hasAny = inputs.some(inp=>String(inp.value||"").trim().length>0);
      if(hasAny) return; // don't overwrite user edits

      // Fill sequentially
      let i=0;
      inputs.forEach(inp=>{
        if(i<state.players.length){
          inp.value = state.players[i].name || "";
          i++;
        }
      });
    }catch(e){}
  };

})();
</script>


<!-- === OFFLINE-FIRST START + LOCAL HUB (rebased on v98 core) === -->
<style>
  
html, body { height: 100%; }
body { padding-bottom: 1px; }
.overlayScreen{position:fixed;inset:0;z-index:99999;background:linear-gradient(180deg,#0b2442,#08192f);display:none;align-items:flex-start;justify-content:center;padding:24px;overflow:auto}
  .overlayScreen.active{display:flex}
  .overlayScreen .panel{width:min(720px,100%);margin-top:24px;background:rgba(255,255,255,.92);border-radius:18px;padding:18px 18px 22px;box-shadow:0 20px 60px rgba(0,0,0,.35)}
  .overlayScreen h2{margin:0 0 6px;font-size:22px}
  .overlayScreen p{margin:0 0 14px;color:#334155}
  .overlayScreen .row{display:flex;gap:12px;flex-wrap:wrap}
  .overlayScreen .row .btn{flex:1 1 220px}
  .overlayScreen .hint{margin-top:10px;font-size:13px;color:#475569}
  .overlayScreen .list{margin-top:14px;border-top:1px solid #e5e7eb;padding-top:12px}
  .overlayScreen .item{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 0;border-bottom:1px solid #eef2f7}
  .overlayScreen .item .meta{min-width:0;flex:1}
  .overlayScreen .item .meta strong{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .overlayScreen .item .actions{display:flex;gap:8px;align-items:center}
  .overlayScreen .smalllink{margin-top:10px;font-size:13px;color:#0b2442;text-decoration:underline;cursor:pointer;display:inline-block}
</style>

<div id="startScreen" class="overlayScreen active" aria-hidden="false">
  <div class="panel">
    <h2>Dart-turneringar</h2>

<div class="startHero" aria-hidden="true">
  <div class="boardWrap">
    <svg viewBox="0 0 200 200" role="img" aria-label="Darttavla">
      <circle cx="100" cy="100" r="98" fill="#0f0f0f"/>
      <path d="M 100.000 4.000 A 96 96 0 0 1 129.666 8.699 L 108.652 73.370 A 28 28 0 0 0 100.000 72.000 Z" fill="#111"/><path d="M 129.666 8.699 A 96 96 0 0 1 156.427 22.334 L 116.458 77.348 A 28 28 0 0 0 108.652 73.370 Z" fill="#f3f1e6"/><path d="M 156.427 22.334 A 96 96 0 0 1 177.666 43.573 L 122.652 83.542 A 28 28 0 0 0 116.458 77.348 Z" fill="#111"/><path d="M 177.666 43.573 A 96 96 0 0 1 191.301 70.334 L 126.630 91.348 A 28 28 0 0 0 122.652 83.542 Z" fill="#f3f1e6"/><path d="M 191.301 70.334 A 96 96 0 0 1 196.000 100.000 L 128.000 100.000 A 28 28 0 0 0 126.630 91.348 Z" fill="#111"/><path d="M 196.000 100.000 A 96 96 0 0 1 191.301 129.666 L 126.630 108.652 A 28 28 0 0 0 128.000 100.000 Z" fill="#f3f1e6"/><path d="M 191.301 129.666 A 96 96 0 0 1 177.666 156.427 L 122.652 116.458 A 28 28 0 0 0 126.630 108.652 Z" fill="#111"/><path d="M 177.666 156.427 A 96 96 0 0 1 156.427 177.666 L 116.458 122.652 A 28 28 0 0 0 122.652 116.458 Z" fill="#f3f1e6"/><path d="M 156.427 177.666 A 96 96 0 0 1 129.666 191.301 L 108.652 126.630 A 28 28 0 0 0 116.458 122.652 Z" fill="#111"/><path d="M 129.666 191.301 A 96 96 0 0 1 100.000 196.000 L 100.000 128.000 A 28 28 0 0 0 108.652 126.630 Z" fill="#f3f1e6"/><path d="M 100.000 196.000 A 96 96 0 0 1 70.334 191.301 L 91.348 126.630 A 28 28 0 0 0 100.000 128.000 Z" fill="#111"/><path d="M 70.334 191.301 A 96 96 0 0 1 43.573 177.666 L 83.542 122.652 A 28 28 0 0 0 91.348 126.630 Z" fill="#f3f1e6"/><path d="M 43.573 177.666 A 96 96 0 0 1 22.334 156.427 L 77.348 116.458 A 28 28 0 0 0 83.542 122.652 Z" fill="#111"/><path d="M 22.334 156.427 A 96 96 0 0 1 8.699 129.666 L 73.370 108.652 A 28 28 0 0 0 77.348 116.458 Z" fill="#f3f1e6"/><path d="M 8.699 129.666 A 96 96 0 0 1 4.000 100.000 L 72.000 100.000 A 28 28 0 0 0 73.370 108.652 Z" fill="#111"/><path d="M 4.000 100.000 A 96 96 0 0 1 8.699 70.334 L 73.370 91.348 A 28 28 0 0 0 72.000 100.000 Z" fill="#f3f1e6"/><path d="M 8.699 70.334 A 96 96 0 0 1 22.334 43.573 L 77.348 83.542 A 28 28 0 0 0 73.370 91.348 Z" fill="#111"/><path d="M 22.334 43.573 A 96 96 0 0 1 43.573 22.334 L 83.542 77.348 A 28 28 0 0 0 77.348 83.542 Z" fill="#f3f1e6"/><path d="M 43.573 22.334 A 96 96 0 0 1 70.334 8.699 L 91.348 73.370 A 28 28 0 0 0 83.542 77.348 Z" fill="#111"/><path d="M 70.334 8.699 A 96 96 0 0 1 100.000 4.000 L 100.000 72.000 A 28 28 0 0 0 91.348 73.370 Z" fill="#f3f1e6"/>
      <path d="M 100.000 30.000 A 70 70 0 0 1 121.631 33.426 L 119.159 41.034 A 62 62 0 0 0 100.000 38.000 Z" fill="#c21f2f"/><path d="M 121.631 33.426 A 70 70 0 0 1 141.145 43.369 L 136.443 49.841 A 62 62 0 0 0 119.159 41.034 Z" fill="#1f8a4c"/><path d="M 141.145 43.369 A 70 70 0 0 1 156.631 58.855 L 150.159 63.557 A 62 62 0 0 0 136.443 49.841 Z" fill="#c21f2f"/><path d="M 156.631 58.855 A 70 70 0 0 1 166.574 78.369 L 158.966 80.841 A 62 62 0 0 0 150.159 63.557 Z" fill="#1f8a4c"/><path d="M 166.574 78.369 A 70 70 0 0 1 170.000 100.000 L 162.000 100.000 A 62 62 0 0 0 158.966 80.841 Z" fill="#c21f2f"/><path d="M 170.000 100.000 A 70 70 0 0 1 166.574 121.631 L 158.966 119.159 A 62 62 0 0 0 162.000 100.000 Z" fill="#1f8a4c"/><path d="M 166.574 121.631 A 70 70 0 0 1 156.631 141.145 L 150.159 136.443 A 62 62 0 0 0 158.966 119.159 Z" fill="#c21f2f"/><path d="M 156.631 141.145 A 70 70 0 0 1 141.145 156.631 L 136.443 150.159 A 62 62 0 0 0 150.159 136.443 Z" fill="#1f8a4c"/><path d="M 141.145 156.631 A 70 70 0 0 1 121.631 166.574 L 119.159 158.966 A 62 62 0 0 0 136.443 150.159 Z" fill="#c21f2f"/><path d="M 121.631 166.574 A 70 70 0 0 1 100.000 170.000 L 100.000 162.000 A 62 62 0 0 0 119.159 158.966 Z" fill="#1f8a4c"/><path d="M 100.000 170.000 A 70 70 0 0 1 78.369 166.574 L 80.841 158.966 A 62 62 0 0 0 100.000 162.000 Z" fill="#c21f2f"/><path d="M 78.369 166.574 A 70 70 0 0 1 58.855 156.631 L 63.557 150.159 A 62 62 0 0 0 80.841 158.966 Z" fill="#1f8a4c"/><path d="M 58.855 156.631 A 70 70 0 0 1 43.369 141.145 L 49.841 136.443 A 62 62 0 0 0 63.557 150.159 Z" fill="#c21f2f"/><path d="M 43.369 141.145 A 70 70 0 0 1 33.426 121.631 L 41.034 119.159 A 62 62 0 0 0 49.841 136.443 Z" fill="#1f8a4c"/><path d="M 33.426 121.631 A 70 70 0 0 1 30.000 100.000 L 38.000 100.000 A 62 62 0 0 0 41.034 119.159 Z" fill="#c21f2f"/><path d="M 30.000 100.000 A 70 70 0 0 1 33.426 78.369 L 41.034 80.841 A 62 62 0 0 0 38.000 100.000 Z" fill="#1f8a4c"/><path d="M 33.426 78.369 A 70 70 0 0 1 43.369 58.855 L 49.841 63.557 A 62 62 0 0 0 41.034 80.841 Z" fill="#c21f2f"/><path d="M 43.369 58.855 A 70 70 0 0 1 58.855 43.369 L 63.557 49.841 A 62 62 0 0 0 49.841 63.557 Z" fill="#1f8a4c"/><path d="M 58.855 43.369 A 70 70 0 0 1 78.369 33.426 L 80.841 41.034 A 62 62 0 0 0 63.557 49.841 Z" fill="#c21f2f"/><path d="M 78.369 33.426 A 70 70 0 0 1 100.000 30.000 L 100.000 38.000 A 62 62 0 0 0 80.841 41.034 Z" fill="#1f8a4c"/>
      <path d="M 100.000 4.000 A 96 96 0 0 1 129.666 8.699 L 127.812 14.405 A 90 90 0 0 0 100.000 10.000 Z" fill="#c21f2f"/><path d="M 129.666 8.699 A 96 96 0 0 1 156.427 22.334 L 152.901 27.188 A 90 90 0 0 0 127.812 14.405 Z" fill="#1f8a4c"/><path d="M 156.427 22.334 A 96 96 0 0 1 177.666 43.573 L 172.812 47.099 A 90 90 0 0 0 152.901 27.188 Z" fill="#c21f2f"/><path d="M 177.666 43.573 A 96 96 0 0 1 191.301 70.334 L 185.595 72.188 A 90 90 0 0 0 172.812 47.099 Z" fill="#1f8a4c"/><path d="M 191.301 70.334 A 96 96 0 0 1 196.000 100.000 L 190.000 100.000 A 90 90 0 0 0 185.595 72.188 Z" fill="#c21f2f"/><path d="M 196.000 100.000 A 96 96 0 0 1 191.301 129.666 L 185.595 127.812 A 90 90 0 0 0 190.000 100.000 Z" fill="#1f8a4c"/><path d="M 191.301 129.666 A 96 96 0 0 1 177.666 156.427 L 172.812 152.901 A 90 90 0 0 0 185.595 127.812 Z" fill="#c21f2f"/><path d="M 177.666 156.427 A 96 96 0 0 1 156.427 177.666 L 152.901 172.812 A 90 90 0 0 0 172.812 152.901 Z" fill="#1f8a4c"/><path d="M 156.427 177.666 A 96 96 0 0 1 129.666 191.301 L 127.812 185.595 A 90 90 0 0 0 152.901 172.812 Z" fill="#c21f2f"/><path d="M 129.666 191.301 A 96 96 0 0 1 100.000 196.000 L 100.000 190.000 A 90 90 0 0 0 127.812 185.595 Z" fill="#1f8a4c"/><path d="M 100.000 196.000 A 96 96 0 0 1 70.334 191.301 L 72.188 185.595 A 90 90 0 0 0 100.000 190.000 Z" fill="#c21f2f"/><path d="M 70.334 191.301 A 96 96 0 0 1 43.573 177.666 L 47.099 172.812 A 90 90 0 0 0 72.188 185.595 Z" fill="#1f8a4c"/><path d="M 43.573 177.666 A 96 96 0 0 1 22.334 156.427 L 27.188 152.901 A 90 90 0 0 0 47.099 172.812 Z" fill="#c21f2f"/><path d="M 22.334 156.427 A 96 96 0 0 1 8.699 129.666 L 14.405 127.812 A 90 90 0 0 0 27.188 152.901 Z" fill="#1f8a4c"/><path d="M 8.699 129.666 A 96 96 0 0 1 4.000 100.000 L 10.000 100.000 A 90 90 0 0 0 14.405 127.812 Z" fill="#c21f2f"/><path d="M 4.000 100.000 A 96 96 0 0 1 8.699 70.334 L 14.405 72.188 A 90 90 0 0 0 10.000 100.000 Z" fill="#1f8a4c"/><path d="M 8.699 70.334 A 96 96 0 0 1 22.334 43.573 L 27.188 47.099 A 90 90 0 0 0 14.405 72.188 Z" fill="#c21f2f"/><path d="M 22.334 43.573 A 96 96 0 0 1 43.573 22.334 L 47.099 27.188 A 90 90 0 0 0 27.188 47.099 Z" fill="#1f8a4c"/><path d="M 43.573 22.334 A 96 96 0 0 1 70.334 8.699 L 72.188 14.405 A 90 90 0 0 0 47.099 27.188 Z" fill="#c21f2f"/><path d="M 70.334 8.699 A 96 96 0 0 1 100.000 4.000 L 100.000 10.000 A 90 90 0 0 0 72.188 14.405 Z" fill="#1f8a4c"/>
      <circle cx="100" cy="100" r="26" fill="#0f0f0f"/>
      <circle cx="100" cy="100" r="18" fill="#1f8a4c"/>
      <circle cx="100" cy="100" r="8" fill="#c21f2f"/>
      <circle cx="100" cy="100" r="98" fill="none" stroke="rgba(255,255,255,0.14)" stroke-width="2"/>
      <circle cx="100" cy="100" r="70" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="1.5"/>
      <circle cx="100" cy="100" r="62" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="1.5"/>
      <circle cx="100" cy="100" r="96" fill="none" stroke="rgba(255,255,255,0.10)" stroke-width="1.5"/>
      <circle cx="100" cy="100" r="90" fill="none" stroke="rgba(255,255,255,0.10)" stroke-width="1.5"/>
    </svg>
  </div>

  <div class="heroDart d1"><span class="flight"></span><span class="shaft"></span><span class="tip"></span></div>
  <div class="heroDart d2"><span class="flight"></span><span class="shaft"></span><span class="tip"></span></div>
  <div class="heroDart d3"><span class="flight"></span><span class="shaft"></span><span class="tip"></span></div>
</div>
  </div>
</div>

<div id="localHubScreen" class="overlayScreen" aria-hidden="true">
  <div class="panel">
    <h2>Lokala turneringar</h2>
    <p>Skapa ny eller √∂ppna en sparad turnering.</p>
    <div class="row">
      <button class="btn" id="btnHubNew">‚ûï Skapa ny turnering</button>
    </div>

    <div class="list">
      <div style="font-weight:700;margin:0 0 8px;">Mina lokala turneringar</div>
      <div id="hubList"><em>Inga sparade turneringar √§nnu.</em></div>
    </div>

    <span class="smalllink" id="btnHubShowApp">Visa appen √§nd√•</span>
  </div>
</div>

<script>
(function(){
  const LIB_PREFIX = "dart_tournament_v98_";
  const LEGACY_KEY = (typeof STORAGE_KEY !== "undefined") ? STORAGE_KEY : "turneringsapp_v2_2";
  const AUTOSAVE = (typeof AUTOSAVE_KEY !== "undefined") ? AUTOSAVE_KEY : "turneringsapp_autosave_v1";

  let INITIAL_STATE = null;

  function show(id){
    const start = document.getElementById("startScreen");
    const hub = document.getElementById("localHubScreen");
    if(start){ start.classList.remove("active"); start.setAttribute("aria-hidden","true"); }
    if(hub){ hub.classList.remove("active"); hub.setAttribute("aria-hidden","true"); }
    const el = document.getElementById(id);
    if(!el) return;
    el.classList.add("active");
    el.setAttribute("aria-hidden","false");
  }
  function hideAll(){
    document.getElementById("startScreen").classList.remove("active");
    document.getElementById("localHubScreen").classList.remove("active");
    document.getElementById("startScreen").setAttribute("aria-hidden","true");
    document.getElementById("localHubScreen").setAttribute("aria-hidden","true");
  }

  function nowIso(){ return new Date().toISOString(); }

  function loadJson(key){
    try{
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : null;
    }catch(e){ return null; }
  }
  function saveJson(key, obj){
    try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){}
  }

  // Exponera en global hj√§lpfunktion s√• k√§rnlogiken (saveState/autosave) kan
  // uppdatera turneringsbiblioteket n√§r man spelar en sparad turnering.
  // Utan detta kan matcher se ut att "inte sparas" n√§r man √∂ppnar turneringen igen.
  function persistCurrentToLibrary(){
    try{
      if(!state || !state.tournamentId) return;
      const id = String(state.tournamentId);
      const key = LIB_PREFIX + id;
      const existing = loadJson(key) || null;
      const createdAt = (existing && existing.createdAt) || state.createdAt || nowIso();
      const name = (state.tournamentName || (existing && existing.name) || "Turnering");
      const wrapper = {
        id: id,
        name: name,
        createdAt: createdAt,
        updatedAt: nowIso(),
        state: state
      };
      saveJson(key, wrapper);
    }catch(e){}
  }

  window.__hubPersistCurrent = function(){
    persistCurrentToLibrary();
  };

  function ensureInitialState(){
    if(INITIAL_STATE) return;
    try{
      // capture the current in-memory state as default template
      INITIAL_STATE = JSON.parse(JSON.stringify(state));
    }catch(e){
      INITIAL_STATE = { step:1, mode:"single", format:"round_robin", entryMode:"import", players:[], rules:{game:"301",inRule:"single",outRule:"single",legsMode:"single"} };
    }
  }

  function listTournamentKeys(){
    try{
      return Object.keys(localStorage).filter(k=>k.startsWith(LIB_PREFIX));
    }catch(e){ return []; }
  }

  function importLegacyIfNeeded(){
    try{
      const hasAny = listTournamentKeys().length > 0;
      if(hasAny) return;
      const legacy = loadJson(LEGACY_KEY) || null;
      if(!legacy) return;

      const id = "legacy_" + Date.now();
      const wrapper = {
        id,
        name: "Tidigare turnering",
        createdAt: nowIso(),
        updatedAt: nowIso(),
        state: legacy
      };
      saveJson(LIB_PREFIX + id, wrapper);
      // set tournamentId on loaded legacy state to keep future saves in library
      try{
        legacy.tournamentId = id;
        legacy.tournamentName = wrapper.name;
        legacy.createdAt = wrapper.createdAt;
      }catch(e){}
      saveJson(LEGACY_KEY, legacy);
    }catch(e){}
  }

  function hubRender(){
    const host = document.getElementById("hubList");
    const keys = listTournamentKeys();
    if(!keys.length){
      host.innerHTML = "<em>Inga sparade turneringar √§nnu.</em>";
      return;
    }
    const items = keys.map(k=>loadJson(k)).filter(Boolean).sort((a,b)=>{
      return new Date(b.updatedAt||b.createdAt) - new Date(a.updatedAt||a.createdAt);
    });

    host.innerHTML = items.map(t=>{
      const dt = (t.updatedAt||t.createdAt) ? new Date(t.updatedAt||t.createdAt).toLocaleString() : "";
      return `
        <div class="item">
          <div class="meta">
            <strong>${escapeHtml(t.name||"Namnl√∂s turnering")}</strong>
            <small>${escapeHtml(dt)}</small>
          </div>
          <div class="actions">
            <button class="btn secondary" type="button" onclick="__hubOpen('${t.id}')">√ñppna</button>
            <button class="btn secondary" type="button" onclick="__hubDelete('${t.id}')">Radera</button>
          </div>
        </div>
      `;
    }).join("");
  }

  // Exponera minimala helpers globalt s√• att andra delar av appen kan navigera hit
  // utan att trigga back-guard (ingen history/hash anv√§nds).
  window.__showLocalHub = function(){
    try{
      show("localHubScreen");
      try{ importLegacyIfNeeded(); }catch(e){}
      try{ hubRender(); }catch(e){}
    }catch(e){}
  };
  window.__showStartScreen = function(){
    try{ show("startScreen"); }catch(e){}
  };

  function escapeHtml(s){
    return String(s||"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  window.__hubOpen = function(id){
    const wrap = loadJson(LIB_PREFIX + id);
    if(!wrap || !wrap.state) return;
    try{
      state = wrap.state;
      state.tournamentId = wrap.id;
      state.tournamentName = wrap.name || state.tournamentName || "Turnering";
      state.createdAt = wrap.createdAt || state.createdAt || nowIso();
      state.updatedAt = nowIso();
      // persist back to legacy key for backward compatibility with v98 core
      saveJson(LEGACY_KEY, state);
      // also update autosave pointer
      try{ autosaveTournament(); }catch(e){}
      hideAll();
      try{ renderAll(); }catch(e){}
    }catch(e){}
  };

  window.__hubDelete = function(id){
    if(!confirm("Radera turneringen?")) return;
    try{ localStorage.removeItem(LIB_PREFIX + id); }catch(e){}
    hubRender();
  };

  function newTournament(){
    ensureInitialState();
    const name = prompt("Namn p√• turneringen (t.ex. Fredagsturnering):", "Ny turnering") || "Ny turnering";
    const id = "t_" + Date.now();
    state = JSON.parse(JSON.stringify(INITIAL_STATE));
    state.tournamentId = id;
    state.tournamentName = name.trim() || "Ny turnering";
    state.createdAt = nowIso();
    state.updatedAt = nowIso();

    // Save immediately
    saveJson(LIB_PREFIX + id, { id, name: state.tournamentName, createdAt: state.createdAt, updatedAt: state.updatedAt, state });
    saveJson(LEGACY_KEY, state);
    try{ autosaveTournament(); }catch(e){}
    hideAll();
    try{ renderAll(); }catch(e){}
  }

  function resumeLatest(){
    // Prefer autosave
    try{
      const ok = (typeof loadAutosaveTournament === "function") ? loadAutosaveTournament() : false;
      if(ok){
        // ensure has id
        if(!state.tournamentId){
          importLegacyIfNeeded();
          // try attach legacy id if created
          const keys = listTournamentKeys();
          const latest = keys.map(k=>loadJson(k)).filter(Boolean).sort((a,b)=>new Date(b.updatedAt||b.createdAt)-new Date(a.updatedAt||a.createdAt))[0];
          if(latest){
            state.tournamentId = latest.id;
            state.tournamentName = latest.name || state.tournamentName;
          }
        }
        hideAll();
        try{ renderAll(); }catch(e){}
        return;
      }
    }catch(e){}

    // If no autosave, open hub list and let user choose
    show("localHubScreen");
    hubRender();
  }

  function mirrorToLibrary(){
    try{
      if(!state) return;
      if(!state.tournamentId) return;
      const id = state.tournamentId;
      const key = LIB_PREFIX + id;
      const prev = loadJson(key) || { id, createdAt: state.createdAt || nowIso() };
      const name = state.tournamentName || prev.name || "Turnering";
      const wrap = {
        id,
        name,
        createdAt: prev.createdAt || state.createdAt || nowIso(),
        updatedAt: nowIso(),
        state: state
      };
      saveJson(key, wrap);
    }catch(e){}
  }

  // Wrap saveState + autosaveTournament to always mirror to library
  const _saveState = window.saveState;
  window.saveState = function(){
    try{ if(typeof _saveState === "function") _saveState(); }catch(e){}
    mirrorToLibrary();
  };
  const _autosave = window.autosaveTournament;
  window.autosaveTournament = function(){
    try{ if(typeof _autosave === "function") _autosave(); }catch(e){}
    mirrorToLibrary();
  };

  document.addEventListener("DOMContentLoaded", function(){
    ensureInitialState();
    importLegacyIfNeeded();


    var __btnOnline = document.getElementById("btnStartOnline");
    if(__btnOnline){
      __btnOnline.addEventListener("click", function(){
        alert("Online kommer senare. Just nu fungerar bara lokala turneringar.");
      });
    }



    document.getElementById("btnHubNew").addEventListener("click", function(){
      newTournament();
    });


    document.getElementById("btnHubShowApp").addEventListener("click", function(){
      hideAll();
      try{ renderAll(); }catch(e){}
    });

    // Splash (startScreen) visas kort och g√•r sedan automatiskt vidare till lokala turneringar
    show("startScreen");
    setTimeout(function(){
      try{ importLegacyIfNeeded(); }catch(e){}
      try{ show("localHubScreen"); }catch(e){}
      try{ hubRender(); }catch(e){}
    }, 1500);
});
})();
</script>


<script>
(function(){
  function addBackButton(){
    // (v5) Inaktiverad: Start-knappen finns nu i stegraden l√§ngst ned.
    return;
    try{
      var step1 = document.getElementById("step1");
      if(!step1) return;

      // Avoid duplicates
      if(step1.querySelector(".btn-back-setup")) return;

      var header = step1.querySelector("h2") || step1.querySelector("h1") || step1.firstElementChild;
      if(!header) header = step1;

      var bar = document.createElement("div");
      bar.className = "row btn-back-setup";
      bar.style.gap = "10px";
      bar.style.marginTop = "12px";

      // Quick: go to Lokala turneringar (screen before Uppl√§gg)
      var btnLocal = document.createElement("button");
      btnLocal.textContent = "Start";
      btnLocal.className = "btn secondary";
      btnLocal.type = "button";
      btnLocal.onclick = function(){
        try{
          if(typeof hubRender === "function") hubRender();
        }catch(e){}
        var hub = document.getElementById("localHubScreen");
        var start = document.getElementById("startScreen");
        if(hub){
          hub.classList.add("active");
          hub.setAttribute("aria-hidden","false");
        }
        if(start){
          start.classList.remove("active");
          start.setAttribute("aria-hidden","true");
        }
      };

      // Quick: go to f√∂rsta sidan (Dart-turneringar)
      var btnHome = document.createElement("button");
      btnHome.textContent = "Hem";
      btnHome.className = "btn secondary";
      btnHome.type = "button";
      btnHome.onclick = function(){
        var hub = document.getElementById("localHubScreen");
        var start = document.getElementById("startScreen");
        if(start){
          start.classList.add("active");
          start.setAttribute("aria-hidden","false");
        }
        if(hub){
          hub.classList.remove("active");
          hub.setAttribute("aria-hidden","true");
        }
      };

      bar.appendChild(btnLocal);
      bar.appendChild(btnHome);

      // Place near the top of Uppl√§gg instead of at the very bottom
      if(header && header.parentNode){
        header.parentNode.insertBefore(bar, header.nextSibling);
      }else{
        step1.insertBefore(bar, step1.firstChild);
      }
    }catch(e){}
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", addBackButton);
  }else{
    addBackButton();
  }
})();
</script>


<!-- === v98 LocalHub patch v3: show added players on load by syncing textareas from state.players === -->
<script>
(function(){
  function syncAddedToInputs(){
    try{
      if(!window.state) return;
      // Only sync when on step 3 (Spelare) or when player UI exists
      var playersTA = document.getElementById("players");
      var teamNames = document.getElementById("teamNames");

      // Single mode: fill #players from state.players if empty
      if(playersTA && (!playersTA.value || !playersTA.value.trim())){
        if(Array.isArray(state.players) && state.players.length){
          var names = state.players.filter(p=>p && p.type!=="team").map(p=>p.name||"").filter(Boolean);
          if(names.length){
            playersTA.value = names.join("\n");
          }
        }
      }

      // Team mode: fill team fields from state.players if empty
      if(teamNames && (!teamNames.value || !teamNames.value.trim())){
        if(Array.isArray(state.players) && state.players.length){
          var teams = state.players.filter(p=>p && p.type==="team");
          if(teams.length){
            var m1 = document.getElementById("teamMember1");
            var m2 = document.getElementById("teamMember2");
            teamNames.value = teams.map(t=>t.teamName||"").join("\n");
            if(m1) m1.value = teams.map(t=>t.member1||"").join("\n");
            if(m2) m2.value = teams.map(t=>t.member2||"").join("\n");
          }
        }
      }

      // Re-render the "Tillagda" list
      try{ if(typeof renderKioskList === "function") renderKioskList(); }catch(e){}
    }catch(e){}
  }

  // Hook into step navigation
  var _goStep = window.goStep;
  window.goStep = function(n){
    if(typeof _goStep === "function") _goStep(n);
    if(Number(n) === 3){
      syncAddedToInputs();
    }
  };

  // Also run after opening a tournament (renderAll is called)
  var _renderAll = window.renderAll;
  window.renderAll = function(){
    if(typeof _renderAll === "function") _renderAll();
    // If we're on players step after load, sync
    try{
      var nums = (typeof getStepNums === "function") ? getStepNums() : null;
      var stepPlayers = 3;
      if(nums && nums.players) stepPlayers = nums.players;
      if(state && Number(state.step) === Number(stepPlayers)){
        syncAddedToInputs();
      }
    }catch(e){}
  };

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", syncAddedToInputs);
  }else{
    syncAddedToInputs();
  }
})();
</script>


<!-- === v98 LocalHub patch v4: render Tillagda from state.players even if textarea cleared by kiosk mode === -->
<script>
(function(){
  function ensurePlayersTextareaFromState(){
    try{
      var ta = document.getElementById("players");
      if(!ta) return;
      var lines = (ta.value||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      if(lines.length) return;
      if(Array.isArray(state.players) && state.players.length){
        var names = state.players.filter(p=>p && p.type!=="team").map(p=>p.name||"").filter(Boolean);
        if(names.length) ta.value = names.join("\n");
      }
    }catch(e){}
  }

  // Patch renderKioskList so it falls back to state.players if textarea is empty
  var _renderKioskList = window.renderKioskList;
  window.renderKioskList = function(){
    try{
      // If single mode and textarea empty but state.players exists, sync it first
      if(window.state && state.mode!=='team'){
        ensurePlayersTextareaFromState();
      }
    }catch(e){}
    try{ return (typeof _renderKioskList === "function") ? _renderKioskList() : undefined; }
    finally{}
  };

  // When entering step 3, force a sync + list render after renderPlayersStep potentially toggled UI
  var _goStep = window.goStep;
  window.goStep = function(n){
    if(typeof _goStep === "function") _goStep(n);
    if(Number(n) === 3){
      try{
        // run after current call stack so applyEntryUI has finished
        setTimeout(function(){
          ensurePlayersTextareaFromState();
          try{ if(typeof window.renderKioskList==="function") window.renderKioskList(); }catch(e){}
        }, 0);
      }catch(e){}
    }
  };

  // Also after renderAll if we land on step3 (e.g., after loading tournament)
  var _renderAll = window.renderAll;
  window.renderAll = function(){
    var r = (typeof _renderAll === "function") ? _renderAll() : undefined;
    try{
      if(window.state && Number(state.step) === 3){
        setTimeout(function(){
          ensurePlayersTextareaFromState();
          try{ if(typeof window.renderKioskList==="function") window.renderKioskList(); }catch(e){}
        }, 0);
      }
    }catch(e){}
    return r;
  };

})();
</script>


<!-- === Auto-resume v6: √•terg√• automatiskt d√§r du slutade n√§r du kommer tillbaka fr√•n t.ex. Spotify === -->
<script>
(function(){
  function showStart(){
    try{
      var start = document.getElementById("startScreen");
      var hub   = document.getElementById("localHubScreen");
      if(start){ start.classList.add("active"); start.setAttribute("aria-hidden","false"); }
      if(hub){ hub.classList.remove("active"); hub.setAttribute("aria-hidden","true"); }
    }catch(e){}
  }

  function hideEntryOverlays(){
    try{
      var start = document.getElementById("startScreen");
      var hub   = document.getElementById("localHubScreen");
      if(start){ start.classList.remove("active"); start.setAttribute("aria-hidden","true"); }
      if(hub){ hub.classList.remove("active"); hub.setAttribute("aria-hidden","true"); }
    }catch(e){}
  }

  function hasProgress(){
    try{
      if(!window.state) return false;
      if(state.tournamentId) return true;
      if(state.tid || state.id) return true;
      if(Array.isArray(state.players) && state.players.length) return true;
      if(Array.isArray(state.matches) && state.matches.length) return true;
      if(state.step && Number(state.step) > 1) return true;
      return false;
    }catch(e){ return false; }
  }

  function tryResume(reason){
    try{
      if(typeof ensureInitialState === "function") ensureInitialState();
      if(typeof importLegacyIfNeeded === "function") importLegacyIfNeeded();
    }catch(e){}

    try{
      var ok = (typeof loadAutosaveTournament === "function") ? loadAutosaveTournament() : false;
      if(ok && hasProgress()){
        hideEntryOverlays();
        try{ if(typeof renderAll === "function") renderAll(); }catch(e){}
        return true;
      }
    }catch(e){}
    return false;
  }

  // Vid f√∂rsta start: f√∂rs√∂k √•terg√• direkt, annars visa start.
  function onBoot(){
    if(!tryResume("boot")) showStart();
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", onBoot);
  }else{
    onBoot();
  }

  // N√§r man kommer tillbaka fr√•n en annan app (Spotify etc.)
  window.addEventListener("pageshow", function(){ tryResume("pageshow"); });
  document.addEventListener("visibilitychange", function(){
    if(document.visibilityState === "visible") tryResume("visible");
  });
})();
</script>


<!-- === Patch v6: (A) players list sync per tournamentId, (B) stronger playoffs seeding/rebuild === -->
<script>
(function(){
  // --- A) Players tab: avoid showing previous tournament's "Tillagda" ---
  var __lastTidForPlayersUI = null;

  function getTid(){
    try{ return (window.state && (state.tid || state.tournamentId || state.id)) ? (state.tid || state.tournamentId || state.id) : null; }catch(e){ return null; }
  }

  function syncPlayersUI(force){
    try{
      if(!window.state) return;
      var tid = getTid();
      if(force || (tid && tid !== __lastTidForPlayersUI)){
        __lastTidForPlayersUI = tid;

        // Clear inputs first to avoid mixing tournaments
        var ta = document.getElementById("players");
        if(ta) ta.value = "";

        var teamNames = document.getElementById("teamNames");
        var m1 = document.getElementById("teamMember1");
        var m2 = document.getElementById("teamMember2");
        if(teamNames) teamNames.value = "";
        if(m1) m1.value = "";
        if(m2) m2.value = "";

        // Fill from state.players
        if(Array.isArray(state.players) && state.players.length){
          if(state.mode === "team"){
            var teams = state.players.filter(p=>p && p.type==="team");
            if(teams.length){
              if(teamNames) teamNames.value = teams.map(t=>t.teamName||"").filter(Boolean).join("\n");
              if(m1) m1.value = teams.map(t=>t.member1||"").filter(Boolean).join("\n");
              if(m2) m2.value = teams.map(t=>t.member2||"").filter(Boolean).join("\n");
            }
          }else{
            var names = state.players.filter(p=>p && p.type!=="team").map(p=>p.name||"").filter(Boolean);
            if(ta && names.length) ta.value = names.join("\n");
          }
        }
      }

      // Render "Tillagda"
      try{ if(typeof window.renderKioskList === "function") window.renderKioskList(); }catch(e){}
    }catch(e){}
  }

  // Hook into tournament open (our hub uses openTournamentById)
  var _openTournamentById = window.openTournamentById;
  window.openTournamentById = function(id){
    var r = (typeof _openTournamentById === "function") ? _openTournamentById(id) : undefined;
    try{
      // After load + render, sync player UI for this tournament
      setTimeout(function(){ syncPlayersUI(true); }, 0);
    }catch(e){}
    return r;
  };

  // Also when resuming latest
  var _resumeLatest = window.resumeLatest;
  window.resumeLatest = function(){
    var r = (typeof _resumeLatest === "function") ? _resumeLatest() : undefined;
    try{ setTimeout(function(){ syncPlayersUI(true); }, 0); }catch(e){}
    return r;
  };

  // When entering players step, sync based on tournamentId
  var _goStep = window.goStep;
  window.goStep = function(n){
    if(typeof _goStep === "function") _goStep(n);
    if(Number(n) === 3){
      try{ setTimeout(function(){ syncPlayersUI(false); }, 0); }catch(e){}
    }
  };

  // --- B) Slutspel: seed/rebuild robustly ---
  function safeTop2FromGroup(letter){
    try{
      var ids = (state.groups && state.groups[letter]) ? (state.groups[letter] || []) : [];
      // If standings can't be computed (e.g., weird data), fallback to current group order
      var st = [];
      try{ st = computeStandings(ids, state.matches, function(m){ return m.group===letter; }); }catch(e){ st = []; }
      if(!st || st.length===0){
        return (ids || []).slice(0,2);
      }
      return st.slice(0,2).map(x=>x.pid);
    }catch(e){
      try{ return ((state.groups && state.groups[letter]) ? state.groups[letter] : []).slice(0,2); }catch(_){ return ["",""]; }
    }
  }

  // Wrap buildPlayoffsPreview to use safe top2 fallback
  var _buildPlayoffsPreview = window.buildPlayoffsPreview;
  window.buildPlayoffsPreview = function(){
    // Temporarily override top2FromGroup during preview build
    var _top2 = window.top2FromGroup;
    window.top2FromGroup = safeTop2FromGroup;
    try{
      return (typeof _buildPlayoffsPreview === "function") ? _buildPlayoffsPreview() : null;
    }finally{
      window.top2FromGroup = _top2;
    }
  };

  // Rebuild playoffs if started but missing participants (empty aId/bId)
  function playoffsHasHoles(){
    try{
      if(!state.playoffs || !state.playoffs.matches || !state.playoffs.matches.length) return true;
      var ms = state.playoffs.matches;

      // "H√•l" ska bara betyda att f√∂rsta rundan saknar seedade deltagare.
      // I grupp/serie+slutspel √§r det normalt att semifinal/final saknar deltagare innan f√∂reg√•ende runda √§r spelad.
      var hasQF = false;
      for(var i=0;i<ms.length;i++){
        var m = ms[i];
        if(m && m.id==="po_qf1"){ hasQF = true; break; }
      }

      if(hasQF){
        var qfIds = ["po_qf1","po_qf2","po_qf3","po_qf4"];
        for(var k=0;k<qfIds.length;k++){
          var id = qfIds[k];
          var mm = ms.find(function(x){ return x && x.id===id; });
          if(mm && (!mm.aId || !mm.bId)) return true;
        }
        return false;
      }else{
        // F√∂rsta rundan √§r semifinaler (t.ex. 2 grupper / topp-4 fr√•n serie)
        var sfIds = ["po_sf1","po_sf2"];
        for(var k2=0;k2<sfIds.length;k2++){
          var id2 = sfIds[k2];
          var mm2 = ms.find(function(x){ return x && x.id===id2; });
          if(mm2 && (!mm2.aId || !mm2.bId)) return true;
        }
        return false;
      }
    }catch(e){ return true; }
  }

  var _ensurePlayoffs = window.ensurePlayoffs;
  window.ensurePlayoffs = function(){
    try{
      if(state && state.format && (state.format==="group_playoffs" || state.format==="round_robin_playoffs")){
        // If already started but has holes -> rebuild
        if(state.playoffs && state.playoffs.started && playoffsHasHoles()){
          state.playoffs = null;
        }
      }
    }catch(e){}
    return (typeof _ensurePlayoffs === "function") ? _ensurePlayoffs() : false;
  };

  // When entering playoffs step, if started and has holes -> rebuild then render
  var _renderPlayoffs = window.renderPlayoffs;
  window.renderPlayoffs = function(){
    try{
      if(state && (state.format==="group_playoffs" || state.format==="round_robin_playoffs")){
        if(state.playoffs && state.playoffs.started && playoffsHasHoles()){
          state.playoffs = null;
          try{ if(typeof window.ensurePlayoffs==="function") window.ensurePlayoffs(); }catch(e){}
        }
      }
    }catch(e){}
    return (typeof _renderPlayoffs === "function") ? _renderPlayoffs() : undefined;
  };

})();
</script>


<!-- === Patch v7: Slutspel robust seeding + debug seeds === -->
<script>
(function(){

  // ----- Safe standings (avoid crashes, handle partial results) -----
  var __origComputeStandings = window.computeStandings;
  window.computeStandings = function(playerIds, matches, filterFn){
    try{
      // Try original first
      if(typeof __origComputeStandings === "function"){
        return __origComputeStandings(playerIds, matches, filterFn);
      }
    }catch(e){
      // fall through to safe impl
    }

    // Safe minimal implementation
    var ids = (playerIds||[]).slice();
    var st = {};
    ids.forEach(function(pid){
      st[pid] = { pid: pid, played:0, w:0, l:0, pts:0, legsWon:0, legsLost:0,
                 avgSum:0, avgCount:0, f9Sum:0, f9Count:0, coSum:0, coCount:0 };
    });

    (matches||[]).forEach(function(m){
      try{
        if(filterFn && !filterFn(m)) return;
        if(!m || !m.aId || !m.bId) return;
        if(!st[m.aId] || !st[m.bId]) return; // ignore foreign matches
        // Only count decided matches
        var winner = (m.winnerId || m.winner || "");
        if(!winner) return;

        st[m.aId].played += 1;
        st[m.bId].played += 1;

        // legs
        var la = parseInt(m.legsA,10); if(isNaN(la)) la = 0;
        var lb = parseInt(m.legsB,10); if(isNaN(lb)) lb = 0;
        st[m.aId].legsWon += la; st[m.aId].legsLost += lb;
        st[m.bId].legsWon += lb; st[m.bId].legsLost += la;

        if(winner === m.aId){
          st[m.aId].w += 1; st[m.bId].l += 1; st[m.aId].pts += 2;
        }else if(winner === m.bId){
          st[m.bId].w += 1; st[m.aId].l += 1; st[m.bId].pts += 2;
        }

        // averages / f9 / co if present
        function addNum(obj, keySum, keyCnt, v){
          var x = parseFloat(v);
          if(v!=="" && !isNaN(x)){ obj[keySum]+=x; obj[keyCnt]+=1; }
        }
        addNum(st[m.aId], "avgSum","avgCount", m.avgA);
        addNum(st[m.bId], "avgSum","avgCount", m.avgB);
        addNum(st[m.aId], "f9Sum","f9Count", m.f9A);
        addNum(st[m.bId], "f9Sum","f9Count", m.f9B);
        addNum(st[m.aId], "coSum","coCount", m.coA);
        addNum(st[m.bId], "coSum","coCount", m.coB);

      }catch(e){}
    });

    var arr = ids.map(function(pid){
      var o = st[pid];
      o.avg = o.avgCount ? (o.avgSum/o.avgCount) : 0;
      o.f9 = o.f9Count ? (o.f9Sum/o.f9Count) : 0;
      o.co = o.coCount ? (o.coSum/o.coCount) : 0;
      o.diff = (o.legsWon - o.legsLost);
      return o;
    });

    arr.sort(function(a,b){
      if(b.pts !== a.pts) return b.pts - a.pts;
      if(b.diff !== a.diff) return b.diff - a.diff;
      if(b.legsWon !== a.legsWon) return b.legsWon - a.legsWon;
      if(b.avg !== a.avg) return b.avg - a.avg;
      return (a.pid||"").localeCompare(b.pid||"");
    });

    return arr;
  };

  // ----- Safe top2FromGroup (never empty) -----
  window.top2FromGroup = function(groupLetter){
    try{
      var ids = (window.state && state.groups && state.groups[groupLetter]) ? (state.groups[groupLetter]||[]) : [];
      if(!ids || ids.length===0) return ["",""];
      var st = [];
      try{
        st = window.computeStandings(ids, state.matches, function(m){ return m && m.group===groupLetter; });
      }catch(e){ st = []; }
      if(!st || st.length===0){
        return ids.slice(0,2);
      }
      var top = st.slice(0,2).map(function(x){ return x && x.pid ? x.pid : ""; });
      // if still empty, fallback to ids
      if(!top[0]) top[0] = ids[0] || "";
      if(!top[1]) top[1] = ids[1] || "";
      return top;
    }catch(e){
      try{ return ((state.groups && state.groups[groupLetter]) ? state.groups[groupLetter] : []).slice(0,2); }catch(_){ return ["",""]; }
    }
  };

  // ----- EnsurePlayoffs: rebuild if preview is empty/holes -----
  var __origEnsurePlayoffs = window.ensurePlayoffs;
  window.ensurePlayoffs = function(){
    try{
      if(state && state.playoffs && state.playoffs.matches && state.playoffs.matches.length){
        // ok
      }else{
        // if started but empty -> wipe
        if(state && state.playoffs && state.playoffs.started){
          state.playoffs = null;
        }
      }
    }catch(e){}
    if(typeof __origEnsurePlayoffs === "function") return __origEnsurePlayoffs();
    return false;
  };

  // ----- Debug: show seeds A1/A2/B1/B2 + preview length on Slutspel -----
  function setPlayoffsDebug(){
    try{
      var box = document.getElementById("tourneySummary");
      if(!box) return;
      if(!window.state || !state.groups) return;
      var A = top2FromGroup("A");
      var B = top2FromGroup("B");
      function nm(id){ try{ return playerName(id) || "‚Äî"; }catch(e){ return "‚Äî"; } }
      var preview = null;
      try{ preview = buildPlayoffsPreview(); }catch(e){ preview = null; }
      var len = (preview && preview.length) ? preview.length : 0;
      box.innerHTML = '<div class="hint" style="margin:0">'
        + '<span class="pill" style="display:inline-block;margin-right:8px">A1: '+escapeHtml(nm(A[0]))+'</span>'
        + '<span class="pill" style="display:inline-block;margin-right:8px">A2: '+escapeHtml(nm(A[1]))+'</span>'
        + '<span class="pill" style="display:inline-block;margin-right:8px">B1: '+escapeHtml(nm(B[0]))+'</span>'
        + '<span class="pill" style="display:inline-block;margin-right:8px">B2: '+escapeHtml(nm(B[1]))+'</span>'
        + '<span class="pill" style="display:inline-block">preview: '+len+'</span>'
        + '</div>';
    }catch(e){}
  }

  var __origRenderPlayoffs = window.renderPlayoffs;
  window.renderPlayoffs = function(){
    var r = (typeof __origRenderPlayoffs === "function") ? __origRenderPlayoffs() : undefined;
    setTimeout(setPlayoffsDebug, 0);
    return r;
  };

})();

/*** PATCH v11: robust grupp->slutspel seedning (top2FromGroup) ***/
(function(){
  function uniq(arr){
    var out=[], seen={};
    (arr||[]).forEach(function(x){
      if(!x) return;
      var k = String(x);
      if(seen[k]) return;
      seen[k]=1; out.push(x);
    });
    return out;
  }

  // Override top2FromGroup so it ALWAYS finds two spelare om gruppen finns.
  window.top2FromGroup = function(groupLetter){
    groupLetter = (groupLetter||"").toString().trim();

    // 1) F√∂rs√∂k med state.groups[letter]
    var ids = [];
    try{
      var g = state && state.groups ? state.groups[groupLetter] : null;
      if(Array.isArray(g)){
        ids = g.map(function(x){
          if(!x) return "";
          if(typeof x === "string") return x;
          if(typeof x === "number") return String(x);
          if(typeof x === "object" && x.id) return String(x.id);
          return "";
        }).filter(Boolean);
      }
    }catch(e){}

    // 2) Fallback: h√§rled fr√•n gruppmatcherna
    if(!ids || ids.length < 2){
      try{
        var ms = Array.isArray(state.matches) ? state.matches : [];
        var fromMatches = [];
        ms.forEach(function(m){
          if(!m) return;
          if(m.stage !== "Gruppspel") return;
          if((m.group||"") !== groupLetter) return;
          if(m.aId) fromMatches.push(m.aId);
          if(m.bId) fromMatches.push(m.bId);
        });
        ids = uniq(fromMatches);
      }catch(e){}
    }

    // 3) Om vi fortfarande saknar: ge tomt (l√•ter UI visa placeholder)
    if(!ids || ids.length < 2){
      return ["",""];
    }

    // 4) R√§kna tabell och returnera topp 2
    try{
      var st = computeStandings(ids, state.matches, function(m){ return m && m.stage==="Gruppspel" && (m.group||"")===groupLetter; });
      var top = (st||[]).slice(0,2).map(function(x){ return x.pid; });
      return [top[0]||ids[0]||"", top[1]||ids[1]||""];
    }catch(e){
      // Sista fallback: f√∂rsta tv√•
      return [ids[0]||"", ids[1]||""];
    }
  };

  // S√§kerhet: n√§r man trycker "Starta slutspel" i group_playoffs, bygg alltid om preview precis d√•.
  var _ensurePlayoffs = window.ensurePlayoffs;
  window.ensurePlayoffs = function(){
    if(state && state.format==="group_playoffs"){
      // Om grupperna finns men playoffs blir tomt, tvinga preview-rebuild.
      if(state.playoffs && state.playoffs.started && Array.isArray(state.playoffs.matches) && state.playoffs.matches.length){
        return true;
      }
      var chk = canStartPlayoffsNow();
      if(!chk.ok) return false;
      var preview = buildPlayoffsPreview();
      if(!preview) return false;
      state.playoffs = { started:true, matches: preview };
      saveState();
      return true;
    }
    return _ensurePlayoffs ? _ensurePlayoffs() : false;
  };
})();

</script>


  <div style="display:flex; gap:8px; flex: 0 0 auto;">
        
        <button id="btnDismissFullHint" type="button" aria-label="St√§ng" style="
            border:0; padding:10px 12px; border-radius:12px; font-weight:700;
            background:rgba(255,255,255,0.12); color:#fff; cursor:pointer;">√ó</button>
      </div>
    </div>
  </div>


<script>



</body>
</html>