<!DOCTYPE html>

<html lang="sv">
<head>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#111111">

  <!-- App-lik upplevelse / PWA -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Dart-turnering</title>
<style>
.linklike{ color:inherit; }
.linklike:active{ opacity:.7; }

    
    
html, body { height: 100%; }
body { padding-bottom: 1px; }
/* Hide progress pill (x / y klara) */
    #progressPill{display:none!important;}
:root{
            --accent: var(--primary);
--bg:#f4f6f8; --card:#fff; --ink:#111827; --muted:#6b7280;
      --primary:#2563eb; --primary-ink:#fff; --border:#e5e7eb;
      --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
          --matchTitleSize: clamp(22px, 4.8vw, 30px);
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;margin:0;background:var(--bg);color:var(--ink)}
    header{background:linear-gradient(180deg,#0b1220,#111827);color:#fff;padding:14px 16px;position:fixed;top:0;left:0;right:0;z-index:9000;display:flex;align-items:center;justify-content:center}
    header h1{margin:0;font-size:28px;letter-spacing:0.2px}
    header p{margin:6px 0 0;color:rgba(255,255,255,.8);font-size:13px}
    /* Hamburger-meny */
    .hamburger{position:absolute;left:12px;top:50%;transform:translateY(-50%);border:1px solid rgba(255,255,255,.22);background:rgba(255,255,255,.08);color:#fff;border-radius:12px;padding:8px 10px;font-size:18px;line-height:1;cursor:pointer}
    .hamburger:active{opacity:.8}
    .menuOverlay{position:fixed;inset:0;z-index:9500;background:rgba(0,0,0,.35);display:flex;align-items:flex-start;justify-content:flex-start;padding:10px}
    .menuPanel{margin-top:58px;width:min(340px,92vw);background:#fff;border:1px solid #e6eaf2;border-radius:16px;box-shadow:0 18px 60px rgba(0,0,0,.22);padding:10px}
    .menuPanel .stepper{display:flex;flex-direction:column;gap:10px;flex-wrap:nowrap;margin:0}
    .menuPanel .step{display:block;width:100%;text-align:left;padding:10px 12px;border-radius:14px;font-size:14px}
    .menuPanel .step.active{background:#111827;color:#fff;border-color:#111827}
    main{padding-top:74px}

    main{padding:14px;max-width:980px;margin:0 auto 32px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 6px 16px rgba(0,0,0,.05)}
    .card h2{margin:0 0 10px;font-size:18px}
    .card h3{margin:14px 0 8px;font-size:15px}
    .grow{flex:1 1 320px}
    label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
    input, select, textarea{
      width:100%; padding:11px 12px; font-size:16px; border:1px solid var(--border);
      border-radius:12px; outline:none; background:#fff;
    }
    textarea{resize:vertical}
    input:focus, select:focus, textarea:focus{border-color:#c7d2fe; box-shadow:0 0 0 4px rgba(99,102,241,.12)}
    .btnbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      padding:11px 12px; font-size:15px; border-radius:12px; border:1px solid transparent;
      cursor:pointer;
    }
    .btn{background:var(--primary);color:var(--primary-ink)}
    .btn:hover{filter:brightness(.98)}
    .btn.secondary{background:#fff;color:var(--ink);border-color:var(--border)}
    .btn.danger{background:#fff;color:var(--danger);border-color:#fecaca}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted)}
    .pill strong{color:var(--ink)}
    .hidden{display:none !important}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{padding:10px 10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:middle}
/* Kompakt tabell (serie-hubb) */
.hubCompact{font-size:13px; line-height:1.15;}
.hubCompact th, .hubCompact td{padding:6px 6px;}
.hubCompact th{font-size:11px; letter-spacing:.05em;}
.hubCompact td{white-space:nowrap;}
.hubCompact td:nth-child(2){white-space:normal;}
    th{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.06em}
    tr.played{background:#eef2ff}
    .matchRow{cursor:pointer}

    #matchesTable th:first-child,#matchesTable td:first-child{width:72%}
    #matchesTable th:last-child,#matchesTable td:last-child{width:28%;white-space:nowrap}
    .matchMeta{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);white-space:nowrap;display:inline-flex;align-items:center;gap:4px;}
    .tag.ok{border-color:#bbf7d0;color:var(--ok);background:#f0fdf4}
    .tag.todo{border-color:#e5e7eb;color:var(--muted);background:#fafafa}
    .split{display:flex;gap:10px;flex-wrap:wrap}
    .split > div{flex:1 1 220px}
    .hint{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.35}
    label.statRow{display:flex;justify-content:space-between;align-items:baseline;gap:10px}
    .stepper{display:none;gap:8px;flex-wrap:wrap;margin:12px 0}
    .step{padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted)}
    .step.active{background:#111827;color:#fff;border-color:#111827}
    .grid2{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width: 860px){ .grid2{grid-template-columns: 1.2fr .8fr} }
    /* Modal */
    .overlay{position:fixed;inset:0;z-index:100000;background:rgba(17,24,39,.55);display:flex;align-items:flex-end;justify-content:center;padding:14px}
    .modal{width:min(680px,100%);background:#fff;border-radius:18px;border:1px solid var(--border);box-shadow:0 20px 60px rgba(0,0,0,.25);padding:14px}
    @media (min-width: 640px){ .overlay{align-items:center} }
    .modal h2{margin:0 0 10px;font-size:var(--matchTitleSize);line-height:1.1}
    .modal .top{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
.topActions{display:flex;flex-direction:column;gap:6px;align-items:flex-end}
.topActions .btn{padding:6px 10px}

    .x{background:#fff;border:1px solid var(--border);border-radius:12px;padding:8px 10px}
    .winBtns{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
    .winBtn{padding:12px;border-radius:14px;border:1px solid var(--border);background:#fff;font-weight:600}
    .winBtn.primary{border-color:#93c5fd;background:#eff6ff}

    /* Byt sida i matchmodal (A/B vänster/höger) */
    #matchModal.swapped .winBtns{direction:rtl;}
    #matchModal.swapped .winBtn{direction:ltr;}
    #matchModal.swapped .split{flex-direction:row-reverse;}

    .small{font-size:12px;color:var(--muted)}

    body.modal-open{overflow:hidden}
    .overlay{align-items:center; overflow:auto}
    .modal{max-height:90vh; overflow:auto; -webkit-overflow-scrolling:touch}
    .modal .top{position:sticky; top:0; background:#fff; padding-top:4px; z-index:2}

    /* Bracket */
    .bracket{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width: 860px){ .bracket{grid-template-columns: 1fr 1fr 1fr} }
    .roundCol h3{margin:0 0 8px}
    .matchCard{border:1px solid var(--border);border-radius:14px;padding:8px;background:#fff}
    .matchCard .name{display:flex;justify-content:space-between;gap:8px;padding:6px 8px;border-radius:12px;border:1px solid var(--border);margin-top:6px}
    .matchCard .name.win{border-color:#bbf7d0;background:#f0fdf4}
    .footerSpace{height:16px}
  
  .link{color:var(--accent);text-decoration:underline;word-break:break-all;}

  @media print{
header, .stepper, .btnbar, .overlay, .pill, .btn, textarea, input, select { display:none !important; }
    button:not(.clickableName){ display:none !important; }
    /* Visa spelarnamn i PDF (de är klickbara knappar i tabellen) */
    button.clickableName{ display:inline !important; background:transparent !important; border:0 !important; padding:0 !important; margin:0 !important; color:#000 !important; font:inherit !important; text-decoration:underline; }

    /* Visa spelarnamn i PDF (de är klickbara knappar i tabellen) */
    /* Men låt spelarnamn synas i PDF */    body{ background:#fff !important; }
    main{ padding:0 !important; max-width:none !important; }
    .card{ box-shadow:none !important; border:1px solid #ddd !important; margin:0 0 12px 0 !important; }
    .grid2{ grid-template-columns: 1fr !important; }
    a{ color:#000 !important; text-decoration:underline !important; }
  }


  .qual{background:#e8f7ee !important;}
  .qual td{background:#e8f7ee !important;}
.qual td:first-child{font-weight:700;}
  .qual   .lockedBanner{padding:10px 12px;border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,0.03);margin:8px 0;}
  .clickableName{cursor:pointer;text-decoration:underline;text-decoration-thickness:1px;text-underline-offset:2px;}

  .linkbtn{background:none;border:none;padding:0;margin:0;color:inherit;font:inherit;cursor:pointer;text-decoration:underline;text-decoration-thickness:1px;text-underline-offset:2px;}

  .namebtn{background:none;border:none;padding:0;margin:0;color:inherit;font:inherit;cursor:pointer;text-decoration:underline;text-decoration-thickness:1px;text-underline-offset:2px;}

/* PRINT (PDF) – sammanställning */
#printRoot{display:none}
@media print{
  /* Visa bara printRoot */
  body > :not(#printRoot){display:none !important;}
  #printRoot{display:block !important;}
  .page-break{break-before:page; page-break-before:always}
  .avoid-break{break-inside:avoid; page-break-inside:avoid}
  table{width:100%; border-collapse:collapse; break-inside:avoid; page-break-inside:avoid}
  thead{display:table-header-group}
  tfoot{display:table-footer-group}
  tr{break-inside:avoid; page-break-inside:avoid}
  h1,h2{break-after:avoid; page-break-after:avoid; margin:0 0 8px 0}
  @page{margin:12mm}
}
    /* Checkbox ska inte ärva input=100% bredd */
    input[type="checkbox"]{
      width:auto !important;
      padding:0 !important;
      border-radius:4px;
      box-shadow:none !important;
    }


/* --- Sportigt, professionellt tema (UI + PDF) --- */
:root{
  --primary:#0B1F3B;          /* navy */
  --primary-ink:#ffffff;
  --accent:#0B1F3B;
  --accent2:#22c55e;          /* sportgrön */
  --bg:#f3f6fb;
  --card:#ffffff;
  --ink:#0b1220;
  --muted:#556070;
  --border:#d7dde6;
  --ok:#22c55e;
  --warn:#f59e0b;
  --danger:#ef4444;
}

header{
  background: linear-gradient(180deg, #071427, #0B1F3B);
}
header h1{ letter-spacing:0.5px; text-transform:uppercase; font-weight:800; }
header p{ color:rgba(255,255,255,.85); }

.card{
  border:1px solid rgba(11,31,59,.10);
}
.btn{
  border-radius:14px;
  box-shadow: 0 10px 24px rgba(11,31,59,.14);
}
.btn.secondary{
  background: rgba(11,31,59,.03);
  border-color: rgba(11,31,59,.14);
}
.btn.secondary:hover{
  background: rgba(11,31,59,.06);
}
.btn.danger{
  background:#fff;
  border-color: rgba(239,68,68,.35);
}
.pill{
  border-color: rgba(34,197,94,.35);
  background: rgba(34,197,94,.08);
  color: #2f3a4a;
}
.pill strong{ color: var(--primary); }

.titleblock{display:flex;flex-direction:column;gap:2px;}

.datestamp{
  font-size:12px;
  color: var(--muted);
  margin-top:2px;
}

/* Tabeller: bättre läsbarhet */
table{
  border-radius:12px;
  overflow:hidden;
}
thead th{
  background: rgba(11,31,59,.06);
}
tbody tr:nth-child(even){
  background: rgba(11,31,59,.03);
}

/* Tabell: spelare (placering + avatar + namn på en rad) */
.standingsPlayerCell{
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;
  white-space:nowrap;
}
.standingsPlayerCell .avatarBtn{
  flex:0 0 auto;
}
.standingsNameBtn{
  display:inline-block;
  max-width: 14ch;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
  vertical-align:bottom;
}

/* PDF header */
@media print{
  .print-header{
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    margin:0 0 10px 0;
    padding:0 0 8px 0;
    border-bottom:2px solid rgba(11,31,59,.25);
  }
  .print-title{
    font-size:16pt;
    font-weight:800;
    letter-spacing:0.5px;
    text-transform:uppercase;
    color:#0B1F3B;
  }
  .print-meta{
    font-size:10pt;
    color:#334155;
  }
  .print-date-inline{
    font-size:10pt;
    font-weight:500;
    color:#334155;
    margin-left:8px;
  }
  h1{
    color:#0B1F3B;
  }
}


/* Initial-avatar för spelare */
.playerBadge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:26px;
  height:26px;
  border-radius:50%;
  background:#1f7a4f;
  color:#fff;
  font-weight:600;
  font-size:14px;
  margin-right:8px;
  flex-shrink:0;
}


/* Profil-avatar (initial) */
.playerHeader{display:flex;align-items:center;gap:10px;margin:0 0 6px 0;}
.playerAvatar{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:42px;
  height:42px;
  border-radius:50%;
  background:#1f7a4f;
  color:#fff;
  font-weight:700;
  font-size:20px;
  flex-shrink:0;
}


    .sliderWrap{margin-top:6px}
    .sliderWrap .statLabel{display:flex;justify-content:space-between;gap:10px;align-items:baseline}
    .sliderWrap input[type=range]{width:100%}

/* Slider value bubble */
.sliderBox{position:relative; padding-top:clamp(42px, 7vw, 56px);}
.sliderBubble{
  position:absolute;
  top:0;
  left:50%;
  transform:translateX(-50%);
  padding:6px 14px;
  border-radius:999px;
  background:#0c2340;
  color:#fff;
  font-size:var(--matchTitleSize);
  font-weight:700;
  line-height:1.1;
  max-width:90%;
  text-align:center;
  white-space:nowrap;
  pointer-events:none;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}

/* Slider: knappar vid reglaget (±) */
.sliderLine{display:flex;gap:12px;align-items:center}
.sliderLine input[type=range]{flex:1 1 auto;min-width:0}
.sliderNudgeBtn{
  flex:0 0 auto;
  min-width:56px;
  padding:14px 16px;
  border-radius:18px;
  border:1px solid rgba(11,31,59,.14);
  background:#fff;
  font-weight:900;
  font-size:18px;
  line-height:1;
}

/* Slider: finjustering (±) */
.sliderControls{
  margin-top:10px;
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:space-between;
}
.sliderControls .sliderNudgeBtn{
  flex:0 0 auto;
}
.sliderNum{
  width:88px;
  max-width:32vw;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid rgba(11,31,59,.18);
  text-align:center;
  font-weight:800;
}
@media print{
  .sliderControls{ display:none !important; }
}




/* --- Slutspelsträd (bracket-canvas: Semis + Final, redo för Kvarts i framtiden) --- */
#playoffsBracket{
  position:relative;
  border-radius:18px;
  background:#f7f9fc;
  border:1px solid #eef1f6;
  padding:14px;
  overflow:hidden;            /* visa hela bracket utan scroll */
  -webkit-overflow-scrolling: touch;
}
#playoffsBracket::-webkit-scrollbar{ height:10px; }
#playoffsBracket::-webkit-scrollbar-thumb{ background:#dbe3ef; border-radius:10px; }

#playoffsBracket .bracketLines{
  position:absolute;
  left:0; top:0;
  width:100%;
  height:100%;
  pointer-events:none;
}
#playoffsBracketInner{
  position:relative;
  min-width:620px;           /* så det faktiskt ser ut som ett träd på mobil */
  padding:6px;
  width:100%;
  min-width:0;
}
.bracketGrid4{
  display:grid;
  grid-template-columns: 240px 1fr;
  grid-template-rows: auto auto;
  column-gap: 16px;
  row-gap: 18px;
  align-items:center;
}
.bracketCell{ position:relative; }
.bracketCell.qf{
  grid-column:1;
  grid-row:1 / span 4;
  align-self:stretch;
  display:flex;
  flex-direction:column;
  gap:12px;
}
.bracketCell.final{ grid-column:2; grid-row:1 / span 2; align-self:center; }
.bracketCell.sf1{ grid-column:1; grid-row:1; align-self:start; }
.bracketCell.sf2{ grid-column:1; grid-row:2; align-self:end; }

/* 4 grupper: QF + SF + Final i tre kolumner */
#playoffsBracketInner.hasQF{ min-width: 880px; }
#playoffsBracketInner.hasQF .bracketGrid4{
  grid-template-columns: 280px 240px 1fr;
  grid-template-rows: repeat(4, auto);
  row-gap: 18px;
  align-items: stretch;
}
#playoffsBracketInner.hasQF .bracketCell.qf{ grid-column:1; grid-row:1 / span 4; }
#playoffsBracketInner.hasQF .bracketCell.sf1{ grid-column:2; grid-row:1 / span 2; align-self:center; }
#playoffsBracketInner.hasQF .bracketCell.sf2{ grid-column:2; grid-row:3 / span 2; align-self:center; }
#playoffsBracketInner.hasQF .bracketCell.final{ grid-column:3; grid-row:1 / span 4; align-self:center; }

/* Knockout med kval: extra kolumn längst till vänster */
#playoffsBracketInner.hasQUAL{ min-width: 980px; }
#playoffsBracketInner.hasQUAL .bracketGrid4{
  grid-template-columns: 240px 240px 1fr;
  grid-template-rows: repeat(4, auto);
  row-gap: 18px;
  align-items: stretch;
}
#playoffsBracketInner.hasQUAL .bracketCell.qual{ grid-column:1; grid-row:1 / span 4; align-self:stretch; display:flex; flex-direction:column; justify-content:space-between; gap:14px; }
#playoffsBracketInner.hasQUAL .bracketCell.sf1{ grid-column:2; grid-row:1 / span 2; align-self:center; }
#playoffsBracketInner.hasQUAL .bracketCell.sf2{ grid-column:2; grid-row:3 / span 2; align-self:center; }
#playoffsBracketInner.hasQUAL .bracketCell.final{ grid-column:3; grid-row:1 / span 4; align-self:center; }

/* Knockout med kval + kvarts: 4 kolumner */
#playoffsBracketInner.hasQUAL.hasQF{ min-width: 1180px; }
#playoffsBracketInner.hasQUAL.hasQF .bracketGrid4{
  grid-template-columns: 240px 280px 240px 1fr;
  grid-template-rows: repeat(4, auto);
  row-gap: 18px;
  align-items: stretch;
}
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.qual{ grid-column:1; grid-row:1 / span 4; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.qf{ grid-column:2; grid-row:1 / span 4; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.sf1{ grid-column:3; grid-row:1 / span 2; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.sf2{ grid-column:3; grid-row:3 / span 2; }
#playoffsBracketInner.hasQUAL.hasQF .bracketCell.final{ grid-column:4; grid-row:1 / span 4; }


.finalWrap{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:nowrap;
}
.trophyCircle{
  width:48px;
  height:48px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#f1f3f7;
  border:1px solid #e6ebf3;
  font-size:22px;
  flex:0 0 auto;
}

.winnerAvatar{
  flex:0 0 auto;
}
.winnerAvatar .avatarBtn{
  pointer-events:none;
}
.winnerBox{
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid #e6ebf3;
  background:#fff;
  box-shadow: 0 6px 18px rgba(15,23,42,.06);
  max-width:260px;
  flex:0 0 auto;
}
.winnerBox.hasWinner{
  border-color:#bbf7d0;
  background:#f0fdf4;
}
.winnerText{
  display:flex;
  flex-direction:column;
  gap:2px;
  font-weight:800;
  line-height:1.15;
}
.winnerLabel{
  font-weight:800;
  font-size:12px;
  opacity:.85;
}
.winnerValue{
  font-weight:900;
}
.winnerText .winnerNameTxt{
  font-weight:900;
}


.bracketBox{
  background:#ffffff;
  border:1px solid #eef1f6;
  border-radius:16px;
  box-shadow: 0 10px 30px rgba(15,23,42,.06);
  overflow:hidden;
  cursor:pointer;
  user-select:none;
}


/* Steg 6: Förberedd bracket-struktur använder bracketMatchBox/bracketTitle.
   Mappa dem till befintlig bracketBox-styling så att boxarna alltid renderas snyggt. */
.bracketMatchBox{
  background:#ffffff;
  border:1px solid #eef1f6;
  border-radius:16px;
  box-shadow: 0 10px 30px rgba(15,23,42,.06);
  overflow:hidden;
  cursor:pointer;
  user-select:none;
}
.bracketTitle{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  border-bottom:1px solid #f0f3f8;
  font-weight:800;
}
.bracketBoxHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  border-bottom:1px solid #f0f3f8;
}
.bracketBoxTitle{
  font-weight:800;
}
.bracketPill{
  font-size:12px;
  padding:5px 9px;
  border-radius:999px;
  border:1px solid #e6ebf3;
  background:#f7f9fc;
}
.bracketBody{ padding:8px 10px 10px 10px; display:flex; flex-direction:column; gap:6px; }
.bracketRow{
  padding:7px 10px;
  border-radius:10px;
  background:#f7f9fc;
  font-weight:800;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.bracketRow.winnerRow{
  background:#f0fdf4;
  border:1px solid #bbf7d0;
}
.winnerName{
  color: var(--ok);
}

.bracketRow .mutedName{ font-weight:700; opacity:.55; }
.bracketScore{
  font-weight:900;
  letter-spacing:.5px;
}
.bracketHint{
  margin-top:8px;
  font-size:13px;
  color:#667085;
}

@media (max-width: 720px){
/* På små skärmar kan linjer bli röriga – men vi visar dem ändå */
  #playoffsBracket .bracketLines{ opacity:.9; }
  .trophyCircle{ width:56px; height:56px; font-size:24px; }
}

/* --- Kompakt bracket-rutor (visa namn + poäng, ingen extra rubrik/pill) --- */
.bracketBoxHeader{ display:none !important; }
.bracketBody{ padding:8px 10px !important; gap:6px !important; }
.bracketRow{ padding:8px 10px !important; }
.bracketScore{ font-size:16px !important; }


/* --- Bracket (slutspelsträd) layout tweaks v77 --- */
#playoffsBracketViewport{
  overflow-x: auto !important;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
}
#playoffsBracketCanvas{
  min-width: 640px; /* allow full tree on small screens */
}
.bracketBox{
  width: 220px; /* narrower boxes so final fits more often */
  max-width: 220px;
}
.bracketBox .brRow{
  display:flex;
  align-items:center;
  justify-content:flex-start; /* keep score close */
  gap: 10px;
  padding: 10px 12px;
}
.bracketBox .brName{
  flex: 0 1 auto;
  min-width: 0;
}
.bracketBox .brScore{
  flex: 0 0 auto;
  margin-left: auto; /* keep a small separation, but within narrow width */
}
/* Make final box slightly narrower too */
.bracketBox.brFinal{
  width: 210px;
  max-width: 210px;
}


/* --- Bracket layout tweaks v78 (smalare rutor + scroll tillbaka) --- */
#playoffsBracket{
  overflow-x: auto !important;
  overflow-y: hidden !important;
  -webkit-overflow-scrolling: touch;
}
#playoffsBracketInner{
  min-width: 640px; /* låt finalen få plats på små skärmar */
  padding-right: 18px; /* lite luft så sista rutan inte klipps */
}
/* Smalare matchrutor */
.bracketMatch{ width: 190px !important; max-width: 190px !important; }
/* Gör poängen närmare namnet och minska intern padding */
.bracketBody{ padding:8px 10px !important; }
.bracketRow{
  padding:8px 10px !important;
  justify-content:flex-start !important;
}
.bracketScore{
  margin-left:auto !important;
  font-size:16px !important;
}


/* --- Bracket polish v79 (smalare rutor, pokal längst höger, snabbknappar) --- */
.bracketNav{
  display:none; /* snabbknapparna behövs inte – man kan scrolla i trädet */
  gap:10px;
  flex-wrap:wrap;
  margin: 0 0 10px 0;
}
.bracketNavBtn{ padding:10px 14px; border-radius:999px; }
.finalWrap{ width:100%; }
.trophyCircle{ margin-left:auto; } /* put trophy at far right */

.bracketBox{
  width: 180px;           /* kortare rutor */
  max-width: 180px;
}
.bracketRow{
  display:flex;
  align-items:center;
  gap:10px;
  padding:8px 10px;
  justify-content:flex-start; /* inte space-between */
}
.bracketRow > div:first-child{
  flex:1 1 auto;
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.bracketScore{
  flex:0 0 auto;
  margin-left:auto; /* håll åt höger men nära pga smal ruta */
}


/* bracketLines inside inner v80 */
#playoffsBracketInner{ position:relative; }
#playoffsBracketSvg.bracketLines{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }

/* Player modal: close button bottom-right (mobile friendly) */
.modalCloseBottom{
  position: sticky;
  bottom: 12px;
  display: flex;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 8px;
}

/* ===== Steg 5: Modal för "Ny spelare" ===== */
.modalOverlay{
  position:fixed; inset:0;
  background:rgba(10,20,35,.45);
  display:flex; align-items:center; justify-content:center;
  padding:16px;
  z-index:100010;
}
.modalOverlay.hidden{ display:none !important; }
.modalSheet{
  width:min(560px, 100%);
  background:#fff;
  border-radius:18px;
  box-shadow:0 18px 60px rgba(0,0,0,.22);
  border:1px solid #e9eef6;
  padding:14px 14px 16px 14px;
}

/* Multi-väljare (Spelare) */
.multiPickList{display:flex;flex-direction:column;gap:10px;margin-top:10px}
.multiPickItem{display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px solid var(--border);border-radius:14px}
.multiPickItem input{width:20px;height:20px}
.multiPickItem .name{font-weight:600}
.multiPickItem .sub{font-size:12px;color:#6b7280}
.modalHeader{
  display:flex; align-items:center; justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
}
.modalHeader h3{ margin:0; }
.modalSub{ margin:0 0 10px 0; color:#6b7280; font-size:14px; }

/* Statsimport (ChatGPT JSON) */
.statsImportCard{ margin-top:10px; padding:12px; border:1px dashed var(--border); border-radius:14px; background:rgba(255,255,255,0.03); }
.statsImportHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.statsImportTitle{ font-weight:700; }
.statsImportPanel{ margin-top:10px; }
.statsImportPanel textarea{ width:100%; min-height:120px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }

/* Slutspel: tydlig visuell signal när gruppspelet är klart */
#btnStartPlayoffs.ready{
  box-shadow: 0 0 0 3px rgba(34,197,94,0.18);
  border-color: rgba(34,197,94,0.55);
}
.statsImportStatus{ margin-top:8px; font-size:12px; color:var(--muted); }
.statsImportStatus.ok{ color:#34d399; }
.statsImportStatus.err{ color:#f87171; }


/* Knockout bracket (dynamic columns incl. kval) */
.koBracket{display:flex;gap:16px;align-items:flex-start;padding:6px;min-width:0;}
.koCol{min-width:240px;max-width:280px;display:flex;flex-direction:column;gap:12px;}
.koColTitle{font-weight:800;color:var(--ink);margin:4px 6px 2px;}
@media (max-width:600px){
  .koCol{min-width:220px;max-width:260px;}
}

    
    
    /* --- Startskärm: statisk darttavla (SVG) --- */
    .startHero{
      position: relative;
      width: 100%;
      max-width: 420px;
      height: 230px;
      margin: 12px auto 14px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .startHero .boardWrap{
      position: relative;
      width: 190px;
      height: 190px;
      filter: drop-shadow(0 10px 26px rgba(0,0,0,0.14));
    }
    .startHero svg{ width:100%; height:100%; display:block; }

    /* --- Startskärm: centrerad rubrik + statisk darttavla + startknapp längst ner --- */
    #startScreen .panel{
      display:flex;
      flex-direction:column;
    }
    #startScreen .panel > h2{
      text-align:center;
      margin-bottom:10px;
    }
    #startScreen .panel .row{
      justify-content:center;
      margin-top:auto;
    }



    /* --- Typografi: större och snyggare rubrik på startsidan --- */
    #startScreen .panel > h2{
      font-family: "Poppins", "Montserrat", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      font-size: clamp(28px, 6vw, 38px);
      letter-spacing: 0.08em;
      font-weight: 700;
      text-transform: uppercase;
      color: #0b1d3a;
      margin-bottom: 14px;
    }


    /* Topp-rubrik (app-header) lite kraftigare */
    .appHeader h1, .appHeader .title{
      font-family: "Poppins", "Montserrat", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      letter-spacing: 0.1em;
      font-weight: 700;
    }

  /* Splash */
  .splashScreen{position:fixed;inset:0;z-index:99999;background:linear-gradient(180deg,#0b2442 0%,#0a1f3a 45%,#071528 100%);display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px;overflow:hidden}
  .splashScreen.active{display:flex}
  .splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase;font-size:34px;text-shadow:0 12px 32px rgba(0,0,0,.35)}
  .splashCard{width:min(520px,86vw);background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.18);border-radius:26px;padding:24px;box-shadow:0 30px 90px rgba(0,0,0,.25);display:flex;align-items:center;justify-content:center}
  .splashHint{position:absolute;top:26px;right:18px;color:rgba(255,255,255,.70);font-size:14px}
  @media(max-width:420px){.splashTitle{font-size:26px;top:32px}.splashCard{padding:18px}}

/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>
<!-- Anti pull-to-refresh (minskar risken på mobil) -->
<style id="antiPullToRefreshStyle">

html, body { height: 100%; }
body { padding-bottom: 1px; }
html, body{ overscroll-behavior-y: none; }
/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>

<style id="avatarStyles">

html, body { height: 100%; }
body { padding-bottom: 1px; }
/* ---- Avatars (profilbilder) ---- */
.avatarBtn{display:inline-flex;align-items:center;justify-content:center;width:34px;height:34px;border-radius:999px;border:1px solid #e5e7eb;background:#f3f4f6;color:#111827;font-weight:800;flex:0 0 auto;overflow:hidden;padding:0;cursor:pointer}
.avatarBtn img{width:100%;height:100%;object-fit:cover;display:block}
.avatarBtn.small{width:28px;height:28px}
.avatarBtn.big{width:64px;height:64px}
.avatarBtn:active{transform:scale(0.98)}
.avatarReadOnly{cursor:default;pointer-events:none}
.avatarReadOnly:active{transform:none}
.avatarRow{display:flex;align-items:flex-start;gap:10px;min-width:0}
.avatarMeta{min-width:0}
#avatarOverlay{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:9999}
#avatarModal{width:min(520px,92vw);background:#fff;border-radius:18px;box-shadow:0 25px 80px rgba(0,0,0,.25);padding:14px}
#avatarModal h3{margin:0 0 8px 0}
#avatarCropWrap{display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start}
#avatarCanvasWrap{width:260px;height:260px;border-radius:16px;border:1px solid #eef1f6;background:#f8fafc;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
#avatarCanvas{width:260px;height:260px}
#avatarHint{font-size:13px}


    /* Matchmodal-titel: avatar + namn */
    .matchTitleRow{display:inline-flex;align-items:center;gap:10px;flex-wrap:wrap}
    .matchTitleName{font-weight:800}
    .matchTitleVs{opacity:.65;margin:0 2px;font-weight:700}
/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>


<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 200vh; /* gör sidan hög så Chrome kan gömma adressfältet */
  }
/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>


<style>
/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>


<style id="topbarSpacingPatch">
  /* Dynamisk luft under fast header (Android/WebView-sakert) */
  :root{ --topbar-h: 74px; }
  :root{ --bottomnav-h: 64px; }
  main{ padding-top: calc(var(--topbar-h) + 14px) !important; padding-bottom: calc(var(--bottomnav-h) + 14px) !important; }
</style>

<style id="bottomNavPatch">
  /* Ersatt hamburgermeny med fast botten-navigering */
  #btnMenu, #menuOverlay{ display:none !important; }
  .bottomNav{position:fixed;left:0;right:0;bottom:0;z-index:10050;
    background:linear-gradient(180deg,#0b1220,#111827);
    border-top:1px solid rgba(255,255,255,.14);
    padding:10px 10px 12px;
    display:flex;gap:10px;align-items:center;justify-content:flex-start;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
  }
  .bottomNav::-webkit-scrollbar{ height:6px; }
  .bottomNavBtn{flex:0 0 auto; border:1px solid rgba(255,255,255,.22);
    background:rgba(255,255,255,.08); color:#fff;
    border-radius:999px; padding:10px 12px; font-size:13px; line-height:1;
    white-space:nowrap; cursor:pointer;
  }
  .bottomNavBtn:active{ opacity:.85; }
  .bottomNavBtn.active{ background:#fff; color:#111827; border-color:#fff; font-weight:800; }
</style>

<style id="tvModeStyles">
  /* === TV-läge / turneringsvy (landscape-first) === */
  body.tvmode{ background:#070b12 !important; color:#e5e7eb; }
  body.tvmode header, body.tvmode #bottomNav{ display:none !important; }
  /* I TV-läge täcker TV-skärmen allt. Låt appMain vara kvar så match-/profil-modaler kan visas ovanpå. */
  body.tvmode #appMain.tvHiddenMain{ visibility:visible !important; }

  #tvModeScreen{ display:none; }
  #tvModeScreen.active{ display:block; }
  #tvModeScreen{
    position:fixed; inset:0; z-index:12000;
    background: radial-gradient(1200px 800px at 20% 10%, rgba(37,99,235,.18), transparent 60%),
                linear-gradient(180deg, #060a11, #0b1220);
    color:#e5e7eb;
    overflow:hidden;
  }
  .tvTopbar{
    display:flex; align-items:center; justify-content:space-between;
    padding:12px 16px;
    border-bottom:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.20);
    backdrop-filter: blur(8px);
  }
  .tvTitle{
    font-weight:900; letter-spacing:.14em; text-transform:uppercase;
    font-size:18px; line-height:1;
  }
  .tvTopActions{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
  .tvBtn{
    border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.08);
    color:#fff;
    border-radius:999px;
    padding:10px 14px;
    font-weight:800;
    cursor:pointer;
  }
  .tvBtn:active{ opacity:.85; }
  .tvBtn.primary{ background:#fff; color:#0b1220; border-color:#fff; }
  .tvGrid{
    height: calc(100vh - 58px);
    display:grid;
    grid-template-columns: 1.15fr 1fr;
    gap:12px;
    padding:12px;
  }

  /* Flex/scroll: viktigt för att listor ska kunna scrolla i TV-läget */
  .tvGrid{ height: calc(100vh - 58px); display:grid; grid-template-columns: 1.15fr 1fr; gap:12px; padding:12px; }
  .tvCol{ display:flex; flex-direction:column; min-height:0; }
  .tvCard{ display:flex; flex-direction:column; min-height:0; }
  .tvCardHeader{ flex:0 0 auto; }
  .tvScroll{ flex:1 1 auto; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch; }
  /* Gör matchrader lite kompaktare för TV */
  .tvMatchItem{ padding:8px 10px !important; }
  .tvMatchItem .t{ font-size:16px !important; }
  .tvMatchItem .m{ font-size:12px !important; }
  .tvMatchItem .t{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tvMatchItem .m{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100%; }
  .tvMatchItem .left{ min-width:0; }
  .tvSectionTitle{ font-weight:800; letter-spacing:.12em; text-transform:uppercase; font-size:12px; opacity:.9; padding:8px 10px 0 10px; }



  /* Landscape-first: mer “TV-känsla” */
  @media (orientation: landscape){
    .tvGrid{ grid-template-columns: 1.35fr 1fr; }
  }
  @media (min-width: 1100px){
    .tvGrid{ grid-template-columns: 1.55fr 1.05fr; }
  }
  .tvCol{ display:flex; flex-direction:column; gap:12px; min-width:0; }
  .tvCard{
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
    overflow:hidden;
    display:flex;
    flex-direction:column;
    min-height:0;
    box-shadow: 0 18px 70px rgba(0,0,0,.35);
  }
  .tvCardHeader{
    padding:10px 12px;
    border-bottom:1px solid rgba(255,255,255,.10);
    display:flex; align-items:baseline; justify-content:space-between; gap:10px;
  }
  .tvCardHeader .h{ font-weight:900; letter-spacing:.08em; text-transform:uppercase; font-size:12px; opacity:.92; }
  .tvCardHeader .sub{ font-size:12px; opacity:.7; white-space:nowrap; }
  .tvScroll{ flex:1 1 auto; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch; }
  .tvScroll::-webkit-scrollbar{ height:10px; width:10px; }
  .tvScroll::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.18); border-radius:12px; }
  .tvMatchList{ display:flex; flex-direction:column; gap:8px; padding:10px; }
  .tvMatch{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:8px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.05);
    cursor:pointer;
    user-select:none;
  }
  .tvMatch.played{ background: rgba(34,197,94,.10); border-color: rgba(34,197,94,.25); }
  .tvMatch:active{ transform: scale(.995); opacity:.92; }
  .tvMatchMain{ min-width:0; }
  .tvMatchTitle{ font-weight:900; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tvMatchMeta{ margin-top:3px; font-size:12px; opacity:.75; display:flex; gap:8px; flex-wrap:wrap; }
  .tvPill{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
    font-size:12px; white-space:nowrap;
  }
  .tvPill.ok{ border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); }
  .tvPill.todo{ opacity:.8; }
  .tvStandingsTbl{ width:100%; border-collapse:collapse; font-size:12.5px; }
  .tvStandingsTbl th, .tvStandingsTbl td{
    padding:7px 8px; border-bottom:1px solid rgba(255,255,255,.10); text-align:left;
  }
  .tvStandingsTbl th{ text-transform:uppercase; letter-spacing:.08em; font-size:11px; opacity:.75; }
  .tvRightStack{ display:grid; grid-template-rows: 1fr auto auto; gap:12px; min-height:0; }
  .tvActionsRow{ display:flex; gap:10px; flex-wrap:wrap; padding:10px; }
  .tvTiny{ font-size:12px; opacity:.75; }

  .tvNameBtn{
    background:transparent; border:0; padding:0; margin:0;
    color:#e5e7eb; font:inherit; font-weight:800;
    text-decoration:underline; text-underline-offset:2px; cursor:pointer;
  }
  .tvPlayoffsList{ display:flex; flex-direction:column; gap:8px; }
  .tvPoRow{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:8px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.05);
    cursor:pointer;
    user-select:none;
  }
  .tvPoRow:active{ opacity:.9; }
  .tvPoLabel{ font-weight:900; letter-spacing:.04em; text-transform:uppercase; font-size:12px; opacity:.85; }
  .tvPoNames{ font-weight:800; font-size:14px; margin-top:4px; display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
  .tvVs{ opacity:.6; font-weight:700; }
  .tvNameBtn2{
    background:transparent; border:0; padding:0; margin:0;
    color:#e5e7eb; font:inherit; font-weight:900;
    text-decoration:underline; text-underline-offset:2px; cursor:pointer;
  }
  .tvPoStatus{
    flex:0 0 auto;
    font-size:12px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    white-space:nowrap;
  }
  .tvPoStatus.ok{ border-color: rgba(34,197,94,.45); background: rgba(34,197,94,.12); }
  .tvPoStatus.todo{ border-color: rgba(255,255,255,.14); opacity:.85; }
  .tvMuted{ opacity:.75; font-size:13px; }
</style>

<style id="modernDartThemePatch">
  /* === Modern dart/pub tema (ljust + rött/grönt från darttavlan) === */
  :root{
    --bg:#f4f6f8;            /* ljus neutral bas */
    --card:#ffffff;
    --ink:#111827;
    --muted:#6b7280;
    --border: rgba(17,24,39,.10);

    --brandGreen:#15803d;    /* dart-grön */
    --brandRed:#b91c1c;      /* dart-röd */

    --primary:var(--brandGreen);
    --primary-ink:#ffffff;
    --accent:var(--brandGreen);
    --accent2:var(--brandRed);

    --ok:var(--brandGreen);
    --warn:#b45309;
    --danger:var(--brandRed);
  }

  /* Ljusare blå header (behåller identitet, lite mindre mörk) */
  header{ background:linear-gradient(180deg,#0f2442 0%, #0c213d 55%, #081a31 100%) !important; }


  body{ background:var(--bg) !important; color:var(--ink) !important;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                     Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif !important; }

  /* Header: ljusare, pub-känsla men fortfarande tydlig */
  header{
    background: linear-gradient(180deg, #0b1220 0%, #111827 100%) !important;
  }
  header h1{ letter-spacing:.10em !important; }

  /* Cards: mindre “kantiga”, mer luft + mjuk skugga */
  .card{
    border: 1px solid var(--border) !important;
    border-radius: 16px !important;
    box-shadow: 0 10px 30px rgba(17,24,39,.06) !important;
  }

  /* Inputs: modernare fokusfärg (röd accent) */
  input, select, textarea{
    border-color: rgba(17,24,39,.12) !important;
    border-radius: 14px !important;
  }
  input:focus, select:focus, textarea:focus{
    border-color: rgba(21,128,61,.45) !important;
    box-shadow: 0 0 0 4px rgba(21,128,61,.14) !important;
  }

  /* Buttons */
  .btn{
    background: var(--primary) !important;
    color: var(--primary-ink) !important;
    border-radius: 14px !important;
    box-shadow: 0 12px 26px rgba(21,128,61,.16) !important;
    font-weight: 700 !important;
    display:inline-flex !important;
    align-items:center !important;
    justify-content:center !important;
    gap:8px !important;
    line-height:1.15 !important;
    letter-spacing:0 !important;
    text-transform:none !important;
    text-align:center !important;
    white-space:normal !important;
    word-break:break-word !important;
    padding:12px 14px !important;
    min-height:44px !important;
  }
  .btn:hover{ filter:brightness(.98) !important; }
  .btn.secondary{
    background:#fff !important;
    color:var(--ink) !important;
    border:1px solid rgba(17,24,39,.14) !important;
    box-shadow: 0 10px 24px rgba(17,24,39,.06) !important;
  }
  .btn.danger{
    background:#fff !important;
    color: var(--danger) !important;
    border:1px solid rgba(185,28,28,.30) !important;
    box-shadow: 0 10px 24px rgba(21,128,61,.10) !important;
  }

  /* Pills / tags */
  .pill{
    border-color: rgba(21,128,61,.28) !important;
    background: rgba(21,128,61,.07) !important;
    color: #334155 !important;
  }
  .pill strong{ color: var(--primary) !important; }
  .tag.ok{
    border-color: rgba(21,128,61,.25) !important;
    color: var(--ok) !important;
    background: rgba(21,128,61,.08) !important;
  }
  .tag.todo{
    border-color: rgba(17,24,39,.14) !important;
    background: rgba(17,24,39,.03) !important;
  }

  /* Tables: lite modernare läsbarhet */
  table{ border-radius: 14px !important; overflow:hidden; }
  thead th{
    background: rgba(17,24,39,.04) !important;
    color: rgba(17,24,39,.70) !important;
  }
  tbody tr:nth-child(even){
    background: rgba(17,24,39,.02) !important;
  }

  /* Kval/vidare-rad: grön ton (dart-grön) */
  .qual, .qual td{ background: rgba(21,128,61,.08) !important; }
  .qual td:first-child{ font-weight: 900 !important; }

  /* Länkar */
  .link{ color: var(--primary) !important; }

  /* Bottom nav: active = röd (dart) */
  .bottomNavBtn.active{
    background:#fff !important;
    color:#111827 !important;
    border-color:#fff !important;
  }
  .bottomNavBtn.active::after{
    content:"";
    display:inline-block;
    width:8px; height:8px;
    border-radius:999px;
    background: var(--accent2);
    margin-left:8px;
    vertical-align:middle;
  }

  /* Matchrader: lite mjukare hover/active */
  .matchRow:hover{ background: rgba(17,24,39,.03); }
  .matchRow:active{ background: rgba(185,28,28,.06); }

  /* Behåll TV-läget som det är (egna färger) */
  body.tvmode .btn, body.tvmode .card, body.tvmode input, body.tvmode select, body.tvmode textarea{
    box-shadow:none !important;
  }
</style>

</head>
<body>
<div aria-hidden="true" id="focusSink" style="position:fixed;left:-10000px;top:0;width:1px;height:1px;opacity:0;" tabindex="-1"></div>
<!-- Start overlay (fortsätt/ny/import) -->
<div class="hidden" id="startGate" style="position:fixed;inset:0;background:rgba(0,0,0,0.45);z-index:9999;display:flex;align-items:center;justify-content:center;padding:16px">
<div style="max-width:520px;width:100%;background:var(--card);border:1px solid var(--border);border-radius:18px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,0.2)">
<h3 style="margin:0 0 6px 0">Fortsätt turnering?</h3>
<div class="small">Det finns en sparad turnering på den här enheten.</div>
<div class="btnbar" style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
<button class="btn" onclick="autosaveStartGateContinue()">Fortsätt</button>
<button class="btn secondary" onclick="autosaveStartGateNew()">Ny turnering</button>
<label class="btn secondary" style="cursor:pointer">Ladda turnering från fil</label></div>
<div class="hint" style="margin-top:12px">Tips: Exportera turneringen när ni är klara för att arkivera eller flytta den.</div>
</div>
</div>
<header>
  <button class="hamburger" id="btnMenu" type="button" onclick="toggleMenu(event)">☰</button>
  <h1>Dart-turnering</h1>
</header>

<div class="menuOverlay hidden" id="menuOverlay" onclick="closeMenu()">
  <div class="menuPanel" onclick="stopPropagation(event)">
    <div class="small muted" style="margin:2px 2px 10px 2px">Meny</div>
    <div class="stepper" id="menuStepper"></div>
</div>
</div>

<main id="appMain"><div class="row" style="justify-content:flex-end; margin-bottom:10px"><span class="pill" id="progressPill"><strong>0</strong> / 0 klara</span></div>
<!-- STEP 1: format -->
<section class="card" id="step1">
<h2 style="margin:0">Välj upplägg</h2>
<label>Tävlingsform</label><select id="mode"><option selected="" value="single">Singel</option><option value="team">Lag (2-mot-2)</option></select>
<label>Spelform</label><select id="format" onchange="onFormatChange()">
<option value="knockout">Slutspel</option>
<option value="round_robin">Alla möter alla (serie)</option>
<option value="round_robin_playoffs">Alla möter alla (serie) + slutspel</option>
<option value="group_only">Gruppspel</option>
<option value="group_playoffs">Gruppspel + slutspel</option>
</select>
<div id="numGroupsWrap" style="display:none">
<label>Antal grupper</label><select id="numGroups">
<option value="2" selected>2 grupper</option>
<option value="4">4 grupper</option>
</select>
</div>

<label>Hur många gånger möts spelarna?</label><select id="repeat">
<option value="1">1 gång</option>
<option value="2">2 gånger</option>
<option value="3">3 gånger</option>
</select>


<div class="card hidden" id="groupQualifyCard" style="margin-top:14px;box-shadow:none">
  <div class="row between" style="align-items:center;gap:12px;flex-wrap:wrap">
    <div>
      <div style="font-weight:700">Vidare till slutspel</div>
      <div class="hint" style="margin:4px 0 0 0">Standard är topp 2 per grupp. Välj <b>Alla</b> om du vill att alla ska gå vidare (då kan kval/BYE uppstå).</div>
    </div>
    <select id="groupQualifySelect" onchange="onGroupQualifyChange()" style="min-width:180px">
      <option value="top2">Topp 2 per grupp</option>
      <option value="all">Alla</option>
    </select>
  </div>
</div>

<div class="btnbar">
<button class="btn secondary" type="button" onclick="openFormatLegend()">Uppläggsförklaring</button>
<button class="btn" onclick="goStep(2)">Nästa</button>
</div>
</section>
<!-- STEP 2: game -->
<section class="card hidden" id="step2">
<h2>Välj spel</h2>
<div class="split">
<div>
<label>Spel</label><select id="game">
<option value="301">301</option>
<option value="501">501</option>
</select>
</div>
<div>
<label>Ingång</label><select id="inRule">
<option value="single">Enkel in</option>
<option value="double">Dubbel in</option>
</select>
</div>
<div>
<label>Utgång</label><select id="outRule">
<option value="single">Enkel ut</option>
<option value="double">Dubbel ut</option>
</select>
</div>
<div>
<label>Matchformat (legs)</label><select id="legsMode">
<option value="single" selected>1 leg</option>
<option value="bo3">Bäst av 3 legs (först till 2)</option>
</select>
<div class="hint"><strong>Leg</strong> = en omgång. <strong>Set</strong> = flera leg (används inte här ännu).</div>

<div class="card" style="margin-top:12px" id="seriesCreateCard">
  <div style="display:flex;gap:10px;align-items:flex-start">
    <input id="isSeriesEvent" type="checkbox" style="margin-top:4px">
    <div style="flex:1">
      <div style="font-weight:800">Deltävling i serie</div>
      <div class="small" style="margin-top:4px">Visar extra fält för bullseye på matcherna och sparar statistiken i exporten.</div>
    </div>
  </div>
  <div id="seriesNameWrap" style="margin-top:10px;display:none">
    <label>Seriens namn (valfritt)</label>
    <input id="seriesName" placeholder="t.ex. Pulsi Open 2026">
  </div>
</div>
</div>
</div>
<div class="btnbar">
<button class="btn secondary" onclick="goStep(1)">Tillbaka</button>
<button class="btn" onclick="goStep(3)">Nästa</button>
</div>
</section>
<!-- STEP 3: players -->
<section class="card hidden" id="step3">
<h2>Spelare</h2>
<div id="importPlayersFromTournamentBar" class="card" style="box-shadow:none;border:1px solid #eef1f6;margin:10px 0 12px 0;display:none">
  <div class="row" style="align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
    <div>
      <div style="font-weight:700">Importera spelare från turneringen</div>
      <div class="small muted">Lägg till spelarna från den importerade turneringen i listan över sparade spelare.</div>
    </div>
    <button class="btn primary" type="button" onclick="addImportedPlayersToSaved()">Lägg till spelare i lista</button>
  </div>
</div>
<div class="hint"></div>
<!-- Tidigare fanns en knapp för "Lägg till en i taget" här. Vi kör alltid kiosk-läge nu. -->
<div id="entryKioskWrap">
<div class="card" style="box-shadow:none;border:1px solid #eef1f6;margin-bottom:12px">
<h3 id="kioskTitle" style="margin-top:0">Lägg till spelare</h3>
<div id="kioskSingleForm">
<div id="savedSingleWrap" style="margin:10px 0 6px 0">
<label>Välj sparad spelare</label>
<div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
<select id="savedPlayerSelect" style="flex:1;min-width:220px" onchange="savedAutoAddFromSelect('single')"></select>
<button class="btn secondary" id="btnMultiPickPlayers" onclick="openSavedMultiPicker('single')" type="button">Välj flera…</button>
        <button class="btn secondary" id="btnNewPlayer" onclick="openNewOrEditPlayerModal('single')" type="button">Ny / Ändra</button>
<button class="btn danger secondary" id="btnDeleteProfileTop" onclick="savedDelete('single')" type="button">Ta bort vald profil</button>
</div>

</div>
<div class="card" style="box-shadow:none;border:1px solid #eef1f6">
<h3 style="margin-top:0">Tillagda</h3>
<div id="kioskList"></div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn primary" id="btnKioskCreateTournament" onclick="createTournament()" style="min-width:220px" type="button">Skapa turnering</button>
</div>
</div>
</div>
<div id="kioskSingleFields" class="hidden">
<label>Namn</label><input id="kName" placeholder="Skriv ditt namn"/>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn secondary" id="btnOpenSpotify" onclick="openSpotify()" type="button">🎵 Öppna Spotify</button>
</div>
<label style="margin-top:10px">Spotify-länk (valfritt)</label><input id="kSpotify" placeholder="Klistra in Spotify-länk"/>
<label style="margin-top:10px">Pilar (valfritt)</label>
<input id="kDarts" placeholder="Ex: Winmau 22g"/>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn secondary" type="button" onclick="closeNewPlayerModal()">Stäng</button>
<button class="btn secondary" onclick="modalKioskAddSingle()" type="button">Spara</button>
</div>
</div>
</div>

<div id="kioskTeamFields" class="hidden">
  <label>Lagnamn</label><input id="kTeamName" placeholder="T.ex. Team Rocket"/>
  <div class="grid2" style="margin-top:10px">
    <div>
      <label>Spelare 1</label>
      <input id="kTeamP1" list="singlePlayersList" placeholder="Välj eller skriv namn"/>
    </div>
    <div>
      <label>Spelare 2</label>
      <input id="kTeamP2" list="singlePlayersList" placeholder="Välj eller skriv namn"/>
    </div>
  </div>
  <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
    <button class="btn secondary" id="btnOpenSpotifyTeam" onclick="openSpotify()" type="button">🎵 Öppna Spotify</button>
  </div>
  <label style="margin-top:10px">Lagets Spotify-länk (valfritt)</label><input id="kTeamSpotify" placeholder="Klistra in Spotify-länk"/>
  <label style="margin-top:10px">Lagets pilar (valfritt)</label>
  <input id="kTeamDarts" placeholder="Ex: 24g"/>
  <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
    <button class="btn secondary" onclick="modalKioskAddTeam()" type="button">Spara</button>
  </div>
</div>

<datalist id="singlePlayersList"></datalist>

<div class="hidden" id="kioskTeamForm">
  <div id="savedTeamWrap" style="margin:10px 0 6px 0">
    <label>Välj sparat lag</label>
    <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
      <select id="savedTeamSelect" style="flex:1;min-width:220px" onchange="savedAutoAddFromSelect('team')"></select>
      <button class="btn secondary" id="btnNewTeam" onclick="openNewPlayerModal('team')" type="button">Ny / Ändra</button>
      <button class="btn danger secondary" id="btnDeleteTeamTop" onclick="savedDelete('team')" type="button">Ta bort vald profil</button>
    </div>
  </div>

  <div class="card" style="box-shadow:none;border:1px solid #eef1f6">
    <h3 style="margin-top:0">Tillagda</h3>
    <div id="kioskTeamList"></div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
      <button class="btn primary" id="btnKioskCreateTournamentTeam" onclick="createTournament()" style="min-width:220px" type="button">Skapa turnering</button>
    </div>
  </div>
</div>

<div class="hidden" id="teamFieldsWrap">
<h3 style="margin-top:14px">Lag (2-mot-2)</h3>
<label>Lagnamn (en per rad)</label>
<textarea id="teamNames" placeholder="Team Rocket
Team Viking" rows="5"></textarea>
<div class="grid2">
<div>
<label>Spelare 1 (en per rad)</label>
<textarea id="teamMember1" placeholder="Kalle
Anna" rows="5"></textarea>
</div>
<div>
<label>Spelare 2 (en per rad)</label>
<textarea id="teamMember2" placeholder="Per
Lisa" rows="5"></textarea>
</div>
</div>
<label style="margin-top:10px">Lagets Spotify-länk (valfritt, en per lag)</label>
<textarea id="teamSpotify" placeholder="https://open.spotify.com/track/..." rows="4"></textarea>
<label style="margin-top:10px">Lagets pilar (valfritt, en per lag)</label>
<textarea id="teamDarts" placeholder="24g" rows="3"></textarea>
</div>
<!-- Manuell-läge -->
<div id="manualPlayersWrap">
<div id="legacyImportWrap" style="display:none">
<div class="card" style="box-shadow:none;border:1px solid #eef1f6;margin-bottom:12px">
<h3 style="margin-top:0">Snabbimport (klistra in från Excel/Sheets)</h3>
<textarea id="bulkPaste" placeholder="1\tPer\tSeven Nation Army – The White Stripes\thttps://open.spotify.com/track/...\t23g\n0\tKalle\t\t\t\n1\tJenny\tFreed From Desire – Gala\thttps://open.spotify.com/track/...\t22g" rows="6"></textarea>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
<button class="btn" id="btnBulkParse" onclick="bulkParse()" type="button">Fördela i fälten</button>
<button class="btn" id="btnBulkClear" onclick="bulkClear()" style="background:#f4f6fb;color:#0f172a" type="button">Rensa</button>
<div class="muted" id="bulkStatus" style="align-self:center"></div>
</div>
</div>
<label>Spelarnamn (en per rad)</label><textarea id="players" placeholder="Spelare 1
Spelare 2
Spelare 3" rows="8"></textarea>
<h3 style="margin-top:14px">Walk-on (visningsnamn) – valfritt</h3>
<div class="hint">
    En rad per spelare (i samma ordning). Här skriver du bara vilket namn du vill visa i matchen.
  </div>
<textarea id="walkonLabels" placeholder="(valfritt)
Låttitel – Artist" rows="5"></textarea>
<h3 style="margin-top:14px">Spotify-länk – valfritt</h3>
<div class="hint">
    En rad per spelare (i samma ordning). Klistra in en Spotify-länk (t.ex. från Spotify → Dela → Kopiera länk).
  </div>
<textarea id="spotifyLinks" placeholder="(valfritt)
https://open.spotify.com/track/..." rows="5"></textarea>
<h3 style="margin-top:14px">Pilar – valfritt</h3>
<div class="hint">
    En rad per spelare (i samma ordning). Ex: <em>Winmau 22g</em>
</div>
<textarea id="darts" placeholder="(valfritt)
Winmau 22g" rows="4"></textarea>
</div>
<div class="hint"><span id="minParticipantsText">Minst 3 spelare.</span> För gruppspel blir 7 spelare perfekt (4+3).</div>
<div class="btnbar" style="margin-top:14px">
<button class="btn secondary" id="step3BackBtn" onclick="goStep(2)" type="button">Tillbaka</button>
<button class="btn primary" id="step3CreateBtn" onclick="createTournament()" type="button">Skapa turnering</button>
</div>

</div>
</div></div></section>
<!-- STEP 4: groups approval -->
<section class="card hidden" id="step4">
<h2>Grupper</h2>

<div class="grid2">
<div class="card" style="box-shadow:none">
<h3>Grupp A</h3>
<div id="groupAList"></div>
</div>
<div class="card" style="box-shadow:none">
<h3>Grupp B</h3>
<div id="groupBList"></div>
</div>
</div>
<div class="card groupCD hidden" style="box-shadow:none">
<h3>Grupp C</h3>
<div id="groupCList"></div>
</div>
<div class="card groupCD hidden" style="box-shadow:none">
<h3>Grupp D</h3>
<div id="groupDList"></div>
</div>

<div class="btnbar">
<button class="btn secondary" onclick="goStep(3)">Tillbaka</button>
<button class="btn secondary" onclick="reshuffleGroups()">Slumpa om</button>
<button class="btn" onclick="confirmGroups()">Godkänn grupper</button>
</div>
</section>
<!-- STEP 5: overview -->
<section class="hidden" id="stepMatches">
<div class="card">
<div class="row between" style="align-items:center;gap:10px;">
<div>
<h2 style="margin:0">Matchschema</h2>
<div class="datestamp" id="uiDateMatches"></div>
</div>
<span class="pill" id="rulesPill"></span>
</div>
<div class="hint">Tryck på en match för att registrera vinnare, legs-resultat och averages.</div>
<table id="matchesTable"></table>
</div>
</section>
<section class="hidden" id="stepTable">
<div class="card">
<div class="row between" style="align-items:center;gap:10px;">
<div>
<h2 style="margin:0">Tabell</h2>
<div class="datestamp" id="uiDateTable"></div>
</div>
<span class="pill" id="rulesPillTable"></span>
</div>
<div id="standingsWrap"></div>
<div class="row" style="justify-content:flex-end;margin-top:10px">
  <button class="btn secondary" type="button" onclick="openTableLegend()">Tabellförklaring</button>
</div>
</div>
</section><section class="card hidden" id="stepTools"><h2>Verktyg</h2><div class="hint">Export, import, PDF och nollställning.</div><div class="row" style="gap:8px; flex-wrap:wrap"><button class="btn secondary" onclick="autosaveExportTournament()">Exportera turnering</button><label class="btn secondary" style="cursor:pointer">Importera turnering <input accept="application/json,.json" hidden="" id="importJson" onchange="autosaveHandleImportJsonFile(this.files[0]); this.value='';" type="file"/></label><button class="btn secondary" onclick="exportPDF()">Exportera (PDF)</button><button class="btn danger" onclick="resetAll()">Nollställ</button></div>

</section>
<!-- STEP 6: playoffs -->
<section class="card hidden" id="stepPlayoffs">
<div class="row" style="align-items:center;justify-content:space-between">
<div class="titleblock"><h2 style="margin:0">Slutspel</h2><div class="datestamp" id="uiDatePlayoffs"></div></div>
<div class="row" style="align-items:center;gap:10px;justify-content:flex-end;flex-wrap:wrap">
<span class="pill" id="playoffsPill" style="display:none"></span>
<button class="btn secondary" onclick="autosaveExportTournament()" type="button">Exportera turnering</button>
<button class="btn" id="btnStartPlayoffs" onclick="startPlayoffsFromCurrent()" type="button">Starta slutspel</button>
<button class="btn secondary" id="btnUndoPlayoffs" onclick="undoPlayoffsStart()" type="button" style="display:none">Dra tillbaka slutspel</button>
<button class="btn secondary" id="btnShuffleKnockout" onclick="reshuffleKnockout()" type="button" style="display:none">Slumpa om slutspel</button>
<button class="btn secondary" id="btnPlayoffsBracketToggle" onclick="togglePlayoffBracket()" type="button">Visa slutspelsträd</button>
</div>
</div>

<div id="seriesPlayoffsActivateCard" class="card hidden" style="margin-top:12px;box-shadow:none">
  <div style="font-weight:800">Aktivera slutspel</div>
  <div class="hint" style="margin-top:6px">Välj hur många som går vidare från serien. (Alla innebär att alla kan få kval/BYE beroende på antal.)</div>
  <div class="row" style="margin-top:10px;align-items:center;gap:10px">
    <select id="seriesQualifySelect" style="min-width:180px"></select>
    <button type="button" class="btn" id="btnEnableSeriesPlayoffs" onclick="enableSeriesPlayoffs()">Aktivera</button>
    <button type="button" class="btn secondary" id="btnDisableSeriesPlayoffs" onclick="disableSeriesPlayoffs()" style="display:none">Ångra</button>
  </div>
</div>
<div id="playoffsScheduleView">
<div class="hint" id="playoffsHint">Semifinaler: A1 vs B2 och B1 vs A2. Vinnarna möts i final.</div>
<div class="card exportHide" style="margin-top:12px"><div id="tourneySummary"></div></div>
<table id="playoffsTable"></table>
</div>
<div class="hidden" id="playoffsBracketView" style="margin-top:12px">

<div aria-label="Snabbnavigering i slutspelsträd" class="bracketNav">
<button class="btn secondary bracketNavBtn hidden" id="btnBracketQual" onclick="scrollPlayoffsBracket('qual')" type="button">Kval</button>
<button class="btn secondary bracketNavBtn" disabled="" onclick="scrollPlayoffsBracket('qf')" type="button">Kvartsfinal</button>
<button class="btn secondary bracketNavBtn" onclick="scrollPlayoffsBracket('sf')" type="button">Semifinal</button>
<button class="btn secondary bracketNavBtn" onclick="scrollPlayoffsBracket('final')" type="button">Final</button>
</div>
<div aria-label="Slutspelsträd" id="playoffsBracket">
<div id="playoffsBracketViewport">
<div id="playoffsBracketInner">
<svg class="bracketLines" id="playoffsBracketSvg" xmlns="http://www.w3.org/2000/svg"></svg>
<div id="playoffsBracketContent">
  <!-- Förberedd struktur (kan vara tom initialt). JS fyller i namn/resultat när data finns. -->
  <div class="bracketGrid4">
    
<div class="bracketCell qual hidden">
  <div class="bracketMatchBox" data-po-id="po_k1"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k2"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k3"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k4"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k5"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k6"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
  <div class="bracketMatchBox" data-po-id="po_k7"><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
</div>

<div class="bracketCell qf groupCD hidden">
      <div class="bracketMatchBox" data-po-id="po_qf1"><div class="bracketTitle">Kvartsfinal 1</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
      <div class="bracketMatchBox" data-po-id="po_qf2"><div class="bracketTitle">Kvartsfinal 2</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
      <div class="bracketMatchBox" data-po-id="po_qf3"><div class="bracketTitle">Kvartsfinal 3</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
      <div class="bracketMatchBox" data-po-id="po_qf4"><div class="bracketTitle">Kvartsfinal 4</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
    </div>

    <div class="bracketCell sf1">
      <div class="bracketMatchBox" data-po-id="po_sf1"><div class="bracketTitle">Semifinal 1</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
    </div>
    <div class="bracketCell sf2">
      <div class="bracketMatchBox" data-po-id="po_sf2"><div class="bracketTitle">Semifinal 2</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
    </div>

    <div class="bracketCell final">
      <div class="finalWrap">
        <div class="bracketMatchBox" data-po-id="po_f"><div class="bracketTitle">Final</div><div class="bracketBody"><div class="bracketRow"><div class="mutedName">—</div></div><div class="bracketRow"><div class="mutedName">—</div></div></div></div>
        <div class="winnerBox"><div class="trophyCircle" title="Vinnare">🏆</div><div class="winnerText"><div class="winnerLabel">Vinnare av turneringen</div><div class="winnerValue">—</div></div></div>
      </div>
    </div>
  </div>
</div>
</div>
</div>
</div>
<div class="btnbar">
<button class="btn secondary" onclick="goStep(getStepNums().table)">Tillbaka</button>
</div>
</div></section>

<!-- Format legend modal -->
<div class="overlay hidden" id="overlayFormatLegend" onclick="closeFormatLegend()">
  <div class="modal" id="formatLegendModal" onclick="stopPropagation(event)" style="max-width:620px">
    <div class="top">
      <div>
        <h2 style="margin:0">Uppläggsförklaring</h2>
        <div class="small muted">Vad spelformerna betyder just nu i appen</div>
      </div>
      <button class="btn secondary" type="button" onclick="closeFormatLegend()">Stäng</button>
    </div>
    <div id="formatLegendBody" class="small" style="margin-top:10px; line-height:1.35"></div>
  </div>
</div>

<!-- Table legend modal -->
<div class="overlay hidden" id="overlayTableLegend" onclick="closeTableLegend()">
  <div class="modal" id="tableLegendModal" onclick="stopPropagation(event)" style="max-width:520px">
    <div class="top">
      <div>
        <h2 style="margin:0">Tabellförklaring</h2>
        <div class="small muted">Poängsystem och förkortningar</div>
      </div>
      <button class="btn secondary" type="button" onclick="closeTableLegend()">Stäng</button>
    </div>
    <div id="tableLegendBody" class="small" style="margin-top:10px; line-height:1.35"></div>
  </div>
</div>

<!-- Multi-väljare: välj flera sparade spelare -->
<div class="overlay hidden" id="overlayMultiPick" onclick="closeSavedMultiPicker(true)">
  <div class="modal" id="multiPickModal" onclick="stopPropagation(event)" style="max-width:520px">
    <div class="top">
      <div>
        <h2 style="margin:0">Välj flera spelare</h2>
        <div class="small muted">Markera flera och tryck utanför rutan (eller "Klar")</div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
        <button class="btn secondary" type="button" onclick="closeSavedMultiPicker(false)">Avbryt</button>
        <button class="btn" type="button" onclick="closeSavedMultiPicker(true)">Klar</button>
      </div>
    </div>
    <div id="multiPickList" class="multiPickList"></div>
  </div>
</div>

<!-- Modal -->
<div class="overlay hidden" id="overlay" onclick="closeModal()">
<div class="modal" id="matchModal" onclick="stopPropagation(event)">
<div class="top">
<div>
<h2 id="modalTitle">Match</h2>
<div class="small" id="modalMeta"></div>
<div class="lockedBanner hidden" id="lockedBanner">
<div><strong>Match sparad</strong> – redigering är låst för att undvika misstag.</div>
<div class="btnbar" style="margin-top:8px">
<button class="btn secondary" onclick="enableEdit()">Redigera</button>
</div>
</div>
<div class="hint" id="walkonInfo" style="margin-top:6px"></div>
</div>
<div class="topActions"><button class="btn" onclick="saveMatch()">Spara</button><button class="btn secondary" onclick="clearMatch()">Rensa</button><button class="btn secondary" id="swapSidesBtn" onclick="toggleSides()">Byt sida</button><button class="x" onclick="closeModal()">✕</button></div>
</div>
<div class="winBtns">
<button class="winBtn" id="winA" onclick="pickWinner('A')">Vinnare: A</button>
<button class="winBtn" id="winB" onclick="pickWinner('B')">Vinnare: B</button>
</div>
<div class="btnbar" id="resultButtons" style="margin-top:10px"></div>
<div class="hint" id="resultHint" style="margin-top:6px"></div>
<div class="split" id="avgSplit" style="margin-top:10px">
<div>
<label class="statRow" id="avgALabel">Average (A) <strong><span id="avgAVal">70.0</span></strong></label><div class="sliderWrap">
  <div class="sliderBox">
  <div class="sliderLine">
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('avgA',-getRangeStep('avgA'))">−</button>
    <input id="avgA" max="120" min="20" oninput="setStatVal('avgA','avgAVal',1)" step="0.1" type="range" value="70.0"/>
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('avgA',getRangeStep('avgA'))">+</button>
  </div>
  <div class="sliderBubble" id="avgABubble">–</div>
</div>
</div>
</div>
<div>
<label class="statRow" id="avgBLabel">Average (B) <strong><span id="avgBVal">70.0</span></strong></label><div class="sliderWrap">
  <div class="sliderBox">
  <div class="sliderLine">
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('avgB',-getRangeStep('avgB'))">−</button>
    <input id="avgB" max="120" min="20" oninput="setStatVal('avgB','avgBVal',1)" step="0.1" type="range" value="70.0"/>
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('avgB',getRangeStep('avgB'))">+</button>
  </div>
  <div class="sliderBubble" id="avgBBubble">–</div>
</div>
</div>
</div>
</div>
<div class="split">
<div>
<div class="split" id="f9Split" style="margin-top:10px">
<div>
<label class="statRow" id="f9ALabel" title="Snittpoäng under första 9 pilarna">First 9 (A) <strong><span id="f9AVal">70.0</span></strong></label><div class="sliderWrap">
  <div class="sliderBox">
  <div class="sliderLine">
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('f9A',-getRangeStep('f9A'))">−</button>
    <input id="f9A" max="140" min="20" oninput="setStatVal('f9A','f9AVal',1)" step="0.1" type="range" value="70.0"/>
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('f9A',getRangeStep('f9A'))">+</button>
  </div>
  <div class="sliderBubble" id="f9ABubble">–</div>
</div>
</div>
</div>
<div>
<label class="statRow" id="f9BLabel" title="Snittpoäng under första 9 pilarna">First 9 (B) <strong><span id="f9BVal">70.0</span></strong></label><div class="sliderWrap">
  <div class="sliderBox">
  <div class="sliderLine">
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('f9B',-getRangeStep('f9B'))">−</button>
    <input id="f9B" max="140" min="20" oninput="setStatVal('f9B','f9BVal',1)" step="0.1" type="range" value="70.0"/>
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('f9B',getRangeStep('f9B'))">+</button>
  </div>
  <div class="sliderBubble" id="f9BBubble">–</div>
</div>
</div>
</div>
</div>
<div class="split" id="coSplit">
<div>
<label class="statRow" id="coALabel" title="Andel lyckade utgångar (%)">Utgång % (A) <strong><span id="coAVal">0.0%</span></strong></label><div class="sliderWrap">
  <div class="sliderBox">
  <div class="sliderLine">
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('coA',-getRangeStep('coA'))">−</button>
    <input id="coA" data-unit="pct"  max="100" min="0" oninput="setStatVal('coA','coAVal',1)" step="0.1" type="range" value="0.0"/>
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('coA',getRangeStep('coA'))">+</button>
  </div>
  <div class="sliderBubble" id="coABubble">–</div>
</div>
</div>
</div>
<div>
<label class="statRow" id="coBLabel" title="Andel lyckade utgångar (%)">Utgång % (B) <strong><span id="coBVal">0.0%</span></strong></label><div class="sliderWrap">
  <div class="sliderBox">
  <div class="sliderLine">
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('coB',-getRangeStep('coB'))">−</button>
    <input id="coB" data-unit="pct"  max="100" min="0" oninput="setStatVal('coB','coBVal',1)" step="0.1" type="range" value="0.0"/>
    <button type="button" class="sliderNudgeBtn" onclick="nudgeRange('coB',getRangeStep('coB'))">+</button>
  </div>
  <div class="sliderBubble" id="coBBubble">–</div>
</div>
</div>
</div>
</div>
<div class="hint" id="outOverrideWrap" style="margin-top:10px">
<label style="display:flex;gap:10px;align-items:center">
<input id="outOverrideDouble" type="checkbox">
<span>Den här matchen spelades med <strong>dubbel utgång</strong></span>
</input></label>
<div class="hint" style="margin-top:6px">Använd om ni avviker från turneringens inställning för utgång.</div>
</div>
<div id="seriesBonusWrap" class="card hidden" style="margin-top:12px;box-shadow:none;border:1px solid #eef1f6">
  <strong>Bullseye</strong>
  <div class="grid2" style="margin-top:10px">
    <div>
      <div style="font-weight:700;margin-bottom:6px" id="seriesBonusLabelA">Spelare A</div>
      <label style="display:block">Bullseye</label>
      <div class="row" style="gap:8px;align-items:center">
        <button type="button" class="btn secondary" onclick="nudgeNumber('bullsA',-1)">−</button>
        <input id="bullsA" type="number" inputmode="numeric" min="0" step="1" value="0" style="max-width:90px">
        <button type="button" class="btn secondary" onclick="nudgeNumber('bullsA',1)">+</button>
      </div>
    </div>
    <div>
      <div style="font-weight:700;margin-bottom:6px" id="seriesBonusLabelB">Spelare B</div>
      <label style="display:block">Bullseye</label>
      <div class="row" style="gap:8px;align-items:center">
        <button type="button" class="btn secondary" onclick="nudgeNumber('bullsB',-1)">−</button>
        <input id="bullsB" type="number" inputmode="numeric" min="0" step="1" value="0" style="max-width:90px">
        <button type="button" class="btn secondary" onclick="nudgeNumber('bullsB',1)">+</button>
      </div>
    </div>
  </div>
</div>
<label>Anteckningar (valfritt)</label><input id="notes" placeholder="t.ex. grym match...">
</input></div>
</div>
<div class="btnbar">
<button class="btn secondary" onclick="closeModal()">Stäng</button>
</div>
</div>
</div>
</main>
<!-- Player modal -->
<div class="overlay hidden" id="playerOverlay" onclick="closePlayerModal()">
<div class="modal" onclick="stopPropagation(event)">
<div class="row" style="justify-content:space-between;align-items:flex-start">
<div>
<div class="playerHeader"><button type="button" class="playerAvatar avatarBtn big" id="playerAvatarBtn" data-avatar-pid="" data-avatar-name=""><span id="playerAvatarInitials"></span><img alt="" style="display:none"></button><h3 id="playerTitle" style="margin:0">Spelare</h3></div>
<div class="small" id="playerSubtitle"></div>
</div>
</div>
<div id="playerBody" style="margin-top:12px"></div>
<div class="modalCloseBottom"></div>
<!-- History modal -->
<div class="overlay hidden" id="historyOverlay" onclick="closeHistoryModal()">
<div class="modal" onclick="stopPropagation(event)">
<div class="row" style="justify-content:space-between;align-items:flex-start">
<div>
<h3 id="historyTitle" style="margin:0">Historik</h3>
<div class="small" id="historySubtitle"></div>
</div>
<button class="btn secondary" onclick="closeHistoryModal()">Stäng</button>
</div>
<div id="historyBody" style="margin-top:12px"></div>
</div>
</div>
</div>
</div>
<script>


const STORAGE_KEY = "turneringsapp_v2_2";
// Extra autospar (separat nyckel) för snabb återställning vid oavsiktlig uppdatering.
const AUTOSAVE_KEY = "turneringsapp_autosave_v1";

const HISTORY_KEY = "turneringsapp_playerhistory_v1";

function normName(s){
  return (s||"").toString().trim().toLowerCase().replace(/\s+/g," ");
}

function loadHistory(){
  try{
    var raw = _storage().getItem(HISTORY_KEY);
    if(!raw) return { players:{} };
    var obj = JSON.parse(raw);
    if(!obj || typeof obj !== "object") return { players:{} };
    if(!obj.players) obj.players = {};
    return obj;
  }catch(e){
    return { players:{} };
  }
}

function saveHistory(h){
  try{ _storage().setItem(HISTORY_KEY, JSON.stringify(h)); }catch(e){}
}

function clearHistoryForPlayer(pid){
  try{
    var title = playerName(pid) || "";
    var key = normName(title);
    if(!key) return;
    if(!confirm("Är du säker på att du vill radera historiken för " + title + "?\n\nDetta tar bort alla sparade matcher för profilen, men behåller namn, pilar och låt.")) return;
    var h = loadHistory();
    if(h && h.players && h.players[key]){ delete h.players[key]; }
    saveHistory(h || {players:{}});
    // Uppdatera öppet profilkort om det är öppet
    try{ openPlayerModal(pid); }catch(e){}
  }catch(e){}
}


function upsertHistoryMatch(pid, matchObj){
  var h = loadHistory();
  var key = normName(playerName(pid));
  if(!key) return;
  if(!h.players[key]) h.players[key] = { matches:[] };
  var arr = h.players[key].matches || (h.players[key].matches = []);
  // ta bort ev. tidigare version av samma match (om man redigerar)
  arr = arr.filter(function(x){ return x && x.matchId !== matchObj.matchId; });
  arr.push(matchObj);
  // sortera efter tid (äldst->nyast)
  arr.sort(function(a,b){
    return String(a.finishedAt||"").localeCompare(String(b.finishedAt||""));
  });
  h.players[key].matches = arr;
  saveHistory(h);
}

function computeHistorySummary(key){
  var h = loadHistory();
  var entry = h.players && h.players[key];
  var ms = (entry && entry.matches) ? entry.matches.slice() : [];
  var sum = { played:0,w:0,l:0,legsW:0,legsL:0,avg:null,f9:null,co:null,coSingle:null,coDouble:null,last:null };
  if(!ms.length) return sum;

  var avgN=0,f9N=0,coN=0;
  var avgS=0,f9S=0,coS=0;

  var coSingleN=0, coDoubleN=0;
  var coSingleS=0, coDoubleS=0;

  ms.forEach(function(m){
    if(!m) return;
    sum.played++;
    if(m.won) sum.w++; else sum.l++;
    sum.legsW += (m.legsFor||0);
    sum.legsL += (m.legsAgainst||0);

    if(typeof m.avg === "number" && !isNaN(m.avg)){ avgS += m.avg; avgN++; }
    if(typeof m.f9 === "number" && !isNaN(m.f9)){ f9S += m.f9; f9N++; }

    if(typeof m.co === "number" && !isNaN(m.co)){
      coS += m.co; coN++;
      var rule = (m.outRule || "").toLowerCase();
      if(rule === "double"){ coDoubleS += m.co; coDoubleN++; }
      else if(rule === "single"){ coSingleS += m.co; coSingleN++; }
    }

    sum.last = m.finishedAt || sum.last;
  });

  sum.avg = avgN ? (avgS/avgN) : null;
  sum.f9  = f9N ? (f9S/f9N) : null;
  sum.co  = coN ? (coS/coN) : null;
  sum.coSingle = coSingleN ? (coSingleS/coSingleN) : null;
  sum.coDouble = coDoubleN ? (coDoubleS/coDoubleN) : null;
  return sum;
}


function computeHistoryExtras(key){
  // Extra, "kul" statistik för spelarkortet: form (trend) och personbästa.
  // Form = snitt senaste 3 matcher (med avg) jämfört med spelarens historiska snitt (med avg).
  // Personbästa = högsta avg i historiken (med avg).
  var h = loadHistory();
  var entry = h.players && h.players[key];
  var ms = (entry && entry.matches) ? entry.matches.slice() : [];
  if(!ms.length) return { trend:null, best:null, bestOpp:null };

  // Sortera säkert på datum (äldre -> nyare)
  ms.sort(function(a,b){
    try{
      return String(a.finishedAt||"").localeCompare(String(b.finishedAt||""));
    }catch(e){ return 0; }
  });

  // Personbästa
  var best = null, bestOpp = null;
  ms.forEach(function(m){
    if(!m) return;
    var a = (typeof m.avg==="number") ? m.avg : parseFloat(m.avg);
    if(isNaN(a)) return;
    if(best===null || a > best){
      best = a;
      bestOpp = m.opponent || null;
    }
  });

  // Form (trend) på average
  var avgVals = ms.map(function(m){
    var a = (typeof m.avg==="number") ? m.avg : parseFloat(m.avg);
    return (isNaN(a) ? null : a);
  }).filter(function(v){ return v!==null; });

  if(avgVals.length < 3){
    return { trend:null, best:best, bestOpp:bestOpp };
  }

  var overall = avgVals.reduce(function(s,v){ return s+v; },0) / avgVals.length;
  var recent3 = avgVals.slice(-3);
  var recent = recent3.reduce(function(s,v){ return s+v; },0) / recent3.length;

  var delta = recent - overall; // positiv = bättre än historiskt snitt
  // Dämpa brus: små skillnader betraktas som stabilt
  if(Math.abs(delta) < 0.3) delta = 0;

  return {
    trend: { delta: delta, recent: recent, overall: overall },
    best: best,
    bestOpp: bestOpp
  };
}

function fmtNum(x, dec){
  if(x===null || x===undefined || isNaN(x)) return "-";
  return Number(x).toFixed(dec);
}

function fmtDateTime(iso){
  try{
    if(!iso) return "-";
    var d = new Date(iso);
    if(isNaN(d.getTime())) return iso;
    var y=d.getFullYear();
    var m=("0"+(d.getMonth()+1)).slice(-2);
    var da=("0"+d.getDate()).slice(-2);
    var hh=("0"+d.getHours()).slice(-2);
    var mm=("0"+d.getMinutes()).slice(-2);
    return y+"-"+m+"-"+da+" "+hh+":"+mm;
  }catch(e){ return iso||"-"; }
}

function openHistoryModal(pid){
  var title = playerName(pid);
  document.getElementById("historyTitle").textContent = "Historik – " + (title||"");
  var key = normName(title);
  var h = loadHistory();
  var entry = h.players && h.players[key];
  var ms = (entry && entry.matches) ? entry.matches.slice().reverse() : [];
  document.getElementById("historySubtitle").textContent = ms.length ? (ms.length + " matcher") : "Ingen historik sparad.";
  var body = "";
  if(ms.length){
    body += "<div class='tablewrap'><table><thead><tr><th>Datum</th><th>Mot</th><th>Res</th><th class='right'>Avg</th><th class='right'>F9</th><th class='right'>Utg%</th></tr></thead><tbody>";
    ms.forEach(function(m){
      var res = (m.won ? "V " : "F ") + (m.result||"");
      body += "<tr>"
        + "<td class='small'>"+escapeHtml(fmtDateTime(m.finishedAt))+"</td>"
        + "<td>"+escapeHtml(m.opponent||"")+"</td>"
        + "<td class='small'>"+escapeHtml(res)+"</td>"
        + "<td class='right small'>"+escapeHtml(fmtNum(m.avg,1))+"</td>"
        + "<td class='right small'>"+escapeHtml(fmtNum(m.f9,1))+"</td>"
        + "<td class='right small'>"+escapeHtml(fmtNum(m.co,1))+"</td>"
        + "</tr>";
    });
    body += "</tbody></table></div>";
  }else{
    body = "<div class='small'>Ingen historik ännu. När du sparar matcher kommer de dyka upp här.</div>";
  }
  document.getElementById("historyBody").innerHTML = body;
  document.getElementById("historyOverlay").classList.remove("hidden");
}

function closeHistoryModal(){
  var o=document.getElementById("historyOverlay");
  if(o) o.classList.add("hidden");
}

/* Lagring: försök localStorage, fallback till sessionStorage (funkar ofta bättre för content:// på Android) */
function _storage(){
  try{ const t="__ta_test__"; localStorage.setItem(t,"1"); localStorage.removeItem(t); return localStorage; }catch(e){}
  try{ const t="__ta_test__"; sessionStorage.setItem(t,"1"); sessionStorage.removeItem(t); return sessionStorage; }catch(e){}
  return null;
}
const STORAGE = _storage();

function _nameStoreRead(){
  try{
    const prefix = "TA_STORE:";
    const raw = (typeof window !== "undefined" && typeof window.name === "string") ? window.name : "";
    if(raw && raw.indexOf(prefix) === 0){
      const obj = JSON.parse(raw.slice(prefix.length) || "{}");
      return (obj && typeof obj === "object") ? obj : {};
    }
  }catch(e){}
  return {};
}
function _nameStoreWrite(obj){
  try{
    const prefix = "TA_STORE:";
    if(typeof window !== "undefined"){
      window.name = prefix + JSON.stringify(obj || {});
      return true;
    }
  }catch(e){}
  return false;
}

function storageSet(key, value){
  // Först: local/sessionStorage om tillgängligt
  try{
    if(STORAGE){
      STORAGE.setItem(key, value);
      return true;
    }
  }catch(e){}
  // Fallback: window.name (överlever reload i samma flik även när lagring blockas)
  const obj = _nameStoreRead();
  obj[key] = value;
  return _nameStoreWrite(obj);
}
function storageGet(key){
  try{
    if(STORAGE){
      return STORAGE.getItem(key);
    }
  }catch(e){}
  const obj = _nameStoreRead();
  return (obj && Object.prototype.hasOwnProperty.call(obj, key)) ? obj[key] : null;
}
function storageDel(key){
  let ok=false;
  try{
    if(STORAGE){
      STORAGE.removeItem(key);
      ok=true;
    }
  }catch(e){}
  const obj = _nameStoreRead();
  if(obj && Object.prototype.hasOwnProperty.call(obj, key)){
    delete obj[key];
    ok = _nameStoreWrite(obj) || ok;
  }
  return ok;
}

function deepClone(obj){
  return JSON.parse(JSON.stringify(obj));
}
function $(id){ return document.getElementById(id); }

// ===== Start-sida: senaste turneringar + snabbåtkomst till spelare =====
function renderStartRecentTournaments(){
  try{
    var host = document.getElementById('startRecentTournaments');
    if(!host) return;

    var LIB_PREFIX = 'dart_tournament_v98_';
    var keys = [];
    try{ keys = Object.keys(localStorage).filter(function(k){ return k.indexOf(LIB_PREFIX)===0; }); }catch(e){ keys = []; }
    var items = keys.map(function(k){
      try{ return JSON.parse(localStorage.getItem(k)||'null'); }catch(e){ return null; }
    }).filter(Boolean).sort(function(a,b){
      return new Date(b.updatedAt||b.createdAt||0) - new Date(a.updatedAt||a.createdAt||0);
    });

    if(!items.length){
      host.innerHTML = '<em>Inga sparade turneringar ännu.</em>';
      return;
    }

    host.innerHTML = items.map(function(t){
      var dt = (t.updatedAt||t.createdAt) ? new Date(t.updatedAt||t.createdAt).toLocaleString() : '';
      var name = escapeHtml((t.name|| (t.state && t.state.tournamentName) ) || 'Turnering');
      var id = escapeHtml(String(t.id||''));
      return (
        '<div class="item" style="padding:8px 4px;border-bottom:1px solid #eef2f7;display:flex;gap:10px;align-items:center;justify-content:space-between">'
          +'<div class="meta" style="min-width:0;flex:1">'
            +'<button class="linklike" type="button" style="font-weight:800;background:none;border:none;padding:0;margin:0;text-align:left;cursor:pointer;text-decoration:underline" onclick="__hubOpen(\''+id+'\')">'+name+'</button>'
            +'<div class="small" style="color:#64748b">'+escapeHtml(dt)+'</div>'
          +'</div>'
          +'<div class="actions" style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">'
            +'<button class="btn secondary" type="button" onclick="__hubOpen(\''+id+'\')">Öppna</button>'
            +'<button class="btn secondary" type="button" onclick="startDeleteTournament(\''+id+'\')">Radera</button>'
          +'</div>'
        +'</div>'
      );
    }).join('');
  }catch(e){}
}

function startDeleteTournament(id){
  try{
    if(!confirm('Radera turneringen?')) return;
    var key = 'dart_tournament_v98_' + String(id);
    try{ localStorage.removeItem(key); }catch(e){}
    // om aktiv turnering råkar vara samma, lämna state orört men listan uppdateras
    renderStartRecentTournaments();
  }catch(e){}
}


function ensureKnockoutSync(){
  // Säkerställ att knockout alltid har ett slutspels-träd att rendera,
  // även efter att man navigerat bakåt/framåt eller laddat om.
  try{
    if(state && state.format==="knockout"){
      const hasPO = state.playoffs && Array.isArray(state.playoffs.matches) && state.playoffs.matches.length>0;
      if(!hasPO){
        const ms = Array.isArray(state.matches) ? state.matches : [];
        const po = ms.filter(m => m && typeof m.id==="string" && m.id.indexOf("po_")===0);
        if(po.length){
          if(!state.playoffs) state.playoffs = {};
          state.playoffs.matches = po;
          if(typeof state.playoffs.started !== "boolean") state.playoffs.started = false;
        }
      }
    }
  }catch(e){}
}




function ensurePlayoffsSync(){
  // Håll state.playoffs.matches och ev. po_* matcher i state.matches synkade.
  // Viktigt: om man sparar i slutspelsträdet får det INTE skrivas över av en äldre kopia i matchlistan.
  try{
    if(!state) return;

    // Knockout: skapa vid behov playoffs.matches från po_* i state.matches.
    try{ ensureKnockoutSync(); }catch(e){}

    if(!state.playoffs || !Array.isArray(state.playoffs.matches)) return;

    const po = state.playoffs.matches;
    const ms = Array.isArray(state.matches) ? state.matches : [];

    // Indexera
    const poById = {};
    for(let i=0;i<po.length;i++){
      const mm = po[i];
      if(mm && typeof mm.id==="string") poById[mm.id] = mm;
    }

    // Hitta po_* i state.matches
    const poInMatches = ms.filter(m => m && typeof m.id==="string" && m.id.indexOf("po_")===0);
    if(!poInMatches.length){
      // Om matchlistan inte innehåller po_* (vanligt i grupp/serie+slutspel) finns inget mer att synka.
      return;
    }

    // Hjälp: jämför tidsstämplar (ISO). Returnerar true om a > b.
    function isoAfter(a,b){
      if(!a) return false;
      if(!b) return true;
      try{ return String(a) > String(b); }catch(e){ return false; }
    }

    // 1) Först: spegla från playoffs -> matches (så att sparningar i trädet alltid vinner).
    po.forEach(function(src){
      const idx = ms.findIndex(m => m && m.id===src.id);
      if(idx<0) return;
      const dst = ms[idx];
      if(!dst) return;

      // Endast uppdatera om playoffs har nyare info eller om matchlistan saknar vinnare.
      const srcNewer = isoAfter(src.finishedAt, dst.finishedAt);
      const srcHasWinner = !!src.winnerId;
      const dstHasWinner = !!dst.winnerId;

      if(srcNewer || (srcHasWinner && !dstHasWinner)){
        const keys = ["aId","bId","winnerId","result","avgA","avgB","f9A","f9B","coA","coB","notes","finishedAt","outRule"];
        keys.forEach(function(k){
          if(Object.prototype.hasOwnProperty.call(src, k)) dst[k] = src[k];
        });
      }
    });

    // 2) Sen: synka från matches -> playoffs, men bara om matchlistan är nyare.
    poInMatches.forEach(function(src){
      const dst = poById[src.id];
      if(!dst) return;

      const srcNewer = isoAfter(src.finishedAt, dst.finishedAt);
      const srcHasWinner = !!src.winnerId;
      const dstHasWinner = !!dst.winnerId;

      // Kopiera om matchlistan är nyare, eller om playoffs saknar vinnare men matchlistan har.
      if(srcNewer || (srcHasWinner && !dstHasWinner)){
        for(const k in src){
          if(Object.prototype.hasOwnProperty.call(src, k)){
            dst[k] = src[k];
          }
        }
      }
    });

    // 3) Efter synk: uppdatera final/semis när det är relevant
    try{
      if(state.playoffs && state.playoffs.started && state.format!=="knockout"){
        updateFinalFromSemis();
      }
    }catch(e){}

  }catch(e){}
}

function advancePlayoffWinners(){
  // För knockout: för vinnare vidare enligt nextId/nextSlot i matchobjekten.
  // Körs efter att en slutspelsmatch sparats så att trädet + kommande matcher uppdateras direkt.
  try{
    if(!state || state.format!=="knockout") return false;
    ensureKnockoutSync();

    // Primär källa: state.matches (Match-fliken). Fallback: state.playoffs.matches.
    var ms = Array.isArray(state.matches) ? state.matches : (state.playoffs && Array.isArray(state.playoffs.matches) ? state.playoffs.matches : []);
    if(!ms || !ms.length) return false;

    // Plocka bara slutspelsmatcher (po_*)
    var po = ms.filter(function(m){ return m && typeof m.id==="string" && m.id.indexOf("po_")===0; });
    if(!po.length) return false;

    var byId = {};
    po.forEach(function(m){ byId[m.id]=m; });

    function clearMatch(m){
      if(!m) return;
      m.winnerId = "";
      m.result = "";
      m.avgA = ""; m.avgB = "";
      m.f9A = ""; m.f9B = "";
      m.coA = ""; m.coB = "";
      m.notes = "";
      m.finishedAt = "";
    }

    var changedAny = false;

    // Kör ett par varv för att "skölja igenom" hela trädet (kval -> qf/sf -> final)
    for(var pass=0; pass<5; pass++){
      var changed = false;

      po.forEach(function(m){
        if(!m || !m.winnerId || !m.nextId || !m.nextSlot) return;
        var nm = byId[m.nextId];
        if(!nm) return;

        if(nm[m.nextSlot] !== m.winnerId){
          nm[m.nextSlot] = m.winnerId;

          // Om deltagare ändras: rensa matchen och allt nedströms så det inte blir spök-vinnare.
          clearMatch(nm);
          changed = true;
        }
      });

      // Om vi under passet uppdaterade deltagare, måste vi också säkerställa att
      // "winnerId" fortfarande är giltig i alla matcher (annars rensa).
      po.forEach(function(m){
        if(!m || !m.winnerId) return;
        if(m.winnerId !== m.aId && m.winnerId !== m.bId){
          clearMatch(m);
          changed = true;
        }
      });

      if(changed){
        changedAny = true;
      }else{
        break; // stabilt
      }
    }

    // Håll state.playoffs.matches pekande mot aktuella objekt om det finns.
    try{
      if(state.playoffs){
        state.playoffs.matches = po;
      }
    }catch(e){}

    return changedAny;
  }catch(e){
    console.error(e);
    return false;
  }
}


function togglePlayoffBracket(){
  if(!state.ui) state.ui = {};
  state.ui.showPlayoffsBracket = !state.ui.showPlayoffsBracket;
  saveState();
  applyPlayoffView();
  try{ window.scrollTo(0,0); }catch(e){}
}


function applyPlayoffView(){
  // Persist UI choice (schema vs träd) without affecting tournament logic
  if(!state.ui) state.ui = {};
  var show = !!state.ui.showPlayoffsBracket;

  var sched = $("playoffsScheduleView");
  var br = $("playoffsBracketView");
  var btn = $("btnPlayoffsBracketToggle");

  if(sched) sched.classList.toggle("hidden", show);
  if(br) br.classList.toggle("hidden", !show);

  if(btn){
    btn.textContent = show ? "Visa slutspelsschema" : "Visa slutspelsträd";
  }

  if(show){
    renderPlayoffBracket();
  }
}

function scrollPlayoffsBracket(where){
  try{
    var vp = document.getElementById('playoffsBracket');
    if(!vp) return;

    var scroller = document.getElementById('playoffsBracketViewport') || vp;
    var inner = document.getElementById('playoffsBracketInner');
    if(!scroller || !inner) return;

    var hasQF = !!(inner.querySelector && inner.querySelector('[data-po-id="po_qf1"]'));
    var hasQUAL = !!(inner.querySelector && inner.querySelector('[data-po-id="po_k1"]'));


    // Kval = längst till vänster när den finns
    if(where==='qual'){
      scroller.scrollTo({left:0, behavior:'smooth'});
      return;
    }

    // Kvartsfinal = längst till vänster (start) när den finns
    if(where==='qf'){
      // om Kval finns, scrolla lite åt höger så Kvarts hamnar snyggt
      if(hasQUAL){
        scroller.scrollTo({left: 0, behavior:'smooth'});
      }else{
        scroller.scrollTo({left:0, behavior:'smooth'});
      }
      return;
    }

    // Semifinal: vid 2 grupper är den längst till vänster. Vid 4 grupper scrollar vi till SF-kolumnen.
    if(where==='sf'){
      if(!hasQF){
        scroller.scrollTo({left:0, behavior:'smooth'});
        return;
      }
      var sf = inner.querySelector('[data-po-id="po_sf1"]');
      if(!sf){ scroller.scrollTo({left:0, behavior:'smooth'}); return; }
      var sRect = scroller.getBoundingClientRect();
      var fRect = sf.getBoundingClientRect();
      var cur = scroller.scrollLeft;
      var target = cur + (fRect.left - sRect.left) - 24;
      if(target < 0) target = 0;
      scroller.scrollTo({left: target, behavior:'smooth'});
      return;
    }

    // Final = så att både final och pokal syns (om pokal finns)
    if(where==='final'){
      var fin = inner.querySelector('[data-po-id="po_f"]');
      var trophy = inner.querySelector('.trophyCircle');

      if(!fin){
        scroller.scrollTo({left:scroller.scrollWidth, behavior:'smooth'});
        return;
      }

      var sRect = scroller.getBoundingClientRect();

      // Prioritera att pokalen kommer in i bild om den finns
      if(trophy){
        var tRect = trophy.getBoundingClientRect();
        var cur = scroller.scrollLeft;
        // Flytta så att pokalens högersida hamnar innanför viewport (med marginal)
        var target = cur + (tRect.right - sRect.right) + 24;
        if(target < 0) target = 0;
        scroller.scrollTo({left: target, behavior:'smooth'});
        return;
      }

      // Annars: centrera finalrutan så gott det går
      var fRect = fin.getBoundingClientRect();
      var current = scroller.scrollLeft;
      var target2 = current + (fRect.left - sRect.left) - (sRect.width/2) + (fRect.width/2);
      scroller.scrollTo({left: Math.max(0, target2), behavior:'smooth'});
      return;
    }
  }catch(e){
    console.error(e);
  }
}

function renderPlayoffBracket(){
  ensurePlayoffsSync();
  var hasPO = !!(state.playoffs && state.playoffs.matches && state.playoffs.matches.length>0);
  var started = !!(state.playoffs && state.playoffs.started && hasPO);

  // Knockout: visa alltid det skapade trädet (även innan man tryckt Starta slutspel)
  // så att Slumpa om + förhandsvisning fungerar och trädet matchar Match-fliken.
  var ms = (state.format === "knockout" && hasPO) ? state.playoffs.matches
           : (started ? state.playoffs.matches : (buildPlayoffsPreview() || []));
  if(!ms || ms.length===0) return;

  // Se till att finalen alltid får deltagare från semis när de är spelade (endast när slutspelet är startat)
  if(started && state.format!=="knockout"){
    try{ updateFinalFromSemis(); }catch(e){}
  }
  function byId(id){ for(var i=0;i<ms.length;i++) if(ms[i].id===id) return ms[i]; return null; }

  var qf1 = byId("po_qf1");
  var qf2 = byId("po_qf2");
  var qf3 = byId("po_qf3");
  var qf4 = byId("po_qf4");

  var sf1 = byId("po_sf1");
  var sf2 = byId("po_sf2");
  var fin = byId("po_f");

  function pname(pid, placeholder){
    try{ if(pid) return playerName(pid); }catch(e){}
    return placeholder || "";
  }

  function splitResult(m){
    if(!m || !m.result) return null;
    var parts = String(m.result).split("-");
    if(parts.length!==2) return null;
    var a = parseInt(parts[0],10); var b=parseInt(parts[1],10);
    if(isNaN(a)||isNaN(b)) return null;
    return [a,b];
  }
  function scoresForRows(m){
    if(!m || !m.winnerId) return ["",""];
    var ab = splitResult(m);
    if(!ab) return ["",""];
    var w = ab[0], l = ab[1];
    if(m.winnerId===m.aId) return [String(w), String(l)];
    if(m.winnerId===m.bId) return [String(l), String(w)];
    return ["",""];
  }

  function rowHtml(pid, scoreTxt, isWinner, placeholder){
    var nm = pname(pid, placeholder);
    var rowClass = "bracketRow" + (isWinner ? " winnerRow" : "");
    var nameClass = isWinner ? "winnerName" : "mutedName";
    var left = "<div class='row' style='align-items:center;gap:8px;min-width:0'>"
             + _avatarBtnViewHtml(pid||'', nm, 'small')
             + "<div class='"+nameClass+"' style='min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap'>"+escapeHtml(nm)+"</div>"
             + "</div>";
    return '<div class="'+rowClass+'">'
         +   left
         +   (scoreTxt ? '<div class="bracketScore">'+escapeHtml(scoreTxt)+'</div>' : '')
         + '</div>';
  }

  function matchBox(m, aPlaceholder, bPlaceholder){
    // Om platsen kommer från kval, visa rätt placeholder
    try{
      if(m && m._aFromQual!==null && m._aFromQual!==undefined) aPlaceholder = 'Vinnare Kval ' + (m._aFromQual+1);
      if(m && m._bFromQual!==null && m._bFromQual!==undefined) bPlaceholder = 'Vinnare Kval ' + (m._bFromQual+1);
    }catch(e){}

    var played = !!(m && m.winnerId);
    var rowScores = scoresForRows(m);

    var aWinner = played && m.winnerId===m.aId;
    var bWinner = played && m.winnerId===m.bId;

    var aRow = rowHtml(m ? m.aId : null, rowScores[0], aWinner, aPlaceholder);
    var bRow = rowHtml(m ? m.bId : null, rowScores[1], bWinner, bPlaceholder);

    var clickable = !!(m && m.id);
    
    

    var attrs = 'class="bracketBox" data-po-id="'+escapeHtml(m?m.id:"")+'"'
              + (m && m._aFromQual!==null && m._aFromQual!==undefined ? ' data-k-a="'+escapeHtml(String(m._aFromQual))+'"' : '')
              + (m && m._bFromQual!==null && m._bFromQual!==undefined ? ' data-k-b="'+escapeHtml(String(m._bFromQual))+'"' : '')
              + (clickable ? ' onclick="openPlayoffMatch(\''+escapeHtml(m.id)+'\')"' : '');

    return '<div '+attrs+'>'
         +   '<div class="bracketBody">'+aRow+bRow+'</div>'
         + '</div>';
  }

  var inner = $("playoffsBracketContent") || $("playoffsBracketInner");
  if(!inner) return;

  // Vinnarruta (visas även innan finalen är spelad)
  var winnerName = "—";
  try{ if(fin && fin.winnerId) winnerName = playerName(fin.winnerId); }catch(e){}
  var winnerAvatar = _avatarBtnViewHtml((fin && fin.winnerId) ? fin.winnerId : '', winnerName, 'small');
  var winnerBox = ''
    + '<div class="winnerBox'+((fin && fin.winnerId) ? ' hasWinner' : '')+'">'
    +   '<div class="trophyCircle" title="Vinnare">🏆</div>'
    +   '<div class="winnerAvatar" aria-hidden="true">'+winnerAvatar+'</div>'
    +   '<div class="winnerText">'
    +     '<div class="winnerLabel">Vinnare av turneringen</div>'
    +     '<div class="winnerValue">'+escapeHtml(winnerName)+'</div>'
    +   '</div>'
    + '</div>';

  var hasQF = !!(qf1 || qf2 || qf3 || qf4 || state.numGroups===4);
  var hasQUAL = false;
  for(var ki=1; ki<=7; ki++){ if(byId('po_k'+ki)) { hasQUAL=true; break; } }


  // Layout: växla mellan 2-kolumn (SF+Final) och 3-kolumn (QF+SF+Final)
  try{
    var shell = $("playoffsBracketInner");
    if(shell && shell.classList){
      shell.classList.toggle('hasQF', !!hasQF);
      shell.classList.toggle('hasQUAL', !!hasQUAL);
    }
  }catch(e){}

  var html = ''
    + '<div class="bracketGrid4">';


if(hasQUAL){
  html += '<div class="bracketCell qual">';
  for(var ki=1; ki<=7; ki++){
    var km = byId('po_k'+ki);
    if(km) html += matchBox(km, "—", "—");
  }
  html += '</div>';
}

if(hasQF){
    html += ''
      + '<div class="bracketCell qf">'
      +   matchBox(qf1, "Spelare A1", "Spelare B2")
      +   matchBox(qf2, "Spelare B1", "Spelare A2")
      +   matchBox(qf3, "Spelare C1", "Spelare D2")
      +   matchBox(qf4, "Spelare D1", "Spelare C2")
      + '</div>';
  }

  html += ''
    +   '<div class="bracketCell sf1">'+matchBox(sf1, (hasQF ? "Vinnare QF1" : "Spelare A1"), (hasQF ? "Vinnare QF2" : "Spelare B2"))+'</div>'
    +   '<div class="bracketCell sf2">'+matchBox(sf2, (hasQF ? "Vinnare QF3" : "Spelare B1"), (hasQF ? "Vinnare QF4" : "Spelare A2"))+'</div>'
    +   '<div class="bracketCell final">'
    +     '<div class="finalWrap">'
    +       '<div>'+matchBox(fin, "Vinnare SF1", "Vinnare SF2")+'</div>'
    +       winnerBox
    +     '</div>'
    +   '</div>'
    + '</div>';

  inner.innerHTML = html;

  // Aktivera/inaktivera snabbnavigering för kvartsfinal beroende på upplägg
  try{
    var qfBtn = document.querySelector("button.bracketNavBtn[onclick*='scrollPlayoffsBracket(\\'qf\\')']");
    if(qfBtn) qfBtn.disabled = !hasQF;
    var kvalBtn = document.getElementById('btnBracketQual');
    if(kvalBtn){
      if(hasQUAL){ kvalBtn.classList.remove('hidden'); kvalBtn.disabled = false; }
      else{ kvalBtn.classList.add('hidden'); kvalBtn.disabled = true; }
    }
  }catch(e){}

  try{ hydrateAvatarsIn(inner); }catch(e){}

  // Rita linjer efter att layouten lagt sig
  setTimeout(drawPlayoffsBracketLines, 0);
  try{
    if(!window.__bracketLinesBound){
      window.__bracketLinesBound = true;
      var sc = document.getElementById('playoffsBracketViewport');
      if(sc){ sc.addEventListener('scroll', function(){ drawPlayoffsBracketLines(); }, {passive:true}); }
      window.addEventListener('resize', function(){ drawPlayoffsBracketLines(); });
    }
  }catch(e){}
}

function drawPlayoffsBracketLines(){
  var canvas = $("playoffsBracketViewport") || $("playoffsBracket");
  var svg = $("playoffsBracketSvg");
  var inner = $("playoffsBracketContent") || $("playoffsBracketInner");
  if(!canvas || !svg || !inner) return;

  function box(id){
    return inner.querySelector('[data-po-id="'+id+'"]');
  }
  var k1 = box("po_k1");
  var k2 = box("po_k2");
  var k3 = box("po_k3");
  var k4 = box("po_k4");
  var k5 = box("po_k5");
  var k6 = box("po_k6");
  var k7 = box("po_k7");

  var qf1 = box("po_qf1");
  var qf2 = box("po_qf2");
  var qf3 = box("po_qf3");
  var qf4 = box("po_qf4");

  var sf1 = box("po_sf1");
  var sf2 = box("po_sf2");
  var fin = box("po_f");

  if(!sf1 || !sf2 || !fin) { svg.innerHTML=""; return; }

  var hasQF = !!(qf1 || qf2 || qf3 || qf4);
  var hasQUAL = !!(k1||k2||k3||k4||k5||k6||k7);

  var cRect = canvas.getBoundingClientRect();
  var width = inner.scrollWidth || inner.clientWidth;
  var height = inner.scrollHeight || inner.clientHeight;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", "0 0 "+width+" "+height);
  svg.style.width = width+"px";
  svg.style.height = height+"px";

  var baseRect = inner.getBoundingClientRect();
  function relRect(el){
    var r = el.getBoundingClientRect();
    return {
      left: r.left - baseRect.left,
      top: r.top - baseRect.top,
      right: r.right - baseRect.left,
      bottom: r.bottom - baseRect.top,
      cx: (r.left + r.right)/2 - cRect.left + canvas.scrollLeft,
      cy: (r.top + r.bottom)/2 - cRect.top
    };
  }

  var r1 = relRect(sf1);
  var r2 = relRect(sf2);
  var rf = relRect(fin);

  var trophy = (inner.querySelector && inner.querySelector(".trophyCircle")) ? inner.querySelector(".trophyCircle") : null;
  var rt = trophy ? relRect(trophy) : null;

  var stroke = "#dbe3ef";
  var strokeW = 6;

  function pathL(sx, sy, tx, ty, mx){
    return "M "+sx+" "+sy+" L "+mx+" "+sy+" L "+mx+" "+ty+" L "+tx+" "+ty;
  }

  var paths = [];

  // Kval-linjer: från po_kX till matcher som väntar kvalvinnare
if(hasQUAL){
  var targets = inner.querySelectorAll('[data-k-a], [data-k-b]');
  targets.forEach(function(t){
    var aK = t.getAttribute('data-k-a');
    var bK = t.getAttribute('data-k-b');
    var idx = aK || bK;
    if(!idx) return;
    var kEl = box('po_k'+idx);
    if(!kEl) return;

    var rk = relRect(kEl);
    var rt = relRect(t);

    var ax = rk.right, ay = rk.cy;
    var tx = rt.left,  ty = rt.cy;

    var joinX = (ax + tx) / 2;

    paths.push("M "+ax+" "+ay+" L "+joinX+" "+ay+" L "+joinX+" "+ty+" L "+tx+" "+ty);
  });
}


  if(hasQF && qf1 && qf2 && qf3 && qf4){
    var rq1 = relRect(qf1);
    var rq2 = relRect(qf2);
    var rq3 = relRect(qf3);
    var rq4 = relRect(qf4);

    function addBracketPair(qA, qB, sfRect){
      var ax = qA.right, ay = qA.cy;
      var bx = qB.right, by = qB.cy;
      var tx = sfRect.left, ty = sfRect.cy;
      var joinX = (ax + tx) / 2;

      paths.push("M "+ax+" "+ay+" L "+joinX+" "+ay);
      paths.push("M "+bx+" "+by+" L "+joinX+" "+by);

      var topY = Math.min(ay, by);
      var botY = Math.max(ay, by);
      paths.push("M "+joinX+" "+topY+" L "+joinX+" "+botY);

      paths.push("M "+joinX+" "+ty+" L "+tx+" "+ty);
    }

    addBracketPair(rq1, rq2, r1);
    addBracketPair(rq3, rq4, r2);
  }

  var p1x = r1.right;
  var p1y = r1.cy;
  var p2x = r2.right;
  var p2y = r2.cy;
  var fx = rf.left;
  var fy = rf.cy;
  var midSFtoF = (p1x + fx) / 2;

  paths.push(pathL(p1x, p1y, fx, fy, midSFtoF));
  paths.push(pathL(p2x, p2y, fx, fy, midSFtoF));

  svg.innerHTML = paths.map(function(d){
    return '<path d="'+d+'" fill="none" stroke="'+stroke+'" stroke-width="'+strokeW+'" stroke-linecap="round" stroke-linejoin="round" />';
  }).join("");

  if(rt){
    var tx1 = rf.right;
    var ty1 = rf.cy;
    var tx2 = rt.left;
    var ty2 = rt.cy;
    var mx = (tx1 + tx2) / 2;
    svg.innerHTML += '<path d="'+pathL(tx1, ty1, tx2, ty2, mx)+'" fill="none" stroke="'+stroke+'" stroke-width="'+strokeW+'" stroke-linecap="round" stroke-linejoin="round" />';
  }
}



function setStatVal(inputId, spanId, decimals){
  var el = document.getElementById(inputId);
  var out = document.getElementById(spanId);

  if(!el) return;

  var min = Number(el.min || 0);
  var max = Number(el.max || 100);
  var step = Number(el.step || 1);

  // Read value; if empty/NaN, fall back to min so we always show something
  var raw = (el.value === "" || el.value == null) ? NaN : Number(el.value);
  var v = Number.isFinite(raw) ? raw : min;

  // Snap to step if needed (helps when browser gives weird floats)
  if(Number.isFinite(step) && step > 0){
    var snapped = Math.round((v - min) / step) * step + min;
    // avoid -0
    v = Math.abs(snapped) < 1e-9 ? 0 : snapped;
  }

  // Format text
  var txt = (decimals != null) ? v.toFixed(decimals) : String(v);
  if (inputId === "coA" || inputId === "coB") txt = txt + "%";

  if(out) out.textContent = txt;

  // Bubble element (supports multiple id conventions)
  var bub = document.getElementById(inputId + "Bubble")
         || document.getElementById(spanId + "Bubble")
         || document.getElementById(spanId + "_bubble");

  if(bub){
    bub.textContent = txt;

    // Position bubble to follow the thumb
    // We position relative to the sliderBox container so it works on mobile.
    var box = bub.parentElement; // .sliderBox
    if(box){
      // Positionering som funkar stabilt i mobil-modaler (offset* i stället för getBoundingClientRect)
      var pct = (max === min) ? 0 : (v - min) / (max - min);
      pct = Math.min(1, Math.max(0, pct));

      // x inom sliderBox
      var sliderW = (el.offsetWidth || 0);
      var boxW = (box.clientWidth || 0);

      // Om modalen precis öppnats kan offsetWidth/bubbleWidth vara 0 (pga display:none innan),
      // då centrerar vi bubblan och låter en senare sync (rAF) placera den korrekt.
      var bw0 = (bub.offsetWidth || 0);
      if(sliderW < 5 || boxW < 5 || bw0 < 5){
        bub.style.left = "50%";
        bub.style.transform = "translateX(-50%)";
        return;
      }

      var x = (el.offsetLeft || 0) + (pct * sliderW);

      // clamp så bubblan inte hamnar "död" utanför
      var bw = bw0;
      var maxX = boxW - (bw/2);
      var minX = (bw/2);
      if(Number.isFinite(x)){
        x = Math.max(minX, Math.min(maxX, x));
      } else {
        x = minX;
      }

      bub.style.left = x + "px";
      bub.style.transform = "translateX(-50%)";
    }
  }
}


function syncStatSliders(){
  try{ setStatVal('avgA','avgAVal',1); }catch(e){}
  try{ setStatVal('avgB','avgBVal',1); }catch(e){}
  try{ setStatVal('f9A','f9AVal',1); }catch(e){}
  try{ setStatVal('f9B','f9BVal',1); }catch(e){}
  try{ setStatVal('coA','coAVal',1); }catch(e){}
  try{ setStatVal('coB','coBVal',1); }catch(e){}
  // Synka nummerfält + bind input->range en gång
  try{
    ['avgA','avgB','f9A','f9B','coA','coB'].forEach(function(id){
      var r = $(id);
      var num = $(id + 'Num');
      if(r && num){
        num.value = String(r.value);
        _bindRangeNumber(id);
      }
    });
  }catch(e){}
}

// ===== Slider: snabb och exakt inmatning (nummerfält + ±) =====
function getRangeStep(rangeId){
  try{
    var r = $(rangeId);
    var s = Number(r && r.step ? r.step : 1);
    return (Number.isFinite(s) && s>0) ? s : 1;
  }catch(e){ return 1; }
}
function _snapToStep(v, min, step){
  if(!(Number.isFinite(step) && step>0)) return v;
  var snapped = Math.round((v - min) / step) * step + min;
  if(Math.abs(snapped) < 1e-9) snapped = 0; // undvik -0
  var dec = (String(step).split('.')[1]||'').length;
  if(dec>0) snapped = Number(snapped.toFixed(Math.min(6, dec)));
  return snapped;
}
function nudgeRange(rangeId, delta){
  try{
    var r = $(rangeId);
    if(!r) return;
    var min = Number(r.min || 0);
    var max = Number(r.max || 100);
    var step = getRangeStep(rangeId);
    var cur = Number(r.value || 0);
    var v = cur + Number(delta||0);
    v = Math.max(min, Math.min(max, v));
    v = _snapToStep(v, min, step);
    r.value = String(v);
    r.dispatchEvent(new Event('input', { bubbles:true }));
    var num = $(rangeId + 'Num');
    if(num) num.value = String(v);
  }catch(e){}
}
function _bindRangeNumber(rangeId){
  try{
    var r = $(rangeId);
    var num = $(rangeId + 'Num');
    if(!r || !num) return;
    if(num.dataset.bound === '1') return;
    num.dataset.bound = '1';
    num.min = r.min || '';
    num.max = r.max || '';
    num.step = r.step || '1';
    if(!num.getAttribute('inputmode')) num.setAttribute('inputmode','decimal');
    num.addEventListener('input', function(){
      var min = Number(r.min || 0);
      var max = Number(r.max || 100);
      var step = getRangeStep(rangeId);
      var v = Number(num.value);
      if(!Number.isFinite(v)) return;
      v = Math.max(min, Math.min(max, v));
      v = _snapToStep(v, min, step);
      r.value = String(v);
      r.dispatchEvent(new Event('input', { bubbles:true }));
    });
  }catch(e){}
}

// ===== Statsimport (ChatGPT JSON) =====
function resetStatsImportUi(){
  try{
    var p = $("statsImportPanel");
    if(p) p.classList.add("hidden");
    var t = $("statsJsonText");
    if(t) t.value = "";
    statsImportSetStatus("", null);
  }catch(e){}
}

function toggleStatsImport(){
  var p = $("statsImportPanel");
  if(!p) return;
  p.classList.toggle("hidden");
  if(!p.classList.contains("hidden")){
    try{ $("statsJsonText").focus(); }catch(e){}
  }
}

function clearStatsImport(){
  try{ var t=$("statsJsonText"); if(t) t.value=""; }catch(e){}
  statsImportSetStatus("", null);
}

function statsImportSetStatus(msg, ok){
  var el = $("statsImportStatus");
  if(!el) return;
  el.textContent = msg || "";
  el.classList.remove("ok","err");
  if(ok === true) el.classList.add("ok");
  if(ok === false) el.classList.add("err");
}

function applyStatsImportFromFile(file){
  if(!file){ statsImportSetStatus("Ingen fil vald.", false); return; }
  var reader = new FileReader();
  reader.onload = function(){
    try{
      var txt = (reader.result||"").toString();
      var ta = $("statsJsonText");
      if(ta) ta.value = txt;
      applyStatsImportFromText();
    }catch(e){
      statsImportSetStatus("Kunde inte läsa filen.", false);
    }
  };
  reader.onerror = function(){ statsImportSetStatus("Kunde inte läsa filen.", false); };
  reader.readAsText(file);
}

function _toNumOrNull(v){
  if(v===null || v===undefined) return null;
  if(typeof v === "number" && isFinite(v)) return v;
  if(typeof v === "string"){
    var s = v.trim().replace(",",".");
    if(!s) return null;
    var n = parseFloat(s);
    return isFinite(n) ? n : null;
  }
  return null;
}

function _clamp(n, min, max){
  if(n===null || n===undefined) return null;
  if(!isFinite(n)) return null;
  if(min!=null) n = Math.max(min, n);
  if(max!=null) n = Math.min(max, n);
  return n;
}

function _findMatchById(id){
  var m = (state.matches||[]).find(function(x){ return x.id===id; });
  if(m) return m;
  if(state.playoffs && Array.isArray(state.playoffs.matches)){
    m = state.playoffs.matches.find(function(x){ return x.id===id; });
    if(m) return m;
  }
  return null;
}

function _applySlider(id, val, min, max){
  var el = $(id);
  if(!el) return;
  var n = _toNumOrNull(val);
  if(n===null) return;
  n = _clamp(n, min, max);
  el.value = n;
}

function applyStatsImportFromText(){
  try{
    var raw = ($("statsJsonText") && $("statsJsonText").value) ? $("statsJsonText").value.trim() : "";
    if(!raw){ statsImportSetStatus("Klistra in JSON eller ladda en fil.", false); return; }
    var obj = JSON.parse(raw);
    applyStatsImportObject(obj);
  }catch(e){
    statsImportSetStatus("JSON kunde inte tolkas. Kontrollera att du bara klistrat in JSON (utan extra text).", false);
  }
}

function applyStatsImportObject(obj){
  var m = _findMatchById(modal.id);
  if(!m){ statsImportSetStatus("Ingen match är öppen.", false); return; }

  var aName = playerName(m.aId) || "";
  var bName = playerName(m.bId) || "";

  var playersObj = (obj && obj.players) ? obj.players : null;
  var inA = playersObj && playersObj.A ? playersObj.A : {};
  var inB = playersObj && playersObj.B ? playersObj.B : {};

  function n(s){ return normName(s||""); }
  var aKey = n(aName), bKey = n(bName);

  var slotA = null, slotB = null;

  // Försök matcha på namn först (robust mot A/B-ordning)
  if(n(inA.name) && n(inA.name)===aKey) slotA = inA;
  if(n(inA.name) && n(inA.name)===bKey) slotB = inA;
  if(n(inB.name) && n(inB.name)===aKey) slotA = inB;
  if(n(inB.name) && n(inB.name)===bKey) slotB = inB;

  // Om namnen saknas eller inte matchar: fallback till ordning A->A, B->B
  if(!slotA) slotA = inA;
  if(!slotB) slotB = inB;

  // Applicera
  _applySlider("avgA", slotA.avg, 20, 120);
  _applySlider("avgB", slotB.avg, 20, 120);
  _applySlider("f9A", slotA.first9, 30, 140);
  _applySlider("f9B", slotB.first9, 30, 140);
  _applySlider("coA", slotA.checkoutPct, 0, 100);
  _applySlider("coB", slotB.checkoutPct, 0, 100);

  syncStatSliders();
  try{ ['avgA','avgB','f9A','f9B','coA','coB'].forEach(function(id){ var r=$(id); var n=$(id+'Num'); if(r && n){ n.value = r.value; _bindRangeNumber(id); } }); }catch(e){}

  // Spara till matchobjektet direkt så det följer med "Spara"
  m.avgA = $("avgA").value;
  m.avgB = $("avgB").value;
  m.f9A  = $("f9A").value;
  m.f9B  = $("f9B").value;
  m.coA  = $("coA").value;
  m.coB  = $("coB").value;

  statsImportSetStatus("Importerat. Kontrollera värdena och tryck sedan Spara.", true);
}
// ===== /Statsimport =====

function stopPropagation(e){ try{ if(e) e.stopPropagation(); }catch(_){} }

function toggleMenu(e){
  try{ if(e) e.stopPropagation(); }catch(_){}
  var ov = (typeof $ === "function") ? $("menuOverlay") : document.getElementById("menuOverlay");
  if(!ov) return;
  ov.classList.toggle("hidden");
}
function closeMenu(){
  var ov = (typeof $ === "function") ? $("menuOverlay") : document.getElementById("menuOverlay");
  if(ov) ov.classList.add("hidden");
}
// Stäng menyn om man klickar utanför panelen (men låt klick fungera normalt)
document.addEventListener("click", function(){ try{ closeMenu(); }catch(e){} });


function uuid(){ return "p_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); }

// Fisher–Yates shuffle (returns a new array)
function shuffle(arr){
  const a = Array.isArray(arr) ? arr.slice() : [];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    const tmp=a[i]; a[i]=a[j]; a[j]=tmp;
  }
  return a;
}


let state = {
  step: 1,
  format: "round_robin",
  mode: "single",
  entryMode: "kiosk",
  repeats: 1,
  importedPlayers: null,  // förhandsvisning från manuella fält (innan "Använd")
  rules: { game:"301", inRule:"single", outRule:"single", legsMode:"single" },
  // Meta/inställningar som inte påverkar grundlogiken i turneringen
  meta: { isSeriesEvent:false, seriesName:"", bonusProfile:"pulsi" },
  players: [],
  groups: { A: [], B: [] },
  matches: [],
  startedAt: null,
  playoffs: { started:false, matches: [] }
};

state.playerSource = "manual";

let modal = { id:null };

function saveState(){
  try{
    const json = JSON.stringify(state);
    storageSet(STORAGE_KEY, json);
    // På Android/Chrome med lokala filer (file://) kan localStorage vara opålitligt vid reload.
    // Spegla därför även till window.name så att uppdatering i samma flik alltid kan återställa.
    try{
      if(typeof location !== "undefined" && location.protocol === "file:"){
        const obj = _nameStoreRead() || {};
        obj[STORAGE_KEY] = json;
        _nameStoreWrite(obj);
      }
    }catch(e){}
  }catch(e){}

  // Local Hub: om turneringen har ett tournamentId, spara även i biblioteket
  // så att "Öppna" alltid återställer senaste ändringar.
  try{
    if(typeof window !== 'undefined' && typeof window.__hubPersistCurrent === 'function'){
      window.__hubPersistCurrent();
    }
  }catch(e){}
}

// Spara en "senaste"-kopia för snabb återställning vid oavsiktlig uppdatering.
// Anropas vid Skapa turnering och Spara match.
function autosaveTournament(){
  try{
    const payload = { savedAt: new Date().toISOString(), state: state };
    const json = JSON.stringify(payload);
    storageSet(AUTOSAVE_KEY, json);
    // Spegla även till window.name för stabil återställning vid reload på file://
    try{
      if(typeof location !== "undefined" && location.protocol === "file:"){
        const obj = _nameStoreRead() || {};
        obj[AUTOSAVE_KEY] = json;
        _nameStoreWrite(obj);
      }
    }catch(e){}
  }catch(e){}

  // Local Hub: spegla även autosave till biblioteket
  try{
    if(typeof window !== 'undefined' && typeof window.__hubPersistCurrent === 'function'){
      window.__hubPersistCurrent();
    }
  }catch(e){}
}

function loadAutosaveTournament(){
  try{
    let raw = storageGet(AUTOSAVE_KEY);
    if(!raw){
      // Om storage finns men inte höll vid reload (vanligt för file:// på mobil),
      // försök även läsa direkt från window.name-speglingen.
      try{
        const obj = _nameStoreRead() || {};
        raw = obj[AUTOSAVE_KEY] || null;
      }catch(e){}
    }
    if(!raw) return false;
    const parsed = JSON.parse(raw);
    if(parsed && parsed.state && parsed.state.rules && parsed.state.step){
      state = parsed.state;
      // Härda mot gamla versioner / saknade fält
      if(!state.playerSource) state.playerSource = "manual";
      if(state.playerSource !== "manual") state.playerSource = "manual";
      if(!state.mode) state.mode="single";
      if(state.mode!=="single" && state.mode!=="team") state.mode="single";
      if(!state.entryMode) state.entryMode="import";
      if(state.entryMode!=="import" && state.entryMode!=="kiosk") state.entryMode="import";
      if(!state.repeats) state.repeats = 1;
      return true;
    }
  }catch(e){}
  return false;
}
function loadState(){
  const raw = storageGet(STORAGE_KEY);
  if(!raw) return false;
  try{
    const parsed = JSON.parse(raw);
    if(parsed && parsed.rules && parsed.step){
      state = parsed;

      // Skydd mot gamla versioner som sparat fil-läge eller saknar fält
      if(!state.playerSource) state.playerSource = "manual";
      if(state.playerSource !== "manual") state.playerSource = "manual";
      if(!state.mode) state.mode="single";
      if(state.mode!=="single" && state.mode!=="team") state.mode="single";
      if(!state.entryMode) state.entryMode="import";
      if(state.entryMode!=="import" && state.entryMode!=="kiosk") state.entryMode="import";
      if(!state.repeats) state.repeats = 1;
      if(!state.playoffs) state.playoffs = { started:false, matches: [] };
      // Antal grupper (2 = standard, 4 = utökat)
      if(!state.numGroups){
        try{
          var keys = state.groups ? Object.keys(state.groups) : [];
          state.numGroups = (keys && keys.length >= 4) ? 4 : 2;
        }catch(e){
          state.numGroups = 2;
        }
      }
      if(!state.groups){
        state.groups = (state.numGroups===4) ? { A: [], B: [], C: [], D: [] } : { A: [], B: [] };
      }else{
        // Säkerställ att nycklar finns när man byter/öppnar äldre turneringar
        if(state.numGroups===4){
          if(!state.groups.C) state.groups.C = [];
          if(!state.groups.D) state.groups.D = [];
        }
      }
      if(!state.matches) state.matches = [];

      if(!state.startedAt){
        // Om turnering redan finns men saknar starttid, sätt den till nu.
        const hasData = (state.players && state.players.length) || (state.matches && state.matches.length) || (state.groups && ((state.groups && state.groups.A && state.groups.A.length)||(state.groups && state.groups.B && state.groups.B.length)));
        state.startedAt = hasData ? new Date().toISOString() : null;
      }

      return true;
    }
  }catch(e){}
  return false;
}

function renderAll(){
  setStepper();
  $("format").value = state.format;
  if($("numGroups")) $("numGroups").value = String(state.numGroups || 2);
  try{ onFormatChange(); }catch(e){}
  $("game").value = state.rules.game;
  $("inRule").value = state.rules.inRule;
  $("outRule").value = state.rules.outRule;
  $("legsMode").value = state.rules.legsMode;

  var ids = ["step1","step2","step3","step4","stepMatches","stepTable","stepPlayoffs","stepTools"];
  ids.forEach(function(id){
    var el = document.getElementById(id);
    if(el) el.classList.add("hidden");
  });

  var nums = getStepNums();
  // Normalisera gammalt sparat steg (om appen uppdaterats)
  if(state.step > nums.tools) state.step = 1;

  var activeId = stepId(state.step);
  var activeEl = document.getElementById(activeId);
  if(activeEl) activeEl.classList.remove("hidden");


  if(state.step===3){
    renderPlayersStep();
    // Om vi bara öppnat spelare från start (register-läge), gör UI:t enklare.
    try{
      var regOnly = !!state._playerRegisterOnly;
      var backBtn = document.getElementById('step3BackBtn');
      var createBtn = document.getElementById('step3CreateBtn');
      var kioskCreate = document.getElementById('btnKioskCreateTournament');
      if(regOnly){
        if(backBtn){ backBtn.textContent = 'Tillbaka'; backBtn.onclick = closePlayerRegister; }
        if(createBtn){ createBtn.style.display = 'none'; }
        if(kioskCreate){ kioskCreate.style.display = 'none'; }
      }else{
        if(backBtn){ backBtn.textContent = 'Tillbaka'; backBtn.onclick = function(){ goStep(2); }; }
        if(createBtn){ createBtn.style.display = ''; }
        if(kioskCreate){ kioskCreate.style.display = ''; }
      }
    }catch(e){}
  }

  if(nums.isGroup && state.step===nums.groups) renderGroups();

  if(state.step===nums.matches){
    renderMatches();
    renderDailyMatch();
  }

  if(state.step===nums.table){
    renderStandings();
    // Visa slutspel-knappen när ett upplägg med slutspel är valt och grunddelen är klar
    var ns = document.getElementById('nextStageWrap');
    if(ns){
      var ok = false;
      try{
        if(state.format==='group_playoffs') ok = groupStageComplete();
        else if(state.format==='round_robin_playoffs') ok = seriesStageComplete();
      }catch(e){ ok = false; }
      if(ok) ns.classList.remove('hidden');
      else ns.classList.add('hidden');
    }
}

  if(state.step===nums.playoffs){
    renderPlayoffs();
    renderTournamentSummary();
  }

  // Uppdatera snabblistan med lokala turneringar på första sidan
  try{ renderStartRecentTournaments(); }catch(e){}
  applyStartStamp();
  updateProgress();
  saveState();
}


function resetAll(){
  if(!confirm("Nollställa allt?")) return;
  storageDel(STORAGE_KEY);

  // state
  state.step = 1;
  state.mode = 'single';
  state.entryMode = 'import';
  state.format = "round_robin";
  state.rules = { game:"301", inRule:"single", outRule:"single", legsMode:"single" };
  state.players = [];
  state.numGroups = parseInt(($("numGroups") && $("numGroups").value) || state.numGroups || "2", 10) || 2;
    state.groups = (state.numGroups===4) ? {A:[], B:[], C:[], D:[]} : {A:[], B:[]};
  state.matches = [];
  state.playoffs = { started:false, matches: [] };
  state.startedAt = null;

  // rensa ev. inmatningsfält (för att undvika spökdata på mobil)
  var ids = [
    'players','walkonLabels','spotifyLinks','darts',
    'teamNames','teamMember1','teamMember2','teamSpotify','teamDarts',
    'kSingleName','kSingleSpotify','kSingleDarts',
    'kTeamName','kTeamP1','kTeamP2','kTeamSpotify','kTeamDarts',
    'quickImportBox'
  ];
  for(var i=0;i<ids.length;i++){
    var el=document.getElementById(ids[i]);
    if(el && typeof el.value !== 'undefined') el.value='';
  }

  renderAll();
}

function exportPDF(){
  // Bygger en sammanställning (Slutspel → Tabell → Matcher) och öppnar browserns utskrift (Spara som PDF).
  try{ buildPrintView(); }catch(e){ console.error(e); }

  // Sätt rubrik (turneringsnamn) + datum precis innan utskrift (vissa mobila webbläsare triggar inte beforeprint)
  try{
    var tName = (typeof state !== "undefined" && state && state.tournamentName) ? String(state.tournamentName).trim() : "";
    if(!tName) tName = "Turnering";
    var elName = document.getElementById("printTournamentName");
    if(elName) elName.textContent = tName;
    if (window.applyDates) window.applyDates();
  }catch(e){}

  try{ window.scrollTo(0,0); }catch(e){}
  try{ hydrateAvatarsIn(document.getElementById('printRoot')); }catch(e){}
  setTimeout(function(){ try{ window.print(); }catch(e){} }, 250);
}

function buildPrintView(){
  var finalsDst = document.getElementById('print-finals-content');
  var matchesDst = document.getElementById('print-matches-content');
  var tableDst = document.getElementById('print-table-content');
  if(!finalsDst || !matchesDst || !tableDst) return;

  finalsDst.innerHTML = '';
  matchesDst.innerHTML = '';
  tableDst.innerHTML = '';

  function cloneInto(dst, el){
    if(!el) return;
    var c = el.cloneNode(true);
    // Säkerställ att dolda/export-hide element inte stör utskrift
    if(c.classList && c.classList.contains('hidden')) c.classList.remove('hidden');
    dst.appendChild(c);
  }

  // Slutspel: sammanfattning + tabell (om finns)
  cloneInto(finalsDst, document.getElementById('tourneySummary'));
  cloneInto(finalsDst, document.getElementById('playoffsTable'));
  if(finalsDst.innerHTML.trim()===''){
    finalsDst.innerHTML = '<div class="small">Inget slutspel att visa.</div>';
  }

  // Matcher
  cloneInto(matchesDst, document.getElementById('matchesTable'));

  // Tabell
  cloneInto(tableDst, document.getElementById('standingsWrap'));



  // Undvik sidbryt mitt i rader/tabeller (så långt webbläsaren tillåter)
  document.getElementById('printRoot').querySelectorAll('table, tr').forEach(function(n){
    n.classList.add('avoid-break');
  });
}


function openPlayerModal(pid){
  try{
  var p = playerById(pid); if(!p) return;
  var _allMs = (state.matches||[]).slice();
  try{ if(state && state.playoffs && Array.isArray(state.playoffs.matches)) _allMs = _allMs.concat(state.playoffs.matches); }catch(e){}
  var st = computeStandings(state.players.map(function(x){return x.id;}), _allMs, null);
  var row = st.find(function(x){ return x.pid===pid; });
  var title = playerName(pid);
  document.getElementById("playerTitle").textContent = title;

  // Profilbild i profilkortet: använd sparad avatar om den finns, annars initialer
  var kindForAvatar = (p && p.type==='team') ? "team" : "single";
  var avatarPid = (typeof findSavedPlayerIdByName==="function") ? findSavedPlayerIdByName(title, kindForAvatar) : null;

  var btnA = document.getElementById("playerAvatarBtn");
  var initA = document.getElementById("playerAvatarInitials");
  if(btnA){
    btnA.setAttribute("data-avatar-pid", avatarPid || "");
    btnA.setAttribute("data-avatar-name", title || "");
    if(initA) initA.textContent = _avatarInitials(title||"") || "?";
    try{ hydrateAvatarsIn(btnA.parentNode || btnA); }catch(e){}
    btnA.onclick = function(ev){
      try{ ev.stopPropagation(); }catch(e){}
      try{ openAvatarModal(avatarPid, title); }catch(e){}
    };
  }
  var sub = [];
  if(p && p.type==='team' && p.members){
    var mem = p.members.filter(Boolean).join(' & ');
    if(mem) sub.push('Medlemmar: ' + mem);
  }
  // Turneringens rad (row) används längre ner för turneringsdata.
  document.getElementById("playerSubtitle").textContent = sub.join(" • ");

var body = "";
  var dartsInfo = (p.darts||"").trim();
  if(dartsInfo){
    body += "<div class='card' style='margin:0 0 10px 0'><strong>Pilar</strong><div class='small' style='margin-top:6px'>"+escapeHtml(dartsInfo)+"</div></div>";
  }
  if(p.walkonLabel || p.walkonUrl){
    var url = (p.walkonUrl||"").trim();
    var rawLabel = (p.walkonLabel||"").trim();
    // Backward-compatible: om äldre data sparat länken i "walkonLabel" (och inte i walkonUrl)
    // så ska den ändå bli klickbar.
    var inferredUrl = url || (rawLabel && looksLikeUrl(rawLabel) ? rawLabel : "");
    var urlEsc = inferredUrl ? escapeHtml(inferredUrl) : "";
    var labelSafe = escapeHtml(rawLabel);

    // Om vi har en URL, gör alltid en klickbar länk (visa label om den inte bara är en URL).
    var textToShow = labelSafe && !(rawLabel && looksLikeUrl(rawLabel)) ? labelSafe : (urlEsc || "-");
    var labelHtml = urlEsc
      ? ("<a class='link' href='"+urlEsc+"' target='_blank' rel='noopener' onclick=\"stopPropagation(event)\">"+textToShow+"</a>")
      : (labelSafe || "-");
    body += "<div class='card' style='margin:0'><strong>Walk-on</strong>";
    if(urlEsc){
      body += "<div style='margin-top:8px'><a class='link' href='"+urlEsc+"' target='_blank' rel='noopener' onclick=\"stopPropagation(event)\">Öppna i Spotify</a></div>";
    }
    body += "</div>";
  }else{
    body += "<div class='small'>Ingen walk-on song sparad.</div>";
  }

  // Turneringens statistik (endast aktuell turnering)
  if(row){
    body += "<div class='card' style='margin-top:12px'><strong>Turneringsdata</strong>";
    body += "<div class='small' style='margin-top:6px'>Matcher: "+row.played+" • V: "+row.w+" • F: "+row.l+"</div>";
    if(row.pts!=null) body += "<div class='small'>Poäng: "+row.pts+"</div>";
    if(row.legsW!=null) body += "<div class='small'>Legs: "+row.legsW+"</div>";
    var extra = [];
    if(row.avg!=null) extra.push("Avg: "+escapeHtml(fmtNum(row.avg,1)));
    if(row.f9!=null)  extra.push("F9: "+escapeHtml(fmtNum(row.f9,1)));
    if(row.co!=null)  extra.push("Utg%: "+escapeHtml(fmtNum(row.co,1)));
    if(extra.length) body += "<div class='small'>"+extra.join(" • ")+"</div>";
    body += "</div>";
  }

  // Deltävling: bullseye + slutspelspoäng (visas bara om turneringen är markerad som deltävling)
  try{
    if(_seriesEnabled()){
      var bulls = computeLocalBullTotals();
      var poPts = computeLocalPlayoffPoints();
      var b = bulls ? (bulls[pid]||0) : 0;
      var pp = poPts ? (poPts[pid]||0) : 0;
      body += "<div class='card' style='margin-top:12px'><strong>Deltävling – sammanställning</strong>";
      body += "<div class='small' style='margin-top:6px'>Slutspelspoäng: <strong>"+escapeHtml(String(pp))+"</strong> • Bullseye totalt: <strong>"+escapeHtml(String(b))+"</strong></div>";
      body += "</div>";
    }
  }catch(e){}

// senaste matcherna
  var recent = (_allMs||[]).filter(function(m){
    return m.winnerId && (m.aId===pid || m.bId===pid);
  }).slice(-5).reverse();
  if(recent.length){
    body += "<div style='margin-top:12px'><strong>Senaste matcher</strong></div>";
    body += "<table style='margin-top:8px'><tr><th>Match</th><th>Resultat</th></tr>";
    recent.forEach(function(m){
      var opp = (m.aId===pid) ? playerName(m.bId) : playerName(m.aId);
      var res = m.result || (state.rules.legsMode==='single' ? '1-0' : '');
      var win = (m.winnerId===pid) ? "V" : "F";
      body += "<tr><td>"+escapeHtml(opp)+"</td><td>"+win+" "+escapeHtml(res)+"</td></tr>";
    });
    body += "</table>";
  }

  document.getElementById("playerBody").innerHTML = body;
  document.getElementById("playerOverlay").classList.remove("hidden");
  }catch(e){
    console.error(e);
    alert("Kunde inte öppna spelarkortet. Prova att ladda om sidan.");
  }
}
function closePlayerModal(){ document.getElementById("playerOverlay").classList.add("hidden"); }

function setModalLocked(isLocked){
  var banner = document.getElementById("lockedBanner");
  if(banner) banner.classList.toggle("hidden", !isLocked);

  var disable = isLocked;
  ["winA","winB","avgA","avgB","f9A","f9B","coA","coB","notes"].forEach(function(id){
    var el = document.getElementById(id);
    if(el) el.disabled = disable;
  });

  // result buttons
  var rb = document.getElementById("resultBtns");
  if(rb){
    rb.querySelectorAll("button").forEach(function(b){ b.disabled = disable; });
  }
  // clear/save buttons remain enabled, but saving while locked does nothing
  state.modalLocked = isLocked;
}

function enableEdit(){
  setModalLocked(false);
}

function getDailyMatch(){
  // pick played match with highest combined avg (if exists), else null
  var best = null, bestScore = -1;
  (state.matches||[]).forEach(function(m){
    if(!m.winnerId) return;
    var a = parseFloat(m.avgA); var b = parseFloat(m.avgB);
    if(isNaN(a) && isNaN(b)) return;
    var s = 0;
    if(!isNaN(a)) s += a;
    if(!isNaN(b)) s += b;
    if(s > bestScore){ bestScore = s; best = m; }
  });
  return best;
}

function renderDailyMatch(){
  var el = document.getElementById("dailyMatch");
  if(!el) return;
  var m = getDailyMatch();
  if(!m){
    el.innerHTML = "<span class='small'>Inga spelade matcher med average ännu.</span>";
    return;
  }
  var aName = playerName(m.aId), bName = playerName(m.bId);
  var res = m.result || (state.rules.legsMode==='single' ? '1-0' : '');
  var ctx = (m.group==='Alla'?'Serie':(m.group==='A'||m.group==='B'?'Grupp '+m.group:(m.round||"")));
  el.innerHTML = "<div class='row' style='justify-content:space-between;align-items:center'><div><strong>🔥 Dagens match</strong><div class='small'>"+escapeHtml(ctx)+"</div></div><button class='btn secondary' onclick=\"openMatch('"+m.id+"')\">Öppna</button></div>"
    + "<div style='margin-top:8px'>"+escapeHtml(aName)+" vs "+escapeHtml(bName)+" <span class='tag'>"+escapeHtml(res)+"</span></div>"
    + "<div class='small' style='margin-top:6px'>Avg: "+escapeHtml(m.avgA||'–')+" / "+escapeHtml(m.avgB||'–')+"</div>";
}

function tournamentWinnerId(){
  if(!state.playoffs || !state.playoffs.matches) return "";
  var fin = state.playoffs.matches.find(function(x){ return x.id==='po_f'; });
  return fin && fin.winnerId ? fin.winnerId : "";
}

function renderTournamentSummary(){
  var el = document.getElementById("tourneySummary");
  if(!el) return;
  var win = tournamentWinnerId();
  if(!win){
    el.innerHTML = "<span class='small'>Sammanfattning visas när finalen är spelad.</span>";
    return;
  }
  var st = computeStandings(state.players.map(function(p){return p.id;}), state.matches.concat((state.playoffs&&state.playoffs.matches)||[]), null);
  function bestBy(key){
    var best = null, val = -1;
    st.forEach(function(r){
      var v = r[key];
      if(v==null) return;
      if(v>val){ val=v; best=r; }
    });
    return best ? {pid:best.pid, v:val} : null;
  }
  var bAvg = bestBy("avg");
  var bF9 = bestBy("f9");
  var bCo = bestBy("co");
  var html = "<div class='card' style='margin:0'><div class='row' style='justify-content:space-between;align-items:center'><div><strong>🏆 Turneringen är avgjord</strong><div class='small'>Vinnare: <strong>"+escapeHtml(playerName(win))+"</strong></div></div></div>";
  html += "<div style='margin-top:10px' class='small'>";
  if(bAvg) html += "Bästa Avg: <strong>"+escapeHtml(playerName(bAvg.pid))+"</strong> ("+(Math.round(bAvg.v*10)/10).toFixed(1)+")<br>";
  if(bF9) html += "Bästa F9: <strong>"+escapeHtml(playerName(bF9.pid))+"</strong> ("+(Math.round(bF9.v*10)/10).toFixed(1)+")<br>";
  if(bCo) html += "Bästa Utg%: <strong>"+escapeHtml(playerName(bCo.pid))+"</strong> ("+(Math.round(bCo.v*10)/10).toFixed(1)+")";
  html += "</div></div>";
  el.innerHTML = html;
}

function getStepNums(){
  var isGroup = (state.format && state.format.indexOf("group")===0);
  return {
    isGroup: isGroup,
    groups: isGroup ? 4 : null,
    matches: isGroup ? 5 : 4,
    table: isGroup ? 6 : 5,
    playoffs: isGroup ? 7 : 6,
    tools: isGroup ? 8 : 7
  };
}

function stepId(n){
  var nums = getStepNums();
  if(n===1) return "step1";
  if(n===2) return "step2";
  if(n===3) return "step3";
  if(nums.isGroup && n===nums.groups) return "step4";
  if(n===nums.matches) return "stepMatches";
  if(n===nums.table) return "stepTable";
  if(n===nums.playoffs) return "stepPlayoffs";
  if(n===nums.tools) return "stepTools";
  return "step1";
}

function setStepper(){
  var nums = getStepNums();
  var steps = [
    {n:1, t:"Upplägg"},
    {n:2, t:"Spel"},
    {n:3, t:"Spelare"}
  ];
  if(nums.isGroup){
    steps.push({n:nums.groups, t:"Grupper"});
  }
  steps.push({n:nums.matches, t:(nums.isGroup?"Matcher":"Matcher")});
  steps.push({n:nums.table, t:(nums.isGroup?"Tabell":"Tabell")});
  steps.push({n:nums.playoffs, t:(nums.isGroup?"Slutspel":"Slutspel")});
  steps.push({n:nums.tools, t:(nums.isGroup?"Verktyg":"Verktyg")});

  var __st = $("menuStepper") || $("stepper");
  if(__st) __st.innerHTML = '<span class="step" onclick="goStart()">Start</span>' + steps.map(function(s){
    return '<span class="step '+(state.step===s.n?'active':'')+'" onclick="goStep('+s.n+')">'+s.t+'</span>';
  }).join("") + '<span class="step" onclick="openSeriesHub(); closeMenu();">Serie-hubb</span>';
  // Synka även bottennavigeringen (om den finns)
  try{ if(typeof setBottomNav === 'function') setBottomNav(); }catch(e){}
  try{ hydrateAvatarsIn(box); }catch(e){}
}

// Fast bottennavigering (ersätter hamburgermeny)
function setBottomNav(){
  var nav = document.getElementById('bottomNav');
  if(!nav) return;
  var nums = getStepNums();
  var steps = [
    {k:'start', t:'Start', on:function(){ goStart(); }},
    {k:1, t:'Upplägg', on:function(){ goStep(1); }},
    {k:2, t:'Spel', on:function(){ goStep(2); }},
    {k:3, t:'Spelare', on:function(){ goStep(3); }}
  ];
  if(nums.isGroup){ steps.push({k:nums.groups, t:'Grupper', on:function(){ goStep(nums.groups); }}); }
  steps.push({k:nums.matches, t:'Matcher', on:function(){ goStep(nums.matches); }});
  steps.push({k:nums.table, t:'Tabell', on:function(){ goStep(nums.table); }});
  steps.push({k:nums.playoffs, t:'Slutspel', on:function(){ goStep(nums.playoffs); }});
  steps.push({k:nums.tools, t:'Verktyg', on:function(){ goStep(nums.tools); }});
  steps.push({k:'tv', t:'TV-läge', on:function(){ try{ openTVMode(); }catch(e){} }});
  steps.push({k:'hub', t:'Serie-hubb', on:function(){ try{ openSeriesHub(); }catch(e){} }});

  var isHubActive = false;
  try{ var sh = document.getElementById('seriesHubScreen'); isHubActive = !!(sh && sh.classList.contains('active')); }catch(e){}
  var isTVActive = false;
  try{ var tv = document.getElementById('tvModeScreen'); isTVActive = !!(tv && tv.classList.contains('active')); }catch(e){}

  nav.innerHTML = '';
  steps.forEach(function(s){
    var b = document.createElement('button');
    b.type = 'button';
    b.className = 'bottomNavBtn' + (
      (s.k==='tv' && isTVActive) ? ' active' :
      (s.k==='hub' && isHubActive) ? ' active' :
      (typeof s.k==='number' && state.step===s.k && !isHubActive && !isTVActive) ? ' active' :
      (s.k==='start' && !isHubActive && !isTVActive && state.step===0) ? ' active' :
      ''
    );
    b.textContent = s.t;
    b.addEventListener('click', function(ev){ try{ ev.stopPropagation(); }catch(_){ } try{ s.on(); }catch(e){} try{ setBottomNav(); }catch(e2){} });
    nav.appendChild(b);
  });
}


/* === TV-läge / turneringsvy === */
function openTVMode(){
  try{
    var tv = document.getElementById('tvModeScreen');
    if(!tv) return;
    // stäng seriehubb om den är öppen
    try{ closeSeriesHub(); }catch(e){}
    // göm huvudappen men lämna matchmodal etc. som vanligt
    // Låt appMain vara kvar (modaler ligger där). TV-skärmen täcker hela vyn ändå.
    document.body.classList.add('tvmode');
    tv.classList.add('active');
    tv.setAttribute('aria-hidden','false');
    renderTVMode();
    try{ setBottomNav(); }catch(e){}
  }catch(e){}
}

function closeTVMode(){
  try{
    var tv = document.getElementById('tvModeScreen');
    if(!tv) return;
    tv.classList.remove('active');
    tv.setAttribute('aria-hidden','true');
    document.body.classList.remove('tvmode');
    // appMain har inte gömts i TV-läget
    try{ setBottomNav(); }catch(e){}
  }catch(e){}
}

function tvModeRequestFullscreen(){
  try{
    var el = document.documentElement;
    if(el.requestFullscreen) el.requestFullscreen();
  }catch(e){}
}

function renderTVMode(){
  // Matcher
  try{
    var list = document.getElementById('tvMatchesList');
    var sub = document.getElementById('tvMatchesSub');
    if(!list) return;

    var ms = Array.isArray(state.matches) ? state.matches.slice() : [];
    // lägg till slutspelsmatcher om de finns och inte redan ligger i state.matches
    try{
      if(state.playoffs && Array.isArray(state.playoffs.matches)){
        state.playoffs.matches.forEach(function(pm){
          if(pm && pm.id && !ms.some(function(x){return x && x.id===pm.id;})) ms.push(pm);
        });
      }
    }catch(e){}

    var playedCount = ms.filter(function(m){return m && m.winnerId;}).length;
    if(sub) sub.textContent = playedCount + " / " + ms.length + " klara";

    // sortera: ej spelade först, sen spelade (senast uppdaterade sist)
    ms.sort(function(a,b){
      var ap = a && a.winnerId ? 1 : 0;
      var bp = b && b.winnerId ? 1 : 0;
      if(ap!==bp) return ap-bp;
      var at = (a && a.updatedAt) ? Date.parse(a.updatedAt) : 0;
      var bt = (b && b.updatedAt) ? Date.parse(b.updatedAt) : 0;
      return bt-at;
    });

    list.innerHTML = '';
    ms.forEach(function(m){
      if(!m) return;
      var a = playerName(m.aId);
      var b = playerName(m.bId);
      var played = !!m.winnerId;

      var title = a + " vs " + b;
      var meta = [];
      if(m.group) meta.push("Grupp " + m.group);
      if(m.id && String(m.id).indexOf("po_")===0) meta.push("Slutspel");
      if(m.result) meta.push(m.result);

      var status = played ? (playerName(m.winnerId) + " vann") : "Ej spelad";

      var item = document.createElement('div');
      item.className = "tvMatch" + (played ? " played" : "");
      item.addEventListener('click', function(){
        try{ openMatch(m.id); }catch(e){}
      });

      var left = document.createElement('div');
      left.className = "tvMatchMain";

      var t = document.createElement('div');
      t.className = "tvMatchTitle";
      t.textContent = title;

      var mt = document.createElement('div');
      mt.className = "tvMatchMeta";
      meta.slice(0,3).forEach(function(x){
        var p = document.createElement('span');
        p.className = "tvPill";
        p.textContent = x;
        mt.appendChild(p);
      });

      left.appendChild(t);
      if(meta.length) left.appendChild(mt);

      var right = document.createElement('div');
      var pill = document.createElement('span');
      pill.className = "tvPill " + (played ? "ok" : "todo");
      pill.textContent = status;
      right.appendChild(pill);

      item.appendChild(left);
      item.appendChild(right);
      list.appendChild(item);
    });
  }catch(e){}

  // Tabell (enkel sammanställning)
  try{
    var box = document.getElementById('tvStandingsWrap');
    var sub2 = document.getElementById('tvTableSub');
    if(!box) return;

    var ids = (state.players||[]).map(function(p){return p.id;});
    var msAll = Array.isArray(state.matches) ? state.matches : [];
    // Exkludera slutspel ur tabell om det finns separat
    var msRR = msAll.filter(function(m){ return !(m && m.id && String(m.id).indexOf("po_")===0); });

    var st = computeStandings(ids, msRR);
    var arr = Object.keys(st).map(function(k){return st[k];});

    arr.forEach(function(r){
      r.legDiff = (r.legsWon||0) - (r.legsLost||0);
      r.avg = (r.avgCount ? (r.avgSum / r.avgCount) : 0);
    });

    arr.sort(function(a,b){
      if(b.pts!==a.pts) return b.pts-a.pts;
      if(b.w!==a.w) return b.w-a.w;
      if(b.legDiff!==a.legDiff) return b.legDiff-a.legDiff;
      if(b.legsWon!==a.legsWon) return (b.legsWon||0)-(a.legsWon||0);
      if(b.avg!==a.avg) return b.avg-a.avg;
      return (playerName(a.pid)||'').localeCompare(playerName(b.pid)||'');
    });

    if(sub2) sub2.textContent = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

    var html = '<table class="tvStandingsTbl"><thead><tr>'
      + '<th>#</th><th>Spelare</th><th>P</th><th>W-L</th><th>±</th><th>Avg</th>'
      + '</tr></thead><tbody>';
    arr.forEach(function(r,i){
      html += '<tr>'
        + '<td><strong>'+(i+1)+'</strong></td>'
        + '<td>'+escapeHtml(playerName(r.pid))+'</td>'
        + '<td><strong>'+escapeHtml(String(r.pts||0))+'</strong></td>'
        + '<td>'+escapeHtml(String(r.w||0))+'-'+escapeHtml(String(r.l||0))+'</td>'
        + '<td>'+escapeHtml(String(r.legDiff||0))+'</td>'
        + '<td>'+escapeHtml((r.avg||0).toFixed(1))+'</td>'
        + '</tr>';
    });
    html += '</tbody></table>';
    box.innerHTML = html;
    try{
      box.querySelectorAll('.tvNameBtn').forEach(function(btn){
        btn.addEventListener('click', function(ev){
          ev.stopPropagation();
          var pid = btn.getAttribute('data-pid');
          try{ openPlayerModal(pid); }catch(e){}
        });
      });
    }catch(e){}


  // Slutspelsschema (lista över po_* matcher om de finns)
  try{
    var poWrap = document.getElementById('tvPlayoffsWrap');
    var poSub = document.getElementById('tvPlayoffsSub');
    if(poWrap){
      var poMs = [];
      try{
        if(state.playoffs && Array.isArray(state.playoffs.matches)) poMs = state.playoffs.matches.slice();
      }catch(e){}
      // fallback: plocka po_* från state.matches
      if(!poMs.length){
        try{
          poMs = (Array.isArray(state.matches)?state.matches:[]).filter(function(m){ return m && m.id && String(m.id).indexOf('po_')===0; });
        }catch(e){}
      }
      if(poSub){
        poSub.textContent = poMs.length ? ('(' + poMs.length + ' matcher)') : '';
      }
      if(!poMs.length){
        poWrap.innerHTML = '<div class="tvMuted">Slutspel är inte startat ännu (eller finns inte i upplägget).</div>';
      }else{
        // sortera i ordning: kval -> kvarts -> semi -> final om id innehåller det, annars behåll
        var order = ['qual','qf','sf','final'];
        poMs.sort(function(a,b){
          var ai = 99, bi = 99;
          try{
            var aid = String(a.id||'');
            var bid = String(b.id||'');
            order.forEach(function(k,ix){
              if(aid.indexOf(k)>=0) ai = Math.min(ai, ix);
              if(bid.indexOf(k)>=0) bi = Math.min(bi, ix);
            });
          }catch(e){}
          if(ai!==bi) return ai-bi;
          return String(a.id||'').localeCompare(String(b.id||''));
        });

        var h = '<div class="tvPlayoffsList">';
        poMs.forEach(function(m){
          if(!m) return;
          var a = playerName(m.aId);
          var b = playerName(m.bId);
          var played = !!m.winnerId;
          var label = (m.label || '').trim();
          if(!label){
            if(m.id && String(m.id).indexOf('final')>=0) label='Final';
            else if(m.id && String(m.id).indexOf('sf')>=0) label='Semifinal';
            else if(m.id && String(m.id).indexOf('qf')>=0) label='Kvartsfinal';
            else if(m.id && String(m.id).indexOf('qual')>=0) label='Kval';
            else label='Slutspel';
          }
          var status = played ? (playerName(m.winnerId)+' vann') : 'Ej spelad';
          h += '<div class="tvPoRow" role="button" tabindex="0" data-mid="'+escapeHtml(String(m.id))+'">'
             +   '<div class="tvPoLeft">'
             +     '<div class="tvPoLabel">'+escapeHtml(label)+'</div>'
             +     '<div class="tvPoNames"><button type="button" class="tvNameBtn2" data-pid="'+escapeHtml(String(m.aId||''))+'">'+escapeHtml(a)+'</button> <span class="tvVs">vs</span> <button type="button" class="tvNameBtn2" data-pid="'+escapeHtml(String(m.bId||''))+'">'+escapeHtml(b)+'</button></div>'
             +   '</div>'
             +   '<div class="tvPoStatus '+(played?'ok':'todo')+'">'+escapeHtml(status)+'</div>'
             + '</div>';
        });
        h += '</div>';
        poWrap.innerHTML = h;

        // klick: öppna matchen i vanliga matchmodalen
        try{
          poWrap.querySelectorAll('.tvPoRow').forEach(function(row){
            row.addEventListener('click', function(){
              var mid = row.getAttribute('data-mid');
              try{ openMatch(mid); }catch(e){}
            });
          });
          poWrap.querySelectorAll('.tvNameBtn2').forEach(function(btn){
            btn.addEventListener('click', function(ev){
              ev.stopPropagation();
              var pid = btn.getAttribute('data-pid');
              try{ openPlayerModal(pid); }catch(e){}
            });
          });
        }catch(e){}
      }
    }
  }catch(e){}
  }catch(e){}

  // Statistik
  try{
    var stats = document.getElementById('tvStatsBox');
    if(stats){
      var ms2 = Array.isArray(state.matches) ? state.matches : [];
      var played = ms2.filter(function(m){return m && m.winnerId;}).length;
      var total = ms2.length;
      var donePct = total ? Math.round((played/total)*100) : 0;

      stats.innerHTML =
        '<div><strong>Matcher klara:</strong> ' + played + ' / ' + total + ' ('+donePct+'%)</div>'
        + '<div style="margin-top:6px"><strong>Format:</strong> ' + escapeHtml(String(state.format||'')) + '</div>'
        + '<div style="margin-top:6px"><strong>Senast uppdaterad:</strong> ' + new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"}) + '</div>'
        + '<div style="margin-top:6px;opacity:.75">Tips: Klicka på en match till vänster för att redigera. Stäng matchfönstret så är du kvar i TV-läget.</div>';
    }
  }catch(e){}
}

// Håll TV-vyn uppdaterad om man råkar gå tillbaka till den
try{
  document.addEventListener('visibilitychange', function(){
    try{
      var tv = document.getElementById('tvModeScreen');
      if(tv && tv.classList.contains('active')) renderTVMode();
    }catch(e){}
  });
}catch(e){}

function goStart(){
  try{ closeMenu(); }catch(e){}
  // Om Serie-hubb är öppen ska den stängas innan vi navigerar vidare
  try{
    var sh = document.getElementById('seriesHubScreen');
    if(sh && sh.classList.contains('active')){
      if(typeof closeSeriesHub === 'function') closeSeriesHub();
    }
  }catch(e){}
// Navigera till "Turneringar" (hubben där man kan öppna/ladda turneringar)
  // Viktigt: ingen history/hash-navigering här, annars triggas back-guard overlay på vissa Android-webviews.
  try{ doSave(true); }catch(e){}
  try{
    if(typeof window.__showLocalHub === "function"){
      window.__showLocalHub();
    }else{
      // Fallback: visa localHubScreen direkt om hjälpfunktionen saknas
      try{
        var el = document.getElementById("localHubScreen");
        if(el){
          // dölj startsida om den finns
          try{ document.getElementById("startScreen")?.classList.remove("active"); }catch(e){}
          el.classList.add("active");
          el.setAttribute("aria-hidden","false");
        }
      }catch(e2){}
    }
  }catch(e){}
  try{ window.scrollTo(0,0); }catch(e){}
  try{ if(typeof setBottomNav === 'function') setBottomNav(); }catch(e){}
}


function goStep(n){
  try{ closeMenu(); }catch(e){}
  // Om Serie-hubb är öppen: stäng den innan vi byter flik/step
  try{
    var sh = document.getElementById('seriesHubScreen');
    if(sh && sh.classList.contains('active')){
      if(typeof closeSeriesHub === 'function') closeSeriesHub();
    }
  }catch(e){}
  var nums = getStepNums();
  if(state.step===1){ state.format = $("format").value; var ng = $("numGroups"); if(ng) state.numGroups = parseInt(ng.value||"2",10)||2; }
  if(state.step===2){
    state.rules.game = $("game").value;
    state.rules.inRule = $("inRule").value;
    state.rules.outRule = $("outRule").value;
    state.rules.legsMode = $("legsMode").value;
  }

  // Kräv att turnering/matcher är skapade innan man går till Matcher/Tabell/Slutspel
  if((n===nums.matches || n===nums.table || n===nums.playoffs) && (!state.matches || state.matches.length===0)){
    alert("Skapa turnering först (steg 3).");
    return;
  }

  state.step = n;
  saveState();
  renderAll();
  try{ window.scrollTo(0,0); }catch(e){}
  try{ if(typeof setBottomNav === 'function') setBottomNav(); }catch(e){}
}

// Öppna spelare från startsidan (utan att behöva skapa/återuppta turnering).
function openPlayerRegister(){
  state._playerRegisterOnly = true;
  state.step = 3;
  saveState();
  renderAll();
  try{ window.scrollTo(0,0); }catch(e){}
}


// Öppna spelregister som popup (från Turneringar-sidan)
function openPlayerRegisterPopup(){
  var ov = document.getElementById('playerRegisterOverlay');
  if(!ov) return;
  ov.classList.remove('hidden');
  renderPlayerRegisterPopup();
}
function closePlayerRegisterPopup(){
  var ov = document.getElementById('playerRegisterOverlay');
  if(!ov) return;
  ov.classList.add('hidden');
}
function renderPlayerRegisterPopup(){
  try{
    var body = document.getElementById('playerRegisterBody');
    if(!body) return;

    // Hämta alltid från samma lagring som Spelare-fliken (sparade profiler)
    var arr = [];
    try{ arr = _loadSaved(SAVED_PLAYERS_KEY) || []; }catch(e){ arr = []; }
    if(!Array.isArray(arr)) arr = [];

    var html = ''
      + '<div class="card" style="box-shadow:none;border:1px solid #eef1f6">'
      +   '<div style="font-size:22px;font-weight:800;margin:0 0 10px">Befintliga spelare</div>'
      +   '<div class="row" style="gap:10px;align-items:center">'
      +     '<select id="popupSavedPlayerSelect" style="flex:1;min-width:220px"></select>'
      +   '</div>'
      + '</div>';
    body.innerHTML = html;

    var sel = document.getElementById('popupSavedPlayerSelect');
    if(!sel) return;
    sel.innerHTML = '';

    var opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = '— Välj —';
    sel.appendChild(opt0);

    (arr||[])
      .slice()
      .sort(function(a,b){
        var an=(a&&a.name?String(a.name):'').toLowerCase();
        var bn=(b&&b.name?String(b.name):'').toLowerCase();
        return an<bn?-1:an>bn?1:0;
      })
      .forEach(function(p){
        var pid = p.id || p.pid || p.playerId || '';
        var name = (p.name || p.namn || '').trim();
        if(!name) return;
        var opt = document.createElement('option');
        opt.value = String(pid||name);
        opt.textContent = String(name);
        sel.appendChild(opt);
      });

    // Rullistan är främst för överblick (ingen auto-navigering).
    // För att skapa/ändra: använd knappen "Ny / Ändra".
  }catch(e){
    console.error(e);
  }
}

function closePlayerRegister(){
  state._playerRegisterOnly = false;
  state.step = 1;
  saveState();
  renderAll();
  try{ window.scrollTo(0,0); }catch(e){}
}


function escapeHtml(s){
  return (""+s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[c]));
}

function escapeAttr(s){
  return escapeHtml(String(s||"")).replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function escapeJs(s){
  return String(s||"")
    .replace(/\\/g,"\\\\")
    .replace(/'/g,"\\'")
    .replace(/\n/g," ")
    .replace(/\r/g," ");
}

// Robust ID-generator (för spelare/matcher) som funkar även i äldre mobilwebbläsare.
// - Föredrar crypto.randomUUID()
// - Annars crypto.getRandomValues()
// - Annars Math.random() fallback
function cryptoId(){
  try{
    if(window.crypto && typeof window.crypto.randomUUID === "function"){
      return window.crypto.randomUUID();
    }
    if(window.crypto && typeof window.crypto.getRandomValues === "function"){
      const bytes = new Uint8Array(16);
      window.crypto.getRandomValues(bytes);
      // Sätt version/variant-bitar ungefär som UUIDv4 (inte kritiskt, men trevligt).
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = [...bytes].map(b=>b.toString(16).padStart(2,"0")).join("");
      return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
    }
  }catch(e){ /* fall through */ }
  // Fallback: tillräckligt unikt för denna app
  return "id_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
}

function parseLines(text){
  return (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
}

function setEntryMode(mode){
  state.entryMode = mode;
  if(state.entryMode!=='import' && state.entryMode!=='kiosk') state.entryMode='import';
  applyEntryUI();
  var ks=document.getElementById('kioskStatus'); if(ks) ks.textContent='';
  savedEditingPlayerId=null; savedEditingTeamId=null;
  try{ renderKioskList(); }catch(e){}
  saveState();
}

function applyEntryUI(){
  var isTeam = (state.mode==='team');
  var minTxt = document.getElementById('minParticipantsText');
  if(minTxt) minTxt.textContent = isTeam ? 'Minst 3 lag.' : 'Minst 3 spelare.';

  // växla mellan singel- och lagfält
  var teamWrap = document.getElementById('teamFieldsWrap');
  if(teamWrap) teamWrap.classList.toggle('hidden', (!isTeam) || (state.entryMode!=='import'));

  // växla mellan import och kiosk
  var kioskWrap = document.getElementById('entryKioskWrap');
  if(kioskWrap) kioskWrap.classList.toggle('hidden', state.entryMode!=='kiosk');

  var importWrap = document.getElementById('manualPlayersWrap');
  if(importWrap) importWrap.classList.toggle('hidden', (state.entryMode!=='import' || isTeam));

  // knapparnas "valda" känsla
  var bI = document.getElementById('btnEntryImport');
  var bK = document.getElementById('btnEntryKiosk');
  if(bI) bI.style.opacity = (state.entryMode==='import') ? '1' : '0.75';
  if(bK) bK.style.opacity = (state.entryMode==='kiosk') ? '1' : '0.75';

  // kiosk: visa rätt formulär beroende på läge
  var ks=document.getElementById('kioskSingleForm');
  var kt=document.getElementById('kioskTeamForm');
  var ktit=document.getElementById('kioskTitle');
  if(ks) ks.classList.toggle('hidden', isTeam);
  if(kt) kt.classList.toggle('hidden', !isTeam);
  if(ktit) ktit.textContent = isTeam ? 'Lägg till lag' : 'Lägg till spelare';

  // synka select
  var ms=document.getElementById('mode');
  if(ms && ms.value !== state.mode) ms.value = state.mode;

  var ks=document.getElementById('kioskStatus'); if(ks) ks.textContent='';
  try{ refreshSavedDropdowns(); 
    
    try{ if(window.__modalAvatarPid) window.__modalAvatarPid.single = null; }catch(e){}
try{ if(window.__modalAvatarPid) window.__modalAvatarPid.team = null; }catch(e){}
}catch(e){}
  renderKioskList();
}

function openSpotify(){
  var url = 'https://open.spotify.com/search';
  try{ window.location.href = url; }catch(e){}
}

function defocusKeyboard(){
  try{
    var ae = document.activeElement;
    if(ae && typeof ae.blur === 'function') ae.blur();
  }catch(e){}
  try{
    var sink = document.getElementById('focusSink');
    if(sink && typeof sink.focus === 'function') sink.focus({preventScroll:true});
  }catch(e){}
}



// ---- Sparade profiler (lokalt på enheten) ----
const SAVED_PLAYERS_KEY = "dart_saved_players_v1";
const SAVED_TEAMS_KEY = "dart_saved_teams_v1";


// Hjälp: hitta saved profile-id via namn (för att koppla avatar -> playerId)
function findSavedPlayerIdByName(name, kind){
  kind = (kind==="team") ? "team" : "single";
  var key = (kind==="team") ? SAVED_TEAMS_KEY : SAVED_PLAYERS_KEY;
  try{
    var list = _loadSaved(key) || [];
    var low = (name||"").trim().toLowerCase();
    var rec = list.find(function(p){
      var nm = (kind==="team") ? (p.teamName||"") : (p.name||"");
      return (nm||"").trim().toLowerCase() === low;
    });
    return rec ? rec.id : null;
  }catch(e){
    return null;
  }
}

let savedEditingPlayerId = null;
let savedEditingTeamId = null;

function _loadSaved(key){
  try{
    const raw = localStorage.getItem(key);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function _saveSaved(key, arr){
  try{ localStorage.setItem(key, JSON.stringify(arr||[])); }catch(e){}
}


function addImportedPlayersToSaved(){
  try{
    if(!state) return;
    const source = (Array.isArray(state.importedPlayers) && state.importedPlayers.length) ? state.importedPlayers
                  : (Array.isArray(state.players) ? state.players : []);

    // Normalisera till {name, spotify, darts}
    const normalized = source.map(p=>{
      if(typeof p === "string") return { name: p, spotify:"", darts:"" };
      if(p && typeof p === "object"){
        return {
          name: (p.name||p.playerName||p.teamName||"").trim(),
          spotify: (p.spotify||p.walkonUrl||"").trim(),
          darts: (p.darts||"").trim()
        };
      }
      return { name:"", spotify:"", darts:"" };
    }).filter(p=>p.name);

    if(!normalized.length){
      alert("Hittade inga spelare att importera.");
      return;
    }

    if(!confirm("Lägg till " + normalized.length + " spelare i listan över sparade spelare?\n\nDubletter (samma namn) hoppar vi över, men vi kan fylla på Spotify/pilar om det saknas.")){
      return;
    }

    const list = _loadSaved(SAVED_PLAYERS_KEY) || [];
    const byName = (nm)=> (nm||"").trim().toLowerCase();

    let added = 0, updated = 0, skipped = 0;

    normalized.forEach(p=>{
      const low = byName(p.name);
      const ex = list.find(x => byName(x.name) === low);
      if(ex){
        let changed = false;
        if(p.spotify && !ex.spotify){ ex.spotify = p.spotify; changed = true; }
        if(p.darts && !ex.darts){ ex.darts = p.darts; changed = true; }
        if(changed) updated++; else skipped++;
      }else{
        list.push({ id: cryptoId(), name: p.name, spotify: p.spotify||"", darts: p.darts||"" });
        added++;
      }
    });

    _saveSaved(SAVED_PLAYERS_KEY, list);
    refreshSavedDropdowns();

    try{ state._importedTournament = false; }catch(e){}
    try{ saveState(); }catch(e){}
    try{ renderAll(); }catch(e){}

    const msg = "Klart! +"+added+" nya, "+updated+" uppdaterade, "+skipped+" oförändrade.";
    if(typeof toast==="function") toast(msg); else alert(msg);
  }catch(e){
    alert("Kunde inte importera spelare: " + (e && e.message ? e.message : e));
  }
}


function _byId(arr, id){ return (arr||[]).find(x=>x && x.id===id) || null; }

function refreshSavedDropdowns(){
  const spSel = document.getElementById("savedPlayerSelect");
  const tmSel = document.getElementById("savedTeamSelect");
  const dl = document.getElementById("singlePlayersList");

  const players = _loadSaved(SAVED_PLAYERS_KEY).sort((a,b)=>((a.name||"").localeCompare(b.name||"", 'sv')));
  const teams = _loadSaved(SAVED_TEAMS_KEY).sort((a,b)=>((a.teamName||"").localeCompare(b.teamName||"", 'sv')));

  if(spSel){
    spSel.innerHTML = '<option value="">— Välj —</option>' + players.map(p=>{
      const t = escapeHtml(p.name||"");
      return '<option value="'+escapeHtml(p.id)+'">'+t+'</option>';
    }).join("");
  }
  if(tmSel){
    tmSel.innerHTML = '<option value="">— Välj —</option>' + teams.map(t=>{
      const n = escapeHtml(t.teamName||"");
      return '<option value="'+escapeHtml(t.id)+'">'+n+'</option>';
    }).join("");
  }

  // Datalist för att kunna välja redan registrerade singelspelare när man bygger lag
  if(dl){
    dl.innerHTML = players.map(p=>{
      const t = escapeHtml(p.name||"");
      return '<option value="'+t+'"></option>';
    }).join("");
  }
}

// Tar bort ett option-element ur en <select> direkt (snabb UI-uppdatering)
function _removeSelectOptionByValue(sel, value){
  try{
    if(!sel || !value) return;
    // Om value finns, ta bort alla matchande options
    for(let i = sel.options.length - 1; i >= 0; i--){
      if(sel.options[i] && sel.options[i].value === value){
        sel.remove(i);
      }
    }
    // Säkerställ att ingen "död" value är vald
    if(sel.value === value) sel.value = "";
  }catch(e){}
}


function savedLoad(kind){
  if(kind==="team"){
    const sel = document.getElementById("savedTeamSelect");
    const id = sel ? sel.value : "";
    if(!id){ alert("Välj ett lag i rullistan först."); return; }
    const list = _loadSaved(SAVED_TEAMS_KEY);
    const t = _byId(list, id);
    if(!t){ alert("Kunde inte hitta laget."); return; }
    savedEditingTeamId = t.id;
    document.getElementById("kTeamName").value = t.teamName||"";
    document.getElementById("kTeamP1").value = (t.members && t.members[0]) ? t.members[0] : (t.p1||"");
    document.getElementById("kTeamP2").value = (t.members && t.members[1]) ? t.members[1] : (t.p2||"");
    document.getElementById("kTeamSpotify").value = t.spotify||"";
    document.getElementById("kTeamDarts").value = t.darts||"";
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Laddat lag: " + (t.teamName||"");
    return true;
  }else{
    const sel = document.getElementById("savedPlayerSelect");
    const id = sel ? sel.value : "";
    if(!id){ alert("Välj en spelare i rullistan först."); return; }
    const list = _loadSaved(SAVED_PLAYERS_KEY);
    const p = _byId(list, id);
    if(!p){ alert("Kunde inte hitta spelaren."); return; }
    savedEditingPlayerId = p.id;
    document.getElementById("kName").value = p.name||"";
    document.getElementById("kSpotify").value = p.spotify||"";
    document.getElementById("kDarts").value = p.darts||"";
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Laddat: " + (p.name||"");
  }
}

// Snabbt: välj sparad profil och lägg till direkt i turneringen (utan att scrolla)
function savedQuickAdd(kind){
  // Robust: använd alltid aktuellt turneringsläge som källa till sanning
  var mode = (typeof state !== "undefined" && state && state.mode) ? state.mode : "single";
  var effectiveKind = (mode === "team") ? "team" : "single";

  // Om fel kind skickats, rätta automatiskt
  if(kind !== "team" && kind !== "single") kind = effectiveKind;

  // Om UI visar den andra listan (t.ex. efter lägesbyte), fall back till den som har val
  var selPrimary = document.getElementById(kind === "team" ? "savedTeamSelect" : "savedPlayerSelect");
  var selSecondary = document.getElementById(kind === "team" ? "savedPlayerSelect" : "savedTeamSelect");

  var id = (selPrimary && selPrimary.value) ? selPrimary.value : "";
  if(!id && selPrimary && selPrimary.selectedIndex > 0){
    id = selPrimary.options[selPrimary.selectedIndex].value || "";
  }
  if(!id && selSecondary){
    var sid = selSecondary.value || "";
    if(!sid && selSecondary.selectedIndex > 0){
      sid = selSecondary.options[selSecondary.selectedIndex].value || "";
    }
    if(sid){
      // Byt kind till den listan användaren faktiskt valde i
      kind = (kind === "team") ? "single" : "team";
      id = sid;
    }
  }

  if(!id){
    alert("Välj en spelare i rullistan först.");
    return;
  }

  // Ladda profilen direkt (utan att kräva separat 'Ladda'-klick)
  savedLoad(kind);

  // Lägg till i turneringen
  if(kind === "team"){
    kioskAddTeam();
  }else{
    kioskAddSingle();
  }
}



function savedDelete(kind){
  try{
    const isTeam = (kind === "team");

    // Föredra modalens rullista om den finns (Ny / Ändra)
    const modalSelId = isTeam ? "modalSavedTeamSelect" : "modalSavedPlayerSelect";
    const mainSelId  = isTeam ? "savedTeamSelect" : "savedPlayerSelect";
    const modalSel = document.getElementById(modalSelId);
    const mainSel  = document.getElementById(mainSelId);

    const id = (modalSel && modalSel.value) ? modalSel.value : (mainSel ? mainSel.value : "");
    if(!id){
      toast("Välj en profil att ta bort.");
      return;
    }

    // En enda bekräftelse (räcker)
    if(!confirm("Ta bort profilen permanent?")) return;

    const key = isTeam ? SAVED_TEAMS_KEY : SAVED_PLAYERS_KEY;
    const list = _loadSaved(key).filter(x => x && x.id !== id);
    _saveSaved(key, list);

    // Ta bort option direkt ur rullistorna (så det försvinner utan flikbyte)
    _removeSelectOptionByValue(modalSel, id);
    _removeSelectOptionByValue(mainSel, id);

    // Nollställ val i båda rullistorna
    if(modalSel) modalSel.value = "";
    if(mainSel)  mainSel.value  = "";

    // Nollställ ev. laddat formulär
    if(isTeam){
      state.kiosk.team.selectedSavedId = "";
      state.kiosk.team.teamName = "";
      state.kiosk.team.spotify = "";
      state.kiosk.team.darts = "";
    }else{
      state.kiosk.player.selectedSavedId = "";
      state.kiosk.player.name = "";
      state.kiosk.player.spotify = "";
      state.kiosk.player.darts = "";
    }

    refreshSavedDropdowns();
    // Uppdatera även modalens rullista direkt om den är öppen
    if(typeof refreshNewPlayerModalSelect === "function"){
      refreshNewPlayerModalSelect(isTeam ? "team" : "single");
    }

    
    // Uppdatera huvudvyns rullistor så att borttagen profil försvinner direkt
    if(typeof refreshSavedDropdowns === "function"){
      refreshSavedDropdowns();
      if(mainSel) mainSel.value = "";
      if(modalSel) modalSel.value = "";
    }

// Rendera om spelarsidan (rätt funktion i denna fil)
    if(typeof renderPlayersStep === "function") renderPlayersStep();
    else if(typeof renderAll === "function") renderAll();

    toast("Profil borttagen.");
  }catch(e){
    console.error(e);
    toast("Kunde inte ta bort profilen.");
  }
}


function savedUpsertFromForm(kind){
  if(kind==="team"){
    const teamName = (document.getElementById("kTeamName").value||"").trim();
    const p1 = (document.getElementById("kTeamP1").value||"").trim();
    const p2 = (document.getElementById("kTeamP2").value||"").trim();
    if(!teamName){ alert("Skriv in ett lagnamn."); return false; }
    if(!p1 || !p2){ alert("Fyll i båda spelarna i laget."); return false; }
    const spotify = (document.getElementById("kTeamSpotify").value||"").trim();
    const darts = (document.getElementById("kTeamDarts").value||"").trim();

    let list = _loadSaved(SAVED_TEAMS_KEY);
    const id = savedEditingTeamId || cryptoId();
    // Förhindra att man råkar skapa dubletter med samma namn (om det inte är samma id)
    try{
      var low = (teamName||"").trim().toLowerCase();
      var clash = list.find(function(x){
        return x && x.id !== id && ((x.teamName||"").trim().toLowerCase() === low);
      });
      if(clash){ toast("Lagnamnet är redan sparat."); return false; }
    }catch(e){}
    const existing = _byId(list, id);
    const obj = { id, teamName, members:[p1,p2], spotify, darts };
    if(existing){
      Object.assign(existing, obj);
    }else{
      list.push(obj);
      savedEditingTeamId = id;
    }
    _saveSaved(SAVED_TEAMS_KEY, list);
    refreshSavedDropdowns();
    const sel = document.getElementById("savedTeamSelect"); if(sel) sel.value = id;
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Lag uppdaterat: " + teamName;
    toast("Laget är uppdaterat.");
    return true;
  }else{
    const name = (document.getElementById("kName").value||"").trim();
    if(!name){ alert("Skriv in ett namn."); return false; }
    const spotify = (document.getElementById("kSpotify").value||"").trim();
    const darts = (document.getElementById("kDarts").value||"").trim();

    let list = _loadSaved(SAVED_PLAYERS_KEY);
    const id = savedEditingPlayerId || cryptoId();
    // Förhindra att man råkar skapa dubletter med samma namn (om det inte är samma id)
    try{
      var low = (name||"").trim().toLowerCase();
      var clash = list.find(function(x){
        return x && x.id !== id && ((x.name||"").trim().toLowerCase() === low);
      });
      if(clash){ toast("Spelaren är redan sparad."); return false; }
    }catch(e){}
    const existing = _byId(list, id);
    const obj = { id, name, spotify, darts };
    if(existing){
      Object.assign(existing, obj);
    }else{
      list.push(obj);
      savedEditingPlayerId = id;
    }
    _saveSaved(SAVED_PLAYERS_KEY, list);
    refreshSavedDropdowns();
    const sel = document.getElementById("savedPlayerSelect"); if(sel) sel.value = id;
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Spelare uppdaterad: " + name;
    toast("Spelaren är uppdaterad.");
    return true;
  }
}

// Om en spelare/lag redan ligger under "Tillagda" för aktuell turnering, uppdatera raderna där också
function _updateAddedSingleLines(oldName, newName, spotify, darts){
  try{
    oldName = (oldName||"").trim();
    newName = (newName||"").trim();
    if(!oldName || !newName) return;
    var p = document.getElementById('players');
    var s = document.getElementById('spotifyLinks');
    var d = document.getElementById('darts');
    if(!p || !s || !d) return;
    var pLines = parseLines(p.value);
    var sLines = parseLines(s.value);
    var dLines = parseLines(d.value);
    var lowOld = oldName.toLowerCase();
    for(var i=0;i<pLines.length;i++){
      if(((pLines[i]||"").trim().toLowerCase()) === lowOld){
        pLines[i] = newName;
        // säkra att arrayerna är långa nog
        while(sLines.length < pLines.length) sLines.push('');
        while(dLines.length < pLines.length) dLines.push('');
        sLines[i] = spotify || '';
        dLines[i] = darts || '';
        break;
      }
    }
    p.value = pLines.join('\n');
    s.value = sLines.join('\n');
    d.value = dLines.join('\n');
  }catch(e){}
}

function _updateAddedTeamLines(oldTeamName, newTeamName, p1, p2, spotify, darts){
  try{
    oldTeamName = (oldTeamName||"").trim();
    newTeamName = (newTeamName||"").trim();
    if(!oldTeamName || !newTeamName) return;
    var tn = document.getElementById('teamNames');
    var m1 = document.getElementById('teamMember1');
    var m2 = document.getElementById('teamMember2');
    var sp = document.getElementById('teamSpotify');
    var da = document.getElementById('teamDarts');
    if(!tn || !m1 || !m2 || !sp || !da) return;
    var tLines = parseLines(tn.value);
    var m1Lines = parseLines(m1.value);
    var m2Lines = parseLines(m2.value);
    var spLines = parseLines(sp.value);
    var daLines = parseLines(da.value);
    var lowOld = oldTeamName.toLowerCase();
    for(var i=0;i<tLines.length;i++){
      if(((tLines[i]||"").trim().toLowerCase()) === lowOld){
        tLines[i] = newTeamName;
        while(m1Lines.length < tLines.length) m1Lines.push('');
        while(m2Lines.length < tLines.length) m2Lines.push('');
        while(spLines.length < tLines.length) spLines.push('');
        while(daLines.length < tLines.length) daLines.push('');
        m1Lines[i] = p1 || '';
        m2Lines[i] = p2 || '';
        spLines[i] = spotify || '';
        daLines[i] = darts || '';
        break;
      }
    }
    tn.value = tLines.join('\n');
    m1.value = m1Lines.join('\n');
    m2.value = m2Lines.join('\n');
    sp.value = spLines.join('\n');
    da.value = daLines.join('\n');
  }catch(e){}
}

function savedSaveNewFromForm(kind){
  if(kind==="team"){
    const teamName = (document.getElementById("kTeamName").value||"").trim();
    const p1 = (document.getElementById("kTeamP1").value||"").trim();
    const p2 = (document.getElementById("kTeamP2").value||"").trim();
    if(!teamName){ alert("Skriv in ett lagnamn."); return false; }
    if(!p1 || !p2){ alert("Fyll i båda spelarna i laget."); return false; }
    const spotify = (document.getElementById("kTeamSpotify").value||"").trim();
    const darts = (document.getElementById("kTeamDarts").value||"").trim();

    let list = _loadSaved(SAVED_TEAMS_KEY);

    // Om vi importerat en profil med avatar i modalen så finns ofta ett "för-reserverat" pid.
    // Använd samma id här så att avatar (IndexedDB) och profil får exakt samma nyckel direkt.
    var preId = null;
    try{ preId = (typeof savedEditingTeamId!=="undefined" && savedEditingTeamId) ? savedEditingTeamId : null; }catch(e){}
    try{ if(!preId && window.__modalAvatarPid) preId = window.__modalAvatarPid.team || null; }catch(e){}
    const id = preId || cryptoId();

    const rec = { id, teamName, members:[p1,p2], spotify, darts };
    const idx = list.findIndex(function(x){ return x && x.id === id; });
    if(idx >= 0) list[idx] = rec; else list.push(rec);

    _saveSaved(SAVED_TEAMS_KEY, list);
    refreshSavedDropdowns();

    // nollställ fälten så man kan skriva nästa direkt
    savedEditingTeamId = null;
    const sel = document.getElementById("savedTeamSelect"); if(sel) sel.value = "";
    document.getElementById("kTeamName").value = "";
    document.getElementById("kTeamP1").value = "";
    document.getElementById("kTeamP2").value = "";
    document.getElementById("kTeamSpotify").value = "";
    document.getElementById("kTeamDarts").value = "";
    try{ document.getElementById("kTeamName").focus(); }catch(e){}
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Sparat som ny: " + teamName;
    return true;
  }else{
    const name = (document.getElementById("kName").value||"").trim();
    if(!name){ alert("Skriv in ett namn."); return false; }
    const spotify = (document.getElementById("kSpotify").value||"").trim();
    const darts = (document.getElementById("kDarts").value||"").trim();

    let list = _loadSaved(SAVED_PLAYERS_KEY);

    // Om vi importerat en profil med avatar i modalen så finns ofta ett "för-reserverat" pid.
    // Använd samma id här så att avatar (IndexedDB) och profil får exakt samma nyckel direkt.
    var preId = null;
    try{ preId = (typeof savedEditingPlayerId!=="undefined" && savedEditingPlayerId) ? savedEditingPlayerId : null; }catch(e){}
    try{ if(!preId && window.__modalAvatarPid) preId = window.__modalAvatarPid.single || null; }catch(e){}
    const id = preId || cryptoId();

    const rec = { id, name, spotify, darts };
    const idx = list.findIndex(function(x){ return x && x.id === id; });
    if(idx >= 0) list[idx] = rec; else list.push(rec);

    _saveSaved(SAVED_PLAYERS_KEY, list);
    refreshSavedDropdowns();

    // nollställ fälten så man kan skriva nästa direkt
    savedEditingPlayerId = null;
    const sel = document.getElementById("savedPlayerSelect"); if(sel) sel.value = "";
    document.getElementById("kName").value = "";
    document.getElementById("kSpotify").value = "";
    document.getElementById("kDarts").value = "";
    try{ document.getElementById("kName").focus(); }catch(e){}
    const st = document.getElementById("kioskStatus"); if(st) st.textContent = "Sparat som ny: " + name;
    return true;
  }
}


function exportSavedProfiles(){
  const data = {
    players: _loadSaved(SAVED_PLAYERS_KEY),
    teams: _loadSaved(SAVED_TEAMS_KEY),
    exportedAt: new Date().toISOString()
  };
  const ta = document.getElementById("savedProfilesBox");
  if(ta) ta.value = JSON.stringify(data, null, 2);
  try{ ta && ta.focus(); ta && ta.select(); }catch(e){}
}

function importSavedProfiles(){
  const ta = document.getElementById("savedProfilesBox");
  const raw = ta ? ta.value.trim() : "";
  if(!raw){ alert("Klistra in text först."); return; }
  let obj;
  try{ obj = JSON.parse(raw); }catch(e){ alert("Ogiltig text/JSON."); return; }
  const players = Array.isArray(obj.players) ? obj.players : [];
  const teams = Array.isArray(obj.teams) ? obj.teams : [];
  // normalisera
  const p2 = players.map(p=>({ id: p.id||cryptoId(), name: (p.name||"").trim(), spotify:(p.spotify||"").trim(), darts:(p.darts||"").trim() })).filter(p=>p.name);
  const t2 = teams.map(t=>({ id: t.id||cryptoId(), teamName:(t.teamName||"").trim(), members:[((t.members&&t.members[0])||t.p1||"").trim(), ((t.members&&t.members[1])||t.p2||"").trim()], spotify:(t.spotify||"").trim(), darts:(t.darts||"").trim() })).filter(t=>t.teamName && t.members[0] && t.members[1]);
  _saveSaved(SAVED_PLAYERS_KEY, p2);
  _saveSaved(SAVED_TEAMS_KEY, t2);
  refreshSavedDropdowns();
  alert("Importerade sparade profiler: " + p2.length + " spelare, " + t2.length + " lag.");
}

function clearSavedProfiles(){
  if(!confirm("Rensa alla sparade spelare och lag på denna enhet?")) return;
  try{ localStorage.removeItem(SAVED_PLAYERS_KEY); localStorage.removeItem(SAVED_TEAMS_KEY); }catch(e){}
  savedEditingPlayerId = null;
  savedEditingTeamId = null;
  refreshSavedDropdowns();
  const ta = document.getElementById("savedProfilesBox"); if(ta) ta.value = "";
}

function clearStatsOnly(){
  if(!confirm("Rensa all sparad statistik/historik på denna enhet? (Sparade spelare och lag behålls)")) return;
  try{ localStorage.removeItem(HISTORY_KEY); }catch(e){}
  // Om en profilruta/historik är öppen, stäng och uppdatera vyer
  try{ closeProfile(); }catch(e){}
  try{ closeHistoryModal(); }catch(e){}
  // Uppdatera ev. visning om du står på en profilsida just nu
  try{ renderAll(); }catch(e){}
}




function kioskAddSingle(){
  var name=(document.getElementById('kName').value||'').trim();
  if(!name){ alert('Skriv in ett namn.'); return false; }
  var sp=(document.getElementById('kSpotify').value||'').trim();
  var da=(document.getElementById('kDarts').value||'').trim();
  // Förhindra dubletter i "Tillagda"
  try{
    var existing = parseLines($('players').value).map(function(x){return (x||'').trim().toLowerCase();}).filter(Boolean);
    if(existing.indexOf(name.toLowerCase()) !== -1){
      if(typeof toast === "function") toast("Spelaren är redan tillagd.");
      else alert("Spelaren är redan tillagd.");
      // Rensa fält för snabb fortsättning
      document.getElementById('kName').value='';
      document.getElementById('kSpotify').value='';
      document.getElementById('kDarts').value='';
      renderKioskList();
      return false;
    }
  }catch(e){}

  // spara spelare för framtiden (lokalt)
  try{
    
      var list=_loadSaved(SAVED_PLAYERS_KEY);
      // om man har laddat en sparad profil: uppdatera den (även om namn ändras)
      if(savedEditingPlayerId){
        var exId=_byId(list, savedEditingPlayerId);
        if(exId){ exId.name=name; exId.spotify=sp; exId.darts=da; }
        else{ list.push({id:savedEditingPlayerId, name:name, spotify:sp, darts:da}); }
      }else{
        // annars: uppdatera om samma namn finns, annars skapa ny
        var low=name.toLowerCase();
        var ex=list.find(function(p){return ((p.name||'').trim().toLowerCase()===low);});
        if(ex){ ex.spotify=sp; ex.darts=da; }
        else{ list.push({id:cryptoId(), name:name, spotify:sp, darts:da}); }
      }
      _saveSaved(SAVED_PLAYERS_KEY, list);
      refreshSavedDropdowns();
      var sel=document.getElementById('savedPlayerSelect'); if(sel) sel.value='';
      savedEditingPlayerId=null;
  }catch(e){}

  try{ if($('players')) $('players').value = (parseLines($('players').value).concat([name])).join('\n'); }catch(e){}
  try{ if($('spotifyLinks')) $('spotifyLinks').value = (parseLines($('spotifyLinks').value).concat([sp])).join('\n'); }catch(e){}
  try{ if($('darts')) $('darts').value = (parseLines($('darts').value).concat([da])).join('\n'); }catch(e){}
  try{ if($('walkonLabels')) $('walkonLabels').value = (parseLines($('walkonLabels').value).concat([''])).join('\n'); }catch(e){}

  document.getElementById('kName').value='';
  document.getElementById('kSpotify').value='';
  document.getElementById('kDarts').value='';
  // Undvik att öppna tangentbordet efter snabb-add från rullistan
  var ae = null;
  try{ ae = document.activeElement; }catch(e){}
  var shouldRefocus = !!(ae && (ae.id==='kName' || ae.id==='kSpotify' || ae.id==='kDarts'));
  if(shouldRefocus){
    try{ document.getElementById('kName').focus({preventScroll:true}); }catch(e){}
  }else{
    defocusKeyboard();
  }
  renderKioskList();
  return true;
}

function kioskAddTeam(){
  var team=(document.getElementById('kTeamName').value||'').trim();
  var p1=(document.getElementById('kTeamP1').value||'').trim();
  var p2=(document.getElementById('kTeamP2').value||'').trim();
  if(!team){ alert('Skriv in ett lagnamn.'); return; }
  if(!p1 || !p2){ alert('Fyll i båda spelarna i laget.'); return false; }

  var existing=parseLines(($('teamNames')?$('teamNames').value:'')).map(function(x){return (x||'').trim().toLowerCase();});
  // Förhindra dubletter i "Tillagda"
  try{
    var lowTeam = (team||'').trim().toLowerCase();
    if(lowTeam && existing.indexOf(lowTeam) !== -1){
      if(typeof toast === "function") toast("Laget är redan tillagt.");
      else alert("Laget är redan tillagt.");
      document.getElementById('kTeamName').value='';
      document.getElementById('kTeamP1').value='';
      document.getElementById('kTeamP2').value='';
      document.getElementById('kTeamSpotify').value='';
      document.getElementById('kTeamDarts').value='';
      renderKioskList();
      return false;
    }
  }catch(e){}
  if(existing.indexOf(team.toLowerCase())>=0){ alert('Lagnamnet finns redan.'); return; }

  var sp=(document.getElementById('kTeamSpotify').value||'').trim();
  var da=(document.getElementById('kTeamDarts').value||'').trim();

  // spara lag för framtiden (lokalt)
  try{
    
      var list=_loadSaved(SAVED_TEAMS_KEY);
      if(savedEditingTeamId){
        var exId=_byId(list, savedEditingTeamId);
        var obj={id:savedEditingTeamId, teamName:team, members:[p1,p2], spotify:sp, darts:da};
        if(exId){ Object.assign(exId, obj); }
        else{ list.push(obj); }
      }else{
        var low=team.toLowerCase();
        var ex=list.find(function(t){return ((t.teamName||'').trim().toLowerCase()===low);});
        if(ex){ ex.members=[p1,p2]; ex.spotify=sp; ex.darts=da; }
        else{ list.push({id:cryptoId(), teamName:team, members:[p1,p2], spotify:sp, darts:da}); }
      }
      _saveSaved(SAVED_TEAMS_KEY, list);
      refreshSavedDropdowns();
      var sel=document.getElementById('savedTeamSelect'); if(sel) sel.value='';
      savedEditingTeamId=null;
  }catch(e){}


  $('teamNames').value = (parseLines($('teamNames').value).concat([team])).join('\n');
  $('teamMember1').value = (parseLines($('teamMember1').value).concat([p1])).join('\n');
  $('teamMember2').value = (parseLines($('teamMember2').value).concat([p2])).join('\n');
  $('teamSpotify').value = (parseLines($('teamSpotify').value).concat([sp])).join('\n');
  $('teamDarts').value = (parseLines($('teamDarts').value).concat([da])).join('\n');

  document.getElementById('kTeamName').value='';
  document.getElementById('kTeamP1').value='';
  document.getElementById('kTeamP2').value='';
  document.getElementById('kTeamSpotify').value='';
  document.getElementById('kTeamDarts').value='';
  // Undvik att öppna tangentbordet efter snabb-add från rullistan
  var ae2 = null;
  try{ ae2 = document.activeElement; }catch(e){}
  var shouldRefocus2 = !!(ae2 && (ae2.id==='kTeamName' || ae2.id==='kTeamP1' || ae2.id==='kTeamP2' || ae2.id==='kTeamSpotify' || ae2.id==='kTeamDarts'));
  if(shouldRefocus2){
    try{ document.getElementById('kTeamName').focus({preventScroll:true}); }catch(e){}
  }else{
    defocusKeyboard();
  }
  renderKioskList();
  return true;
}


function kioskRemoveAt(idx){
  if(state.mode==='team'){
    var tn=parseLines($('teamNames').value), a=parseLines($('teamMember1').value), b=parseLines($('teamMember2').value),
        sp=parseLines($('teamSpotify').value), da=parseLines($('teamDarts').value);
    tn.splice(idx,1); a.splice(idx,1); b.splice(idx,1); sp.splice(idx,1); da.splice(idx,1);
    $('teamNames').value=tn.join('\n'); $('teamMember1').value=a.join('\n'); $('teamMember2').value=b.join('\n');
    $('teamSpotify').value=sp.join('\n'); $('teamDarts').value=da.join('\n');
  }else{
    var n=parseLines($('players').value), wl=parseLines($('walkonLabels').value), sp2=parseLines($('spotifyLinks').value), da2=parseLines($('darts').value);
    n.splice(idx,1); wl.splice(idx,1); sp2.splice(idx,1); da2.splice(idx,1);
    $('players').value=n.join('\n'); $('walkonLabels').value=wl.join('\n'); $('spotifyLinks').value=sp2.join('\n'); $('darts').value=da2.join('\n');
  }
  renderKioskList();
}


function kioskEditAt(idx){
  try{
    if(state.mode==='team'){
      var tn=parseLines($('teamNames').value), a=parseLines($('teamMember1').value), b=parseLines($('teamMember2').value),
          sp=parseLines(($('teamSpotify')?$('teamSpotify').value:'')), da=parseLines(($('teamDarts')?$('teamDarts').value:''));
      var teamName = ((tn[idx]||'')+'').trim();
      if(!teamName) return;
      openNewPlayerModal('team');

      // Försök ladda sparad profil om den finns
      var saved = _findSavedTeamByName(teamName);
      if(saved && saved.id){
        try{
          var sel = document.getElementById('modalSavedTeamSelect');
          if(sel){ sel.value = saved.id; sel.dispatchEvent(new Event('change')); }
        }catch(e){}
        return;
      }

      // Annars: fyll med det som finns i listan (snabb ändring / spara som ny profil)
      try{
        if(!savedEditingTeamId) savedEditingTeamId = cryptoId();
        window.__modalAvatarPid['team'] = savedEditingTeamId;
      }catch(e){}
      try{
        document.getElementById('kTeamName').value = teamName;
        document.getElementById('kTeamP1').value = (a[idx]||'').trim();
        document.getElementById('kTeamP2').value = (b[idx]||'').trim();
        if(document.getElementById('kTeamSpotify')) document.getElementById('kTeamSpotify').value = (sp[idx]||'').trim();
        if(document.getElementById('kTeamDarts')) document.getElementById('kTeamDarts').value = (da[idx]||'').trim();
      }catch(e){}
      try{
        var ab = document.getElementById('modalAvatarBtnTeam');
        if(ab){
          ab.setAttribute('data-avatar-pid', savedEditingTeamId||'');
          ab.setAttribute('data-avatar-name', teamName||'');
          var spn = ab.querySelector('span'); if(spn) spn.textContent = _avatarInitials(teamName||'')||'?';
          hydrateAvatarsIn(document.getElementById('modalAvatarRowTeam')||ab.parentNode);
        }
      }catch(e){}
    }else{
      var n=parseLines($('players').value),
          sp2=parseLines(($('spotifyLinks')?$('spotifyLinks').value:'')),
          da2=parseLines(($('darts')?$('darts').value:''));
      var name = ((n[idx]||'')+'').trim();
      if(!name) return;
      openNewPlayerModal('single');

      var savedP = _findSavedPlayerByName(name);
      if(savedP && savedP.id){
        try{
          var sel2 = document.getElementById('modalSavedPlayerSelect');
          if(sel2){ sel2.value = savedP.id; sel2.dispatchEvent(new Event('change')); }
        }catch(e){}
        return;
      }

      // Annars: fyll med det som finns i turneringen och låt användaren spara profilen
      try{
        if(!savedEditingPlayerId) savedEditingPlayerId = cryptoId();
        window.__modalAvatarPid['single'] = savedEditingPlayerId;
      }catch(e){}
      try{
        document.getElementById('kName').value = name;
        if(document.getElementById('kSpotify')) document.getElementById('kSpotify').value = (sp2[idx]||'').trim();
        if(document.getElementById('kDarts')) document.getElementById('kDarts').value = (da2[idx]||'').trim();
      }catch(e){}
      try{
        var ab2 = document.getElementById('modalAvatarBtnSingle');
        if(ab2){
          ab2.setAttribute('data-avatar-pid', savedEditingPlayerId||'');
          ab2.setAttribute('data-avatar-name', name||'');
          var spn2 = ab2.querySelector('span'); if(spn2) spn2.textContent = _avatarInitials(name||'')||'?';
          hydrateAvatarsIn(document.getElementById('modalAvatarRowSingle')||ab2.parentNode);
        }
      }catch(e){}
    }
  }catch(e){
    console.error(e);
  }
}

// behövs för onclick
window.kioskEditAt = kioskEditAt;


function renderKioskList(){
  var boxes=[document.getElementById('kioskList'), document.getElementById('kioskTeamList')].filter(Boolean);
  if(!boxes.length) return;

  var items=[];
  if(state.mode==='team'){
    var tn=parseLines(($('teamNames')?$('teamNames').value:'')),
        a=parseLines(($('teamMember1')?$('teamMember1').value:'')),
        b=parseLines(($('teamMember2')?$('teamMember2').value:''));
    for(var i=0;i<tn.length;i++){
      var title=(tn[i]||'').trim();
      if(!title) continue;
      items.push({title:title, sub: ((a[i]||'').trim()+' & '+(b[i]||'').trim()).trim(), pid:_avatarPlayerIdFromAddedTitle(title)});
    }
  }else{
    var n=parseLines($('players').value);
    for(var j=0;j<n.length;j++){
      var t=(n[j]||'').trim();
      if(!t) continue;
      items.push({title:t, sub:'', pid:_avatarPlayerIdFromAddedTitle(t)});
    }
  }

  function buildHtml(){
    if(!items.length) return "<div class='muted'>Inga tillagda än.</div>";
    return items.map(function(it,i){
      var sub = it.sub ? ("<div class='muted' style='margin-top:2px'>"+escapeHtml(it.sub)+"</div>") : "";
      return "<div class='row' style='justify-content:space-between;align-items:flex-start;border-bottom:1px solid #eef1f6;padding:8px 0'>"
        + "<div class='avatarRow'>"
          + "<button class='avatarBtn small' type='button' data-avatar-pid='"+(it.pid||"")+"' data-avatar-name='"+escapeAttr(it.title||"")+"' onclick=\"openAvatarModalResolved('"+(it.pid||"")+"', '"+escapeJs(it.title||"")+"')\">"
            + "<span>"+escapeHtml(_avatarInitials(it.title||""))+"</span>"
          + "</button>"
          + "<div class='avatarMeta' style='min-width:0'>" + "<button class='namebtn' type='button' onclick='kioskEditAt("+i+")'><strong>"+escapeHtml(it.title||('-'))+"</strong></button>"+sub+"</div>"
        + "</div>"
        + "<button class='btn secondary' style='padding:6px 10px' type='button' onclick='kioskRemoveAt("+i+")'>Ta bort</button>"
        + "</div>";
    }).join("");
  }

  var html = buildHtml();
  boxes.forEach(function(box){ box.innerHTML = html; try{ hydrateAvatarsIn(box); }catch(e){} });
}

// behövs för onclick
window.kioskRemoveAt = kioskRemoveAt;


function parseWalkonLine(line){
  const parts = line.split("|");
  if(parts.length===1) return { label: parts[0].trim(), url:"" };
  return { label: parts[0].trim(), url: parts.slice(1).join("|").trim() };
}

function normalizeSpotifyUrl(url){
  url = (url||"").trim();
  if(!url) return "";
  // Tillåt både https://open.spotify.com/... och spotify:track:...
  if(url.startsWith("spotify:")) return "https://open.spotify.com/" + url.replace(/^spotify:/,"").replace(/:/g,"/");
  if(url.startsWith("http://") || url.startsWith("https://")) return url;
  return url; // fallback
}

function buildPlayersFromInput(){
  // Manuell inmatning (rad per spelare)
  const names = parseLines($("players").value);
  const walkonLabels = parseLines(($("walkonLabels")?$("walkonLabels").value:""));
  const spotifyLinks = parseLines(($("spotifyLinks")?$("spotifyLinks").value:""));
  const darts = parseLines(($("darts")?$("darts").value:""));

  const players = names.map((name, i)=>{
    // Tillåt flera sätt att klistra in walk-on:
    // 1) Visningsnamn i "Walk-on (visningsnamn)" + länk i "Spotify-länk".
    // 2) En rad i "Walk-on" på formen: Visningsnamn | https://open.spotify.com/...
    // 3) Bara en Spotify-länk (i valfri av rutorna) – vi gör den klickbar ändå.
    const rawWalk = (walkonLabels[i]||"").trim();
    const parsed = parseWalkonLine(rawWalk);

    let label = (parsed.label||"").trim();
    let url = normalizeSpotifyUrl((parsed.url||"").trim());
    if(!url) url = normalizeSpotifyUrl((spotifyLinks[i]||"").trim());

    // Om användaren råkar klistra in länken i "visningsnamn"-rutan
    if(!url && /spotify\.(com|link)/i.test(label)){
      url = normalizeSpotifyUrl(label);
      label = "";
    }

    const _saved = _findSavedPlayerByName(name);
    const _pid = _saved && _saved.id ? _saved.id : cryptoId();

    return {
      id: _pid,
      name,
      walkonLabel: label,
      walkonUrl: url,
      darts: (darts[i]||"").trim(),
    };
  });

  return players;
}

function buildTeamsFromInput(){
  var teamNames = parseLines(($('teamNames') ? $('teamNames').value : ''));
  var m1 = parseLines(($('teamMember1') ? $('teamMember1').value : ''));
  var m2 = parseLines(($('teamMember2') ? $('teamMember2').value : ''));
  var sp = parseLines(($('teamSpotify') ? $('teamSpotify').value : ''));
  var da = parseLines(($('teamDarts') ? $('teamDarts').value : ''));

  var teams = [];
  for(var i=0;i<teamNames.length;i++){
    var tn = (teamNames[i]||'').trim();
    var a = (m1[i]||'').trim();
    var b = (m2[i]||'').trim();
    if(!tn) continue;
    if(!a || !b) continue;
    const _savedT = _findSavedTeamByName(tn);
    const _tid = _savedT && _savedT.id ? _savedT.id : cryptoId();
    teams.push({
      id: _tid,
      type: 'team',
      teamName: tn,
      members: [a,b],
      walkonLabel: '',
      walkonUrl: (sp[i]||'').trim(),
      darts: (da[i]||'').trim(),
    });
  }
  return teams;
}

function buildParticipantsFromInput(){
  return (state.mode === 'team') ? buildTeamsFromInput() : buildPlayersFromInput();
}


function playerById(pid){ return (state.players||[]).find(p=>p.id===pid); }

function playerInitial(pid){
  const name = playerName(pid) || "";
  const ch = name.trim().charAt(0);
  return ch ? ch.toUpperCase() : "?";
}

function playerName(pid){ var p=playerById(pid); if(!p) return ""; return (p.type==='team') ? (p.teamName||"") : (p.name||"");
}

function suggestGroups(playerIds, numGroups){
  const shuffled = shuffle(playerIds);
  numGroups = parseInt(numGroups || state.numGroups || 2, 10) || 2;

  // Standard (2 grupper): behåll exakt nuvarande beteende
  if(numGroups !== 4){
    const aSize = Math.ceil(playerIds.length/2);
    return { A: shuffled.slice(0,aSize), B: shuffled.slice(aSize) };
  }

  // Utökat (4 grupper): fördela så jämnt som möjligt (maxexempel: 16 spelare => 4x4)
  const n = shuffled.length;
  const base = Math.floor(n / 4);
  const rem = n % 4;
  const sizes = [base, base, base, base];
  for(let i=0;i<rem;i++) sizes[i] += 1;

  let idx = 0;
  const A = shuffled.slice(idx, idx+=sizes[0]);
  const B = shuffled.slice(idx, idx+=sizes[1]);
  const C = shuffled.slice(idx, idx+=sizes[2]);
  const D = shuffled.slice(idx, idx+=sizes[3]);
  return { A, B, C, D };
}

function makeRoundRobinMatches(playerIds, repeats){
  repeats = repeats || 1;
  const ms=[];
  let id=0;
  for(let i=0;i<playerIds.length;i++){
    for(let j=i+1;j<playerIds.length;j++){
      for(let r=0;r<repeats;r++){
        const swap = (r % 2 === 1);
        const a = swap ? playerIds[j] : playerIds[i];
        const b = swap ? playerIds[i] : playerIds[j];
        ms.push({ id:`g_${id++}`, stage:"Grundspel", group:"Alla",
          aId:a, bId:b,
          winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" });
      }
    }
  }
  return ms;
}

function reorderMatchesForFairness(){
  // Syfte: ge jämnare vila och bättre flyt i matchlistan.
  // - Serie/alla möter alla: prioritera de som vilat längst.
  // - Gruppspel: varva grupper (A, B, C, A, B, C ...).
  try{
    if(!state || !Array.isArray(state.matches)) return;

    const all = state.matches.slice();
    const isPlayoffMatch = (m)=> m && typeof m.id==="string" && m.id.indexOf("po_")===0;
    const base = all.filter(m => !isPlayoffMatch(m));
    const po = all.filter(m => isPlayoffMatch(m));

    // Gruppspel: varva grupper
    if(state.format && state.format.indexOf("group")===0){
      const by = {};
      base.forEach(m=>{
        const g = (m.group==null) ? "" : String(m.group);
        (by[g] = by[g] || []).push(m);
      });
      const groups = Object.keys(by).sort();
      const out = [];
      let progressed = true;
      while(progressed){
        progressed = false;
        for(let i=0;i<groups.length;i++){
          const g = groups[i];
          if(by[g] && by[g].length){
            out.push(by[g].shift());
            progressed = true;
          }
        }
      }
      state.matches = out.concat(po);
      return;
    }

    // Serie: jämn vila
    if(state.format==="round_robin" || state.format==="round_robin_playoffs"){
      const last = {};
      const out = [];
      const remaining = base.slice();
      let t = 0;

      function getLast(pid){
        return (pid in last) ? last[pid] : -1000000000;
      }

      while(remaining.length){
        let bestIdx = 0;
        let bestScore = -1e30;

        for(let i=0;i<remaining.length;i++){
          const m = remaining[i];
          const la = getLast(m.aId);
          const lb = getLast(m.bId);

          // högre = bättre (mer vila för den som spelat senast)
          const rest = t - Math.max(la, lb);
          const restMin = t - Math.min(la, lb);

          // Primärt: maximera minsta vila, sekundärt: sprid också den andra
          const score = rest*1000 + restMin;

          if(score > bestScore){
            bestScore = score;
            bestIdx = i;
          }
        }

        const m = remaining.splice(bestIdx, 1)[0];
        out.push(m);
        last[m.aId] = t;
        last[m.bId] = t;
        t++;
      }

      state.matches = out.concat(po);
      return;
    }
  }catch(e){}
}


function makeGroupMatches(groups, repeats){
  repeats = repeats || 1;
  const ms=[];
  let id=0;

  function combos(arr){
    const out=[];
    for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++) out.push([arr[i],arr[j]]);
    return out;
  }

  // Stöd för 2 eller 4 grupper (utan att ändra befintligt beteende för 2 grupper)
  const letters = (state.numGroups===4 || (groups && groups.C) || (groups && groups.D))
    ? ["A","B","C","D"]
    : ["A","B"];

  letters.forEach((g)=>{
    const list = (groups && groups[g]) ? groups[g] : [];
    combos(list).forEach(([a0,b0])=>{
      for(let r=0;r<repeats;r++){
        const swap = (r % 2 === 1);
        const a = swap ? b0 : a0;
        const b = swap ? a0 : b0;
        ms.push({ id:`m_${g}_${id++}`, stage:"Gruppspel", group:g,
          aId:a, bId:b, winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" });
      }
    });
  });

  return ms;
}

function createTournament(){
  try{
    state.format = $("format").value;
    state.repeats = parseInt($("repeat").value || "1", 10) || 1;

    // Regler
    state.rules.game = $("game").value;
    state.rules.inRule = $("inRule").value;
    state.rules.outRule = $("outRule").value;
    state.rules.legsMode = $("legsMode").value;

    // Serie-flagga (deltävling)
    try{
      if(!state.meta) state.meta = { isSeriesEvent:false, seriesName:"", bonusProfile:"pulsi" };
      var chk = document.getElementById('isSeriesEvent');
      var name = document.getElementById('seriesName');
      state.meta.isSeriesEvent = !!(chk && chk.checked);
      state.meta.seriesName = (name && name.value) ? String(name.value||"") : (state.meta.seriesName||"");
    }catch(e){}

    // Spelare: endast manuell inmatning
    state.playerSource = "manual"; // skydd mot gammalt sparat läge
    const newPlayers = buildParticipantsFromInput();
    if(!newPlayers || newPlayers.length < 3){
      alert(state.mode==="team" ? "Minst 3 lag krävs." : "Minst 3 spelare krävs.");
      return;
    }
    state.players = newPlayers;

    // Nollställ turneringsdata
    state.groups = {A:[], B:[]};
    state.playoffs = {started:false, matches:[]};

    // Gruppspel: inställning för vilka som går vidare till slutspel (standard: topp 2 per grupp)
    if(!state.groupQualifyMode) state.groupQualifyMode = "top2";
    state.startedAt = new Date().toISOString();

    // Stabilt turnerings-ID så export/import och "ersätt deltävling" fungerar
    try{
      if(!state.tournamentId) state.tournamentId = cryptoId();
      if(!state.createdAt) state.createdAt = state.startedAt;
      state.updatedAt = state.startedAt;
      if(!state.tournamentName) state.tournamentName = (state.meta && state.meta.seriesName ? (String(state.meta.seriesName).trim()||"Ny turnering") : "Ny turnering");
    }catch(e){}
    const ids = state.players.map(p=>p.id);
    if(state.format === "round_robin" || state.format === "round_robin_playoffs"){
      state.matches = makeRoundRobinMatches(ids, state.repeats);
      state.step = getStepNums().matches;
    }else if(state.format === "knockout"){
      // Slutspel direkt: skapa träd (inkl. kval vid behov) men låt användaren starta när man är nöjd.
      state.groups = null;
      var po = buildKnockoutBracket(ids);
      if(!po || po.length===0){
        alert("Kunde inte skapa slutspel. Kontrollera att du har tillräckligt många spelare/lag.");
        return;
      }
      // Viktigt: samma matchobjekt används i Match-fliken och i slutspels-trädet (synk).
      state.matches = po;
      // Viktigt: slutspel ska INTE starta direkt. Man ska kunna förhandsgranska och slumpa om först.
      state.playoffs = { started:false, matches: po };
      // Final fylls först när semifinaler är spelade (efter att slutspel startats).
      state.step = getStepNums().playoffs;
    }else{
      state.groups = suggestGroups(ids, state.numGroups);
      state.matches = [];
      state.step = getStepNums().groups;
    }

    // Bättre matchordning (vila/grupper)
    reorderMatchesForFairness();

    // Autospar vid skapande (skydd mot reload)
    autosaveTournament();

    saveState();
    renderAll();
  }
  catch(e){
    alert("Fel när turneringen skulle skapas: " + (e && e.message ? e.message : e));
    console.error(e);
  }
}


function onGroupQualifyChange(){
  try{
    var sel = document.getElementById('groupQualifySelect');
    if(!sel) return;
    state.groupQualifyMode = sel.value || "top2";
    saveState();
  }catch(e){}
}

function reshuffleGroups(){
  state.groups = suggestGroups(state.players.map(p=>p.id), state.numGroups);
  saveState();
  renderGroups();
}

function renderGroups(){
  const A = (state.groups && state.groups.A) ? state.groups.A : [];
  const B = (state.groups && state.groups.B) ? state.groups.B : [];
  const C = (state.groups && state.groups.C) ? state.groups.C : [];
  const D = (state.groups && state.groups.D) ? state.groups.D : [];

  $("groupAList").innerHTML = A.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";
  $("groupBList").innerHTML = B.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";

  // Visa/dölj Grupp C/D beroende på valt antal grupper
  var show4 = (state.numGroups===4);
  try{
    var cds = document.querySelectorAll('.groupCD');
    for(var i=0;i<cds.length;i++){
      cds[i].classList.toggle('hidden', !show4);
    }
  }catch(e){}

  // Vidare till slutspel: visa bara när formatet inkluderar slutspel och grupper används
  try{
    if(!state.groupQualifyMode) state.groupQualifyMode = "top2";
    var card = document.getElementById('groupQualifyCard');
    var sel = document.getElementById('groupQualifySelect');
    var show = (state.format === "group_playoffs");
    if(card) card.classList.toggle("hidden", !show);
    if(sel) sel.value = state.groupQualifyMode || "top2";
  }catch(e){}

  var cEl = $("groupCList");
  var dEl = $("groupDList");
  if(cEl){
    cEl.innerHTML = C.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";
  }
  if(dEl){
    dEl.innerHTML = D.map(pid => `<span class="tag todo" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${escapeHtml(playerName(pid))}</span>`).join("") || "<span class='small'>Tom grupp</span>";
  }
}

function confirmGroups(){
  state.matches = makeGroupMatches(state.groups, state.repeats);
  state.step = 5;
  saveState();
  renderAll();
}

function groupStageComplete(){
  if(!state.matches || state.matches.length===0) return false;

  var letters = (state.numGroups===4) ? ["A","B","C","D"] : ["A","B"];

  // Endast gruppmatcher räknas (A/B och ev. C/D)
  for(var i=0;i<state.matches.length;i++){
    var mm = state.matches[i];
    if(letters.indexOf(mm.group) !== -1){
      if(!mm.winnerId) return false;
    }
  }
  return true;
}

function top2FromGroup(groupLetter){
  var ids = (state.groups && state.groups[groupLetter]) ? (state.groups[groupLetter] || []) : [];
  var st = computeStandings(ids, state.matches, function(m){ return m.group===groupLetter; });
  return st.slice(0,2).map(function(x){ return x.pid; });
}


function buildPlayoffsPreview(){
  // Bygger ett förhands-slutspel baserat på NUVARANDE tabell (även om grundspelet inte är klart).
  // Detta sparas inte förrän du trycker "Starta slutspel".

  // 1) Gruppspel + slutspel (befintligt beteende)
  if(state.format==="group_playoffs"){
    var is4 = (state.numGroups===4);
    var mode = (state.groupQualifyMode || "top2");


    // Om "Alla" är valt: bygg seedlista (gruppvinnare först) och skapa seedat slutspel med kval/BYE.
    if(mode==="all"){
      var letters = is4 ? ["A","B","C","D"] : ["A","B"];
      var perGroup = {};
      var maxLen = 0;
      for(var li=0; li<letters.length; li++){
        var L = letters[li];
        var idsL = (state.groups && state.groups[L]) ? (state.groups[L] || []) : [];
        var stL = computeStandings(idsL, state.matches, function(m){ return m.group===L; });
        perGroup[L] = stL.map(function(x){ return x.pid; });
        if(perGroup[L].length > maxLen) maxLen = perGroup[L].length;
      }
      // Interleaving: A1,B1,C1,D1,A2,B2,... så att gruppvinnare prioriteras för ev. BYE.
      var seeds = [];
      for(var pos=0; pos<maxLen; pos++){
        for(var gi=0; gi<letters.length; gi++){
          var L2 = letters[gi];
          var pid = (perGroup[L2] && perGroup[L2][pos]) ? perGroup[L2][pos] : "";
          if(pid) seeds.push(pid);
        }
      }
      if(seeds.length < 4) return null;
      return buildSeededPlayoffsFromSeeds(seeds);
    }

    if(!is4){
      var A = top2FromGroup("A");
      var B = top2FromGroup("B");

      // Semis: A1 vs B2, B1 vs A2 (om saknas -> tomma platser)
      var sf1 = { id:"po_sf1", stage:"Slutspel", round:"Semifinal 1", group:"SF",
        aId:(A[0]||""), bId:(B[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      var sf2 = { id:"po_sf2", stage:"Slutspel", round:"Semifinal 2", group:"SF",
        aId:(B[0]||""), bId:(A[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
      var fin = { id:"po_f", stage:"Slutspel", round:"Final", group:"F",
        aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

      return [sf1, sf2, fin];
    }

    // 4 grupper -> topp 2 från varje -> kvartsfinaler -> semifinaler -> final
    var A2 = top2FromGroup("A");
    var B2 = top2FromGroup("B");
    var C2 = top2FromGroup("C");
    var D2 = top2FromGroup("D");

    // Kvartsfinaler: A1-B2, B1-A2, C1-D2, D1-C2
    var qf1 = { id:"po_qf1", stage:"Slutspel", round:"Kvartsfinal 1", group:"QF",
      aId:(A2[0]||""), bId:(B2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var qf2 = { id:"po_qf2", stage:"Slutspel", round:"Kvartsfinal 2", group:"QF",
      aId:(B2[0]||""), bId:(A2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var qf3 = { id:"po_qf3", stage:"Slutspel", round:"Kvartsfinal 3", group:"QF",
      aId:(C2[0]||""), bId:(D2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var qf4 = { id:"po_qf4", stage:"Slutspel", round:"Kvartsfinal 4", group:"QF",
      aId:(D2[0]||""), bId:(C2[1]||""), winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

    // Semifinaler fylls när kvartsfinalerna är spelade (kan vara tomt i förhandsvisning)
    var sf1x = { id:"po_sf1", stage:"Slutspel", round:"Semifinal 1", group:"SF",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var sf2x = { id:"po_sf2", stage:"Slutspel", round:"Semifinal 2", group:"SF",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
    var finx = { id:"po_f", stage:"Slutspel", round:"Final", group:"F",
      aId:"", bId:"", winnerId:"", result:"", avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };

    return [qf1, qf2, qf3, qf4, sf1x, sf2x, finx];
  }

  // 2) Serie + slutspel (seedat + kval/BYE upp till 32)
  if(state.format==="round_robin_playoffs"){
    var ids = (state.players||[]).map(function(p){return p.id;});
    if(ids.length < 4) return null;

    // Tabell baserat på alla matcher i grundspelet
    var st = computeStandings(ids, state.matches || [], function(m){ return m && m.stage==="Grundspel"; });
    var seeds = st.map(function(x){ return x.pid; });

    // Begränsa antal som går vidare (om valt)
    var qc = (state.seriesQualifyCount || "all");
    if(qc !== "all"){
      var n = parseInt(qc, 10);
      if(n && n >= 2 && n < seeds.length){
        seeds = seeds.slice(0, n);
      }
    }

    // Bygg seedat slutspel: kval bland de sämsta vid behov, toppseed kan få BYE.
    return buildSeededPlayoffsFromSeeds(seeds);
  }


  return null;
}


// ===== Seedat slutspel (kval/BYE) upp till 32 =====
function _largestPow2LE(x){
  var p = 1;
  while(p*2 <= x) p *= 2;
  return p;
}
function buildSeededPlayoffsFromSeeds(seeds){
  // seeds: array of playerIds in seed order (1..n)
  var ids = Array.isArray(seeds) ? seeds.slice() : [];
  if(ids.length < 2) return null;
  // Specialfall: topp 2 = direkt final
  if(ids.length === 2){
    function mkFinal(aId,bId){
      return { id:'po_f', stage:'Slutspel', round:'Final', group:'F',
        aId:(aId||''), bId:(bId||''), winnerId:'', result:'',
        avgA:'', avgB:'', f9A:'', f9B:'', coA:'', coB:'', notes:'' };
    }
    return [mkFinal(ids[0], ids[1])];
  }
  var n = ids.length;
  if(n > 32) ids = ids.slice(0,32), n = ids.length;

  var target = _largestPow2LE(n); // 4/8/16/32
  if(target < 4) target = 4;
  var qualMatches = n - target; // number of kval-matcher (0 om exakt 2-potens)
  var directCount = target - qualMatches; // antal som går direkt in i huvudträdet

  function mk(id, round, group, aId, bId){
    return { id:id, stage:"Slutspel", round:round, group:group,
      aId:(aId||""), bId:(bId||""), winnerId:"", result:"",
      avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"" };
  }

  // 1) Kval: para resterande (från seed directCount..n) som (högst seed vs lägst seed)
  var kval = [];
  var rem = ids.slice(directCount);
  for(var k=0; k<qualMatches; k++){
    var a = rem[k] || "";
    var b = rem[rem.length-1-k] || "";
    var km = mk("po_k"+(k+1), "Kval "+(k+1), "K", a, b);
    // kval-rank: bättre seed av paret (lägre index = bättre)
    km._qualRank = Math.min(directCount + k, directCount + (rem.length-1-k));
    kval.push(km);
  }

  // 2) Lista över huvudträds-seeds (rank 1..target): först direkta seeds, sen kval-platser ordnade efter kval-rank
  var slotsByRank = new Array(target+1);
  for(var r=1; r<=directCount; r++) slotsByRank[r] = ids[r-1];

  var kvalOrder = kval.map(function(m, idx){ return { idx: idx, rank: m._qualRank }; });
  kvalOrder.sort(function(a,b){ return a.rank - b.rank; });
  for(var qi=0; qi<kvalOrder.length; qi++){
    var rank = directCount + 1 + qi;
    slotsByRank[rank] = { fromQual: (kvalOrder[qi].idx + 1) }; // 1-baserad kval-index
  }

  function seedPositions(size){
    if(size===4) return [1,4,2,3];
    if(size===8) return [1,8,4,5,2,7,3,6];
    if(size===16) return [1,16,8,9,5,12,4,13,6,11,3,14,7,10,2,15];
    if(size===32) return [1,32,16,17,8,25,9,24,5,28,13,20,4,29,12,21,6,27,14,19,3,30,11,22,7,26,15,18,2,31,10,23];
    return [];
  }

  function applySlot(match, side, slot){
    if(slot && typeof slot === 'object' && slot.fromQual){
      match[side] = "";
      if(side==='aId') match._aFromQual = slot.fromQual;
      if(side==='bId') match._bFromQual = slot.fromQual;
    }else{
      match[side] = slot || "";
    }
  }

  var matches = [].concat(kval);

  // 3) Skapa huvudrundor
  if(target===4){
    var pos = seedPositions(4);
    var sf1 = mk('po_sf1','Semifinal 1','SF','','');
    var sf2 = mk('po_sf2','Semifinal 2','SF','','');
    var fin = mk('po_f','Final','F','','');
    applySlot(sf1,'aId', slotsByRank[pos[0]]); applySlot(sf1,'bId', slotsByRank[pos[1]]);
    applySlot(sf2,'aId', slotsByRank[pos[2]]); applySlot(sf2,'bId', slotsByRank[pos[3]]);
    matches.push(sf1,sf2,fin);
    return matches;
  }

  if(target===8){
    var p8 = seedPositions(8);
    var qf = [];
    for(var i=0;i<4;i++){
      qf.push(mk('po_qf'+(i+1),'Kvartsfinal '+(i+1),'QF','',''));
      applySlot(qf[i],'aId', slotsByRank[p8[i*2]]);
      applySlot(qf[i],'bId', slotsByRank[p8[i*2+1]]);
    }
    var sf1x = mk('po_sf1','Semifinal 1','SF','','');
    var sf2x = mk('po_sf2','Semifinal 2','SF','','');
    var finx = mk('po_f','Final','F','','');
    matches.push.apply(matches, qf);
    matches.push(sf1x,sf2x,finx);
    return matches;
  }

  if(target===16){
    var p16 = seedPositions(16);
    for(var j=0;j<8;j++){
      var m = mk('po_r16_'+(j+1),'Åttondelsfinal '+(j+1),'R16','','');
      applySlot(m,'aId', slotsByRank[p16[j*2]]);
      applySlot(m,'bId', slotsByRank[p16[j*2+1]]);
      matches.push(m);
    }
    // placeholders för senare rundor
    for(var q=1;q<=4;q++) matches.push(mk('po_qf'+q,'Kvartsfinal '+q,'QF','',''));
    matches.push(mk('po_sf1','Semifinal 1','SF','',''));
    matches.push(mk('po_sf2','Semifinal 2','SF','',''));
    matches.push(mk('po_f','Final','F','',''));
    return matches;
  }

  if(target===32){
    var p32 = seedPositions(32);
    for(var t=0;t<16;t++){
      var m2 = mk('po_r32_'+(t+1),'Sextondelsfinal '+(t+1),'R32','','');
      applySlot(m2,'aId', slotsByRank[p32[t*2]]);
      applySlot(m2,'bId', slotsByRank[p32[t*2+1]]);
      matches.push(m2);
    }
    for(var r=1;r<=8;r++) matches.push(mk('po_r16_'+r,'Åttondelsfinal '+r,'R16','',''));
    for(var q2=1;q2<=4;q2++) matches.push(mk('po_qf'+q2,'Kvartsfinal '+q2,'QF','',''));
    matches.push(mk('po_sf1','Semifinal 1','SF','',''));
    matches.push(mk('po_sf2','Semifinal 2','SF','',''));
    matches.push(mk('po_f','Final','F','',''));
    return matches;
  }

  return matches;
}
function buildKnockoutBracket(playerIds){
  // Knockout direkt med KVAL när antal inte är en 2-potens.
  // Vi kvalar ner till närmaste lägre 2-potens: 4 / 8 / 16 / 32 (max 32).
  var ids = Array.isArray(playerIds) ? playerIds.slice() : [];
  if(ids.length < 2) return null;

  ids = shuffle(ids);

  var n = ids.length;
  var max = 32;
  if(n > max) ids = ids.slice(0, max), n = ids.length;

  function largestPow2LE(x){
    var p = 1;
    while(p*2 <= x) p *= 2;
    return p;
  }

  var target = largestPow2LE(n);
  // Vi stödjer matchgenerering upp till 32, men träd-vyn i UI är primärt byggd för 4/8.
  // Matchfliken + schema fungerar även vid fler.
  var qualMatches = n - target;

  var nowIso = new Date().toISOString();

  function mkBase(id, round, group, aId, bId){
    return { id:id, stage:"Slutspel", round:round, group:group,
      aId:(aId||""), bId:(bId||""), winnerId:"", result:"",
      avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"", notes:"",
      createdAt: nowIso
    };
  }

  // 1) Bygg Kval-matcher (po_k1..)
  var kval = [];
  var idx = 0;
  for(var k=1; k<=qualMatches; k++){
    var a = ids[idx++] || "";
    var b = ids[idx++] || "";
    kval.push(mkBase("po_k"+k, "Kval "+k, "K", a, b));
  }

  // Resterande går direkt
  var direct = ids.slice(idx);

  // 2) Bygg huvudrundor
  var matches = [];
  matches = matches.concat(kval);

  // Helper: pool med kval-platser + direkt
  var pool = [];
  for(var k2=1; k2<=qualMatches; k2++) pool.push({fromQual:k2});
  for(var di=0; di<direct.length; di++) pool.push(direct[di]);
  pool = shuffle(pool);

  function takeSlot(){
    return pool.shift() || "";
  }
  function applySlot(m, side, slot){
    if(typeof slot === "object" && slot && slot.fromQual){
      m[side] = "";
      if(side==="aId") m._aFromQual = slot.fromQual;
      if(side==="bId") m._bFromQual = slot.fromQual;
    }else{
      m[side] = slot || "";
    }
  }

  // target 4: Semis + Final
  if(target === 4){
    var sf1 = mkBase("po_sf1","Semifinal 1","SF","","");
    var sf2 = mkBase("po_sf2","Semifinal 2","SF","","");
    var fin = mkBase("po_f","Final","F","","");

    var s1a = takeSlot(), s1b = takeSlot(), s2a = takeSlot(), s2b = takeSlot();
    applySlot(sf1, "aId", s1a); applySlot(sf1, "bId", s1b);
    applySlot(sf2, "aId", s2a); applySlot(sf2, "bId", s2b);

    matches.push(sf1, sf2, fin);
    return matches;
  }

  // target 8: Kvarts + Semis + Final
  if(target === 8){
    var qf1 = mkBase("po_qf1","Kvartsfinal 1","QF","","");
    var qf2 = mkBase("po_qf2","Kvartsfinal 2","QF","","");
    var qf3 = mkBase("po_qf3","Kvartsfinal 3","QF","","");
    var qf4 = mkBase("po_qf4","Kvartsfinal 4","QF","","");
    var sf1x = mkBase("po_sf1","Semifinal 1","SF","","");
    var sf2x = mkBase("po_sf2","Semifinal 2","SF","","");
    var finx = mkBase("po_f","Final","F","","");

    var slots = [takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot(),takeSlot()];
    applySlot(qf1,"aId",slots[0]); applySlot(qf1,"bId",slots[1]);
    applySlot(qf2,"aId",slots[2]); applySlot(qf2,"bId",slots[3]);
    applySlot(qf3,"aId",slots[4]); applySlot(qf3,"bId",slots[5]);
    applySlot(qf4,"aId",slots[6]); applySlot(qf4,"bId",slots[7]);

    matches.push(qf1,qf2,qf3,qf4,sf1x,sf2x,finx);
    return matches;
  }

  // target 16/32: skapa rundor i matches-listan (schema/matchflik), trädvyn kan senare utökas.
  // Vi skapar då bara en "första runda" + placeholders för nästa (i schema).
  // Här förenklar vi: använd samma id-mönster i schema, men utan trädvisning.
  var rounds = [];
  if(target === 16) rounds = ["Åttondelsfinal"];
  if(target === 32) rounds = ["Sextondelsfinal"];
  var firstName = rounds[0] || "Runda";
  var firstCount = target/2;
  for(var i=1;i<=firstCount;i++){
    var m = mkBase("po_r1_"+i, firstName+" "+i, "R1","","");
    var aS = takeSlot(), bS = takeSlot();
    applySlot(m,"aId",aS); applySlot(m,"bId",bS);
    matches.push(m);
  }
  return matches;
}


function canStartPlayoffsNow(){
  // Styr UI för "Starta slutspel".
  if(state.format==="group_playoffs"){
    var letters = (state.numGroups===4) ? ["A","B","C","D"] : ["A","B"];
    for(var i=0;i<letters.length;i++){
      var g = letters[i];
      var c = (state.groups && state.groups[g]) ? state.groups[g].length : 0;
      if(c < 2){
        return {ok:false, msg:"För att starta slutspel behövs minst 2 spelare i varje grupp."};
      }
    }

    if(!groupStageComplete()){
      return {ok:true, msg:"Gruppspelet är inte klart ännu. Slutspel visas som förhandsvisning. När alla gruppmatcher är spelade kan du starta/låsa slutspelet."};
    }
    return {ok:true, msg:""};
  }

  if(state.format==="round_robin_playoffs"){
    var n = (state.players||[]).length;
    if(n < 4) return {ok:false, msg:"Slutspel kräver minst 4 deltagare."};

    // Grundspel klart?
    var complete = true;
    for(var i2=0;i2<(state.matches||[]).length;i2++){
      var m = state.matches[i2];
      if(m && m.stage==="Grundspel" && !m.winnerId){ complete = false; break; }
    }
    if(!complete){
      return {ok:true, msg:"Grundspelet (serien) är inte klart ännu. Slutspel visas som förhandsvisning. När alla seriematcher är spelade kan du starta/låsa slutspelet."};
    }
    return {ok:true, msg:""};
  }

  return {ok:false, msg:"Slutspel finns bara när du valt Gruppspel + slutspel eller Serie + slutspel."};
}

// Serie (round robin) är klar när alla matcher i "Grundspel" har vinnare.
function seriesStageComplete(){
  try{
    for(var i=0;i<(state.matches||[]).length;i++){
      var m = state.matches[i];
      if(m && m.stage==="Grundspel" && !m.winnerId) return false;
    }
    return true;
  }catch(e){
    return false;
  }
}

// Tillåt att man aktiverar slutspel även om man från början valde "Alla möter alla (serie)".
function canActivatePlayoffsFromSeries(){
  try{
    if(state.format!=="round_robin") return {ok:false, msg:""};
    var n = (state.players||[]).length;
    if(n < 4) return {ok:false, msg:"Slutspel kräver minst 4 deltagare."};
    if(!seriesStageComplete()) return {ok:false, msg:"Serien är inte klar ännu."};
    return {ok:true, msg:""};
  }catch(e){
    return {ok:false, msg:""};
  }
}

function activatePlayoffsFromSeries(){
  var chk = canActivatePlayoffsFromSeries();
  if(!chk.ok){
    alert(chk.msg || "Kan inte aktivera slutspel ännu.");
    return;
  }

  // Byt format så att befintlig slutspelslogik (förhandsvisning + start/lås) kan användas.
  state.format = "round_robin_playoffs";
  // Om det råkar finnas ett gammalt slutspel i datan (från tidigare versioner) – nollställ.
  state.playoffs = null;

  try{ state.step = getStepNums().playoffs; }catch(e){}
  saveState();
  renderAll();
}

function ensurePlayoffs(){
  // Skapar (och låser) slutspel när det är dags.
  if(state.format!=="group_playoffs" && state.format!=="round_robin_playoffs") return false;

  // Om redan startat/låst – behåll.
  if(state.playoffs && state.playoffs.started && state.playoffs.matches && state.playoffs.matches.length>0) return true;

  var chk = canStartPlayoffsNow();
  if(!chk.ok) return false;

  var preview = buildPlayoffsPreview();
  if(!preview) return false;

  state.playoffs = { started:true, matches: preview };
  saveState();
  return true;
}


function updateFinalFromSemis(){
  // Generisk slutspelspropagering upp till 32 spelare.
  // Stöd: Kval (po_k*), R32 (po_r32_*), R16 (po_r16_*), QF (po_qf*), SF (po_sf*), Final (po_f).
  if(!state.playoffs || !state.playoffs.matches) return;
  var ms = state.playoffs.matches;
  function byId(id){ return ms.find(function(x){ return x && x.id===id; }); }

  // --- Kvalvinnare (1-baserad) ---
  var kvalByIdx = [];
  for(var i=1;i<=31;i++){
    var km = byId('po_k'+i);
    if(km) kvalByIdx[i] = km;
  }
  function qualWinner(k){
    try{ var m = kvalByIdx[k]; return (m && m.winnerId) ? m.winnerId : ''; }catch(e){ return ''; }
  }

  function clearMatchIfParticipantsChanged(m, newA, newB){
    if(!m) return;
    var a = newA || '';
    var b = newB || '';
    var changed = (m.aId !== a) || (m.bId !== b);
    if(!changed) return;
    m.aId = a; m.bId = b;
    if(m.winnerId && (m.winnerId !== m.aId && m.winnerId !== m.bId)){
      m.winnerId = '';
      m.result = '';
      m.avgA = ''; m.avgB = '';
      m.f9A = ''; m.f9B = '';
      m.coA = ''; m.coB = '';
      m.notes = '';
      m.finishedAt = '';
    }
  }

  function resolveQualSlots(m){
    if(!m) return;
    var a = m.aId || '';
    var b = m.bId || '';
    if(m._aFromQual) a = qualWinner(m._aFromQual) || '';
    if(m._bFromQual) b = qualWinner(m._bFromQual) || '';
    clearMatchIfParticipantsChanged(m, a, b);
  }

  // 1) Först: fyll in kvalplatser i den runda där de finns (R32/R16/QF/SF).
  ['po_r32_','po_r16_','po_qf','po_sf'].forEach(function(prefix){
    for(var k=1;k<=32;k++){
      var id = (prefix==='po_qf' || prefix==='po_sf') ? (prefix + k) : (prefix + k);
      var m = byId(id);
      if(!m) continue;
      if(m._aFromQual || m._bFromQual) resolveQualSlots(m);
    }
  });

  // 2) Propagera vinnare nedströms (R32 -> R16 -> QF -> SF -> F)
  function winnerOf(id){ var m = byId(id); return (m && m.winnerId) ? m.winnerId : ''; }

  // R32 -> R16
  for(var r=1;r<=8;r++){
    var m16 = byId('po_r16_'+r);
    if(!m16) break;
    var a = winnerOf('po_r32_'+(r*2-1));
    var b = winnerOf('po_r32_'+(r*2));
    if(a || b) clearMatchIfParticipantsChanged(m16, a, b);
  }

  // R16 -> QF
  for(var q=1;q<=4;q++){
    var qf = byId('po_qf'+q);
    if(!qf) break;
    var a2 = winnerOf('po_r16_'+(q*2-1));
    var b2 = winnerOf('po_r16_'+(q*2));
    if(a2 || b2) clearMatchIfParticipantsChanged(qf, a2, b2);
  }

  // QF -> SF (klassisk 8/16/32)
  var qf1 = byId('po_qf1'), qf2 = byId('po_qf2'), qf3 = byId('po_qf3'), qf4 = byId('po_qf4');
  var sf1 = byId('po_sf1'), sf2 = byId('po_sf2');
  var fin = byId('po_f');

  var hasQF = !!(qf1 || qf2 || qf3 || qf4);
  if(hasQF){
    var sf1A = (qf1 && qf1.winnerId) ? qf1.winnerId : '';
    var sf1B = (qf2 && qf2.winnerId) ? qf2.winnerId : '';
    var sf2A = (qf3 && qf3.winnerId) ? qf3.winnerId : '';
    var sf2B = (qf4 && qf4.winnerId) ? qf4.winnerId : '';
    clearMatchIfParticipantsChanged(sf1, sf1A, sf1B);
    clearMatchIfParticipantsChanged(sf2, sf2A, sf2B);
  }else{
    // Ingen QF: semifinaler kan vara seedade direkt (t.ex. target=4). Se till att kvalplatser fyllts.
    resolveQualSlots(sf1);
    resolveQualSlots(sf2);
  }

  // SF -> Final
  if(fin){
    // Om vi INTE har semifinaler (t.ex. topp 2 -> direkt final) ska vi inte nollställa finalens deltagare.
    if(!sf1 && !sf2){
      // behåll befintliga aId/bId
    }else{
      var fA = (sf1 && sf1.winnerId) ? sf1.winnerId : '';
      var fB = (sf2 && sf2.winnerId) ? sf2.winnerId : '';
      clearMatchIfParticipantsChanged(fin, fA, fB);
    }
  }

  try{ saveState(); }catch(e){}
}

// redraw lines on resize (lightweight)
window.addEventListener('resize', function(){
  try{
    if(state && state.ui && state.ui.showPlayoffsBracket) drawPlayoffsBracketLines();
  }catch(e){}
});



function renderPlayoffs(){
  applyStartStamp();

  // Visa/dölj kvartsfinalkolumn beroende på om förhandsvisningen/slutspelet innehåller QF.
  ensureKnockoutSync();

  // Förhandsvisning: knockout visar alltid det skapade trädet (inkl. kval) även innan start.
  var hasPO = !!(state.playoffs && state.playoffs.matches && state.playoffs.matches.length>0);
  var preview = (state.format === "knockout" && hasPO) ? state.playoffs.matches
              : ((state.playoffs && state.playoffs.started) ? (state.playoffs.matches||[]) : (buildPlayoffsPreview()||[]));
  var hasQF = !!(preview && preview.find && preview.find(function(x){ return x.id==="po_qf1"; }));
  var hasQUAL = !!(preview && preview.find && preview.find(function(x){ return x.id==="po_k1"; }));

  try{
    var _inner = $("playoffsBracketInner");
    if(_inner && _inner.classList) _inner.classList.toggle("hasQF", hasQF);
    if(_inner && _inner.classList) _inner.classList.toggle("hasQUAL", hasQUAL);
    var _qfs = document.querySelectorAll("#playoffsBracketContent .groupCD");
    for(var _i=0; _i<_qfs.length; _i++) _qfs[_i].classList.toggle("hidden", !hasQF);

    var _quals = document.querySelectorAll("#playoffsBracketContent .bracketCell.qual");
    for(var _k=0; _k<_quals.length; _k++) _quals[_k].classList.toggle("hidden", !hasQUAL);

    // Snabbnav
    var navBtns = document.querySelectorAll('.bracketNavBtn');
    if(navBtns && navBtns.length>=3){
      navBtns[0].disabled = !hasQF; // Kvartsfinal-knappen
    }
  }catch(e){}

  // Synka vy (schema vs träd)
  if(!state.ui) state.ui = {};
  var _showBracket = !!state.ui.showPlayoffsBracket;
  try{
    var _bv = $("playoffsBracketView");
    var _sv = $("playoffsScheduleView");
    if(_bv) _bv.classList.toggle("hidden", !_showBracket);
    if(_sv) _sv.classList.toggle("hidden", _showBracket);
    var _btn = $("btnPlayoffsBracketToggle");
    if(_btn) _btn.textContent = _showBracket ? "Visa slutspelsschema" : "Visa slutspelsträd";
  }catch(e){}

  var btnStart = $("btnStartPlayoffs");
  var btnUndo = $("btnUndoPlayoffs");
  // Startknappen ska även synas i rent slutspel (knockout) – där används den som "bekräfta/starta".
  if(btnStart){
    btnStart.classList.remove('hidden');
  }
  var actCard = document.getElementById('seriesPlayoffsActivateCard');
  if(actCard) actCard.classList.add('hidden');

  // Serie utan slutspel: låt användaren aktivera slutspel här.
  if(state.format==="round_robin"){
    if(actCard) actCard.classList.remove('hidden');
    try{
      var n = (state.players||[]).length;
      var sel = document.getElementById('seriesQualifySelect');
      if(sel){
        var opts = getSeriesQualifyOptions(n);
        sel.innerHTML = opts.map(function(o){ return '<option value="'+o.value+'">'+o.label+'</option>'; }).join('');
        sel.value = (state.seriesQualifyCount || 'all');
      }
      var hint = document.getElementById('playoffsHint');
      if(hint) hint.textContent = 'Aktivera slutspel om ni vill spela utslagning efter serien.';
    }catch(e){}

    // Visa en enkel info i tabellen
    var pt = $("playoffsTable");
    if(pt) pt.innerHTML = '<tr><td class="muted" style="padding:10px">Slutspel är inte aktiverat för denna serie. Välj hur många som går vidare och tryck <b>Aktivera</b>.</td></tr>';

    // Dölj knappar som kräver slutspel
    if(btnStart) btnStart.classList.add('hidden');
    var btnToggle = $("btnPlayoffsBracketToggle");
    if(btnToggle) btnToggle.classList.add('hidden');
    if(btnUndo) btnUndo.style.display = 'none';
    if($("btnShuffleKnockout")) $("btnShuffleKnockout").style.display = 'none';
    return;
  }else{
    var btnToggle2 = $("btnPlayoffsBracketToggle");
    if(btnToggle2) btnToggle2.classList.remove('hidden');
  }

  // Serie + slutspel (aktiverat) men ännu inte startat: tillåt att man ändrar/ångrar innan start.
  if(state.format==="round_robin_playoffs" && (!state.playoffs || !state.playoffs.started)){
    if(actCard) actCard.classList.remove('hidden');
    try{
      var n2 = (state.players||[]).length;
      var sel2 = document.getElementById('seriesQualifySelect');
      if(sel2){
        var opts2 = getSeriesQualifyOptions(n2);
        sel2.innerHTML = opts2.map(function(o){ return '<option value="'+o.value+'">'+o.label+'</option>'; }).join('');
        sel2.value = (state.seriesQualifyCount || 'all');
      }
      var btnEnable = document.getElementById('btnEnableSeriesPlayoffs');
      if(btnEnable) btnEnable.textContent = 'Uppdatera';
      var btnDisable = document.getElementById('btnDisableSeriesPlayoffs');
      if(btnDisable) btnDisable.style.display = '';
      var hint2 = document.getElementById('playoffsHint');
      if(hint2) hint2.textContent = 'Slutspel är aktiverat men inte startat. Du kan ändra antal som går vidare eller ångra.';
    }catch(e){}
  }else{
    try{
      var btnEnable3 = document.getElementById('btnEnableSeriesPlayoffs');
      if(btnEnable3) btnEnable3.textContent = 'Aktivera';
      var btnDisable3 = document.getElementById('btnDisableSeriesPlayoffs');
      if(btnDisable3) btnDisable3.style.display = 'none';
    }catch(e){}
  }

  var isPlayoffFormat = (state.format==="group_playoffs" || state.format==="round_robin_playoffs" || state.format==="knockout");
  if(!isPlayoffFormat){
    $("playoffsTable").innerHTML = '<tr><td class="muted" style="padding:10px">Slutspel används när du valt <b>Gruppspel + slutspel</b> eller <b>Serie + slutspel</b>.</td></tr>';
    if(btnStart) btnStart.classList.add('hidden');
    if($("btnPlayoffsBracketToggle")) $("btnPlayoffsBracketToggle").classList.add('hidden');
    return;
  }

  var started = !!(state.playoffs && state.playoffs.started && state.playoffs.matches && state.playoffs.matches.length>0);
  var ms = started ? state.playoffs.matches : preview;

  // Knockout: styr Slumpa om-knappen
  var btnShuffle = $("btnShuffleKnockout");
  if(btnShuffle){
    btnShuffle.style.display = (state.format==="knockout" && !started) ? "" : "none";
  }

  // Styr "Ångra start"-knappen (syns bara när slutspel är startat och inga matcher är spelade)
  if(btnUndo){
    // show/hide (inte relevant i ren knockout där trädet redan är grundformen)
    btnUndo.style.display = started ? "" : "none";

    var anyPlayed = false;
    try{
      var _pms = (state.playoffs && state.playoffs.matches) ? state.playoffs.matches : [];
      for(var _u=0; _u<_pms.length; _u++){
        var _m = _pms[_u];
        if(!_m) continue;
        // Blockera bara om det finns riktiga resultat (inte bara ifyllda deltagare)
        if(_m.result || _m.finishedAt || _m.avgA || _m.avgB || _m.f9A || _m.f9B || _m.coA || _m.coB || _m.notes){
          anyPlayed = true; break;
        }
        if(_m.winnerId && _m.result){
          anyPlayed = true; break;
        }
      }
    }catch(e){}

    btnUndo.disabled = false;
    btnUndo.dataset.anyPlayed = anyPlayed ? "1" : "0";
    btnUndo.title = anyPlayed
      ? "Kan inte dra tillbaka när slutspelsmatcher redan har resultat."
      : "Dra tillbaka slutspelet (gå tillbaka till förhandsvisning så du kan slumpa om och starta igen).";
  }

  // Styr startknappen
  if(btnStart){
    // I knockout ska man kunna förhandsgranska trädet, slumpa om, och sedan själv "Starta slutspel".
    if(state.format==="knockout"){
      btnStart.disabled = started;
      btnStart.classList.toggle('ready', !started);
      btnStart.title = started ? "Slutspel är startat." : "Tryck för att starta/låsa slutspelet.";
    }else{
      var chk = canStartPlayoffsNow();
      var complete = true;
      if(state.format==="group_playoffs") complete = groupStageComplete();
      if(state.format==="round_robin_playoffs"){
        for(var i=0;i<(state.matches||[]).length;i++){
          var m = state.matches[i];
          if(m && m.stage==="Grundspel" && !m.winnerId){ complete = false; break; }
        }
      }

      btnStart.disabled = started;
      btnStart.classList.toggle('ready', (!started && complete));
      btnStart.title = started ? "Slutspel är redan startat." : (complete ? "Grundspelet är klart – tryck för att starta/låsa slutspelet." : (chk.msg || ""));
    }
  }

  if(started && state.format!=="knockout"){
    updateFinalFromSemis();
  }

  if(!ms || ms.length===0){
    $("playoffsTable").innerHTML = '<tr><td class="muted" style="padding:10px">Det går inte att skapa slutspel ännu.</td></tr>';
    return;
  }

  // Uppdatera hinttext
  try{
    var hintEl = document.querySelector('#playoffsScheduleView .hint');
    if(hintEl){
      if(state.format==="knockout"){
        hintEl.textContent = hasQF
          ? "Slutspelet är lottat: kvartsfinaler → semifinaler → final. Vid behov ges BYE automatiskt."
          : "Slutspelet är lottat: semifinaler → final. Vid behov ges BYE automatiskt.";
      }else if(state.format==="round_robin_playoffs"){
        hintEl.textContent = hasQF
          ? "Kvartsfinaler baseras på serietabellen (topp 8): 1–8, 4–5, 2–7, 3–6. Vinnarna går vidare till semifinal och final."
          : "Semifinaler baseras på serietabellen (topp 4): 1–4 och 2–3. Vinnarna möts i final.";
      }else{
        hintEl.textContent = hasQF
          ? "Kvartsfinaler: A1–B2, B1–A2, C1–D2, D1–C2. Vinnarna går vidare till semifinal och final."
          : "Semifinaler: A1 vs B2 och B1 vs A2. Vinnarna möts i final.";
      }
    }
  }catch(e){}

  var html = "<tr><th>Rond</th><th>Match</th><th>Status</th></tr>";
  for(var j=0;j<ms.length;j++){
    var mm = ms[j];
    var aName = mm.aId ? playerName(mm.aId) : (mm.id==='po_f' ? 'Vinnare SF1' : (mm.id==='po_sf1' ? 'Vinnare QF1' : (mm.id==='po_sf2' ? 'Vinnare QF3' : '—')));
    var bName = mm.bId ? playerName(mm.bId) : (mm.id==='po_f' ? 'Vinnare SF2' : (mm.id==='po_sf1' ? 'Vinnare QF2' : (mm.id==='po_sf2' ? 'Vinnare QF4' : '—')));

    var played = !!mm.winnerId;
    var status;
    if(!started){
      status = '<span class="tag todo">Förhandsvisning</span>';
    }else{
      status = played
        ? '<span class="tag ok">'+escapeHtml(playerName(mm.winnerId))+' vann '+(mm.result ? '('+escapeHtml(mm.result)+')' : '')+'</span>'
        : '<span class="tag todo">Ej spelad</span>';
    }

    var clickable = started;
    if(mm.id==="po_f" && (!mm.aId || !mm.bId)) clickable = false;

    html += '<tr class="matchRow '+(played?'played':'')+'" '+(clickable?'onclick="openPlayoffMatch(\''+mm.id+'\')"':'')+'>'
         +  '<td><strong>'+escapeHtml(mm.round)+'</strong></td>'
         +  '<td>'
         +  '<div class="row" style="align-items:center;gap:8px">'
         +    _avatarBtnViewHtml(mm.aId||'', aName, 'small')
         +    '<strong>'+escapeHtml(aName)+'</strong><span class="muted">vs</span>'
         +    _avatarBtnViewHtml(mm.bId||'', bName, 'small')
         +    '<strong>'+escapeHtml(bName)+'</strong>'
         +  '</div>'
         +  '</td>'
         +  '<td>'+status+'</td>'
         + '</tr>';
  }

  $("playoffsTable").innerHTML = html;
  try{ hydrateAvatarsIn($("playoffsTable")); }catch(e){}

  applyPlayoffView();
  // Se till att rätt vy (schema/träd) faktiskt renderas varje gång vi går in i slutspelet.
  // Viktigt för knockout: annars kan man bli kvar med default-platshållare (Spelare A1/B2).
  try{ applyPlayoffView(); }catch(e){}

}


function goToPlayoffs(){
  // Navigera till slutspelsfliken. Slutspel förhandsgranskas automatiskt.
  if(state.format!=="group_playoffs" && state.format!=="round_robin_playoffs"){
    alert("Slutspel finns bara när du valt Gruppspel + slutspel eller Serie + slutspel.");
    return;
  }
  var nums = getStepNums();
  state.step = nums.playoffs;
  saveState();
  renderAll();
  try{ window.scrollTo(0,0); }catch(e){}
}

function startPlayoffsFromCurrent(){
  // Starta/lås slutspel. I knockout används detta som en "start"-knapp (förhandsvisning → start).
  if(state.format==="knockout"){
    try{
      if(!state.playoffs || !Array.isArray(state.playoffs.matches) || state.playoffs.matches.length===0){
        const ids = (state.players||[]).map(p=>p.id);
        const po = (window.buildKnockoutBracket ? window.buildKnockoutBracket(ids) : (buildKnockoutBracket ? buildKnockoutBracket(ids) : []));
        state.playoffs = state.playoffs || {started:false, matches:[]};
        state.playoffs.matches = po;
        state.matches = po;
      }
      state.playoffs = state.playoffs || {started:false, matches:[]};
      state.playoffs.started = true;
      try{ state.step = getStepNums().playoffs; }catch(e){}
      saveState();
      renderAll();
    }catch(e){
      alert("Kunde inte starta slutspel.");
    }
    return;
  }

  // Lås slutspel baserat på nuvarande tabell.
  if(state.format!=="group_playoffs" && state.format!=="round_robin_playoffs"){
    alert("Slutspel finns bara när du valt Gruppspel + slutspel eller Serie + slutspel.");
    return;
  }

  var chk = canStartPlayoffsNow();
  if(!chk.ok){
    alert(chk.msg || "Slutspel kan inte startas ännu.");
    return;
  }

  if(state.format==="group_playoffs"){
    if(!groupStageComplete()){
      alert(chk.msg || "Gruppspelet är inte klart ännu.");
      return;
    }
  }

  if(state.format==="round_robin_playoffs"){
    var complete = true;
    for(var i=0;i<(state.matches||[]).length;i++){
      var m = state.matches[i];
      if(m && m.stage==="Grundspel" && !m.winnerId){ complete = false; break; }
    }
    if(!complete){
      alert(chk.msg || "Grundspelet (serien) är inte klart ännu.");
      return;
    }
  }

  var ok = ensurePlayoffs();
  if(!ok){
    alert("Kunde inte starta slutspel. Kontrollera att grundspelet är klart.");
    return;
  }

  try{ state.step = getStepNums().playoffs; }catch(e){}
  saveState();
  renderAll();
}

function reshuffleKnockout(){
  try{
    if(!state || state.format!=="knockout") return;
    if(state.playoffs && state.playoffs.started){
      alert("Slutspelet är startat och kan inte slumpas om.");
      return;
    }
    var ok = confirm("Slumpa om slutspelet?\n\nDetta lottar om trädet innan du startar.");
    if(!ok) return;

    const ids = (state.players||[]).map(p=>p.id);
    const po = (window.buildKnockoutBracket ? window.buildKnockoutBracket(ids) : (buildKnockoutBracket ? buildKnockoutBracket(ids) : []));
    state.playoffs = state.playoffs || {started:false, matches:[]};
    state.playoffs.matches = po;
    state.playoffs.started = false;
    state.matches = po;
    saveState();
    renderAll();
  }catch(e){}
}

// Ångra att man startat/låst slutspelet (så man kan ändra i grupp-/grundspel igen).
// Tillåts bara om inga slutspelsmatcher har spelats.
function undoPlayoffsStart(){
  // Dra tillbaka slutspel (rollback) så man kan slumpa om och starta igen.
  // I knockout: återgår till förhandsvisning.
  // I serie/grupp + slutspel: tar bort låst slutspel så man kan starta om från tabell.
  if(!state || !state.playoffs || !state.playoffs.started) return;

  var ms = (state.playoffs && Array.isArray(state.playoffs.matches)) ? state.playoffs.matches : [];

  // Tillåt rollback om inga riktiga resultat är satta.
  // (winnerId ensamt kan förekomma i vissa auto-flöden, så vi kräver mer än bara winnerId)
  var anyPlayed = false;
  for(var i=0;i<ms.length;i++){
    var m = ms[i];
    if(!m) continue;
    if(m.result || m.finishedAt || m.avgA || m.avgB || m.f9A || m.f9B || m.coA || m.coB || m.notes){
      anyPlayed = true; break;
    }
    if(m.winnerId && m.result){
      anyPlayed = true; break;
    }
  }
  if(anyPlayed){
    alert("Kan inte dra tillbaka när slutspelsmatcher redan har resultat.");
    return;
  }

  // Säkerhetsmekanism: dubbel bekräftelse
  var ok = confirm("Dra tillbaka slutspelet?\n\nDetta låser upp så att du kan slumpa om/ändra innan du startar igen.");
  if(!ok) return;

  var ok2 = confirm("Sista kontroll: Slutspelet återställs till förhandsvisning så att du kan slumpa om och starta igen.\n\nFortsätt?");
  if(!ok2) return;

  if(state.format==="knockout"){
    // Behåll trädet men återgå till preview-läge
    for(var j=0;j<ms.length;j++){
      var mm = ms[j];
      if(!mm) continue;
      mm.winnerId = "";
      mm.result = "";
      mm.avgA = ""; mm.avgB = "";
      mm.f9A = ""; mm.f9B = "";
      mm.coA = ""; mm.coB = "";
      mm.notes = "";
      mm.finishedAt = "";
    }
    state.playoffs.started = false;
    state.playoffs.matches = ms;
    state.matches = ms;
  }else{
    // För serie/grupp + slutspel: ta bort låsningen så man kan skapa/starta igen
    state.playoffs = null;
  }

  try{ saveState(); }catch(e){ alert("Kunde inte spara efter rollback."); }
  try{ renderAll(); }catch(e){ alert("Kunde inte uppdatera vyn efter rollback."); }
}



function getSeriesQualifyOptions(n){
  var opts = [{value:"all", label:"Alla"}];
  var arr = [2,4,8,16,32];
  for(var i=0;i<arr.length;i++){
    if(arr[i] <= n) opts.push({value:String(arr[i]), label:"Topp "+arr[i]});
  }
  return opts;
}

function enableSeriesPlayoffs(){
  try{
    var n = (state.players||[]).length;
    if(n < 4){ alert("Minst 4 spelare krävs för slutspel."); return; }
    var sel = document.getElementById('seriesQualifySelect');
    var val = sel ? sel.value : 'all';
    state.seriesQualifyCount = val || 'all';

    // Växla upplägg till Serie + slutspel
    state.format = 'round_robin_playoffs';

    // Nollställ ev. gammalt slutspel så att det skapas enligt nya inställningen
    state.playoffs = null;

    saveState();
    renderAll();
  }catch(e){
    alert("Kunde inte aktivera slutspel.");
  }
}

function disableSeriesPlayoffs(){
  // Ångra "Serie + slutspel" innan ni har startat slutspelet.
  try{
    if(state.playoffs && state.playoffs.started){
      alert('Slutspel är redan startat. För att ändra upplägget behöver ni nollställa eller importera en tidigare export.');
      return;
    }
    state.format = 'round_robin';
    state.seriesQualifyCount = 'all';
    state.playoffs = null;
    saveState();
    renderAll();
  }catch(e){
    alert('Kunde inte ångra aktiveringen.');
  }
}
function openPlayoffMatch(matchId){
  // Slutspelsmatcher får bara öppnas när slutspelet är startat (även i knockout).
  if(!state.playoffs || !state.playoffs.started){
    alert("Slutspel är inte startat ännu. Tryck 'Starta slutspel' när du vill börja spela.");
    return;
  }

  var m = (state.playoffs && state.playoffs.matches) ? state.playoffs.matches.find(function(x){return x.id===matchId;}) : null;
  if(!m) return;

  // Kvartsfinal/semifinal/final kan kräva deltagare beroende på upplägg
  if((m.id==="po_sf1" || m.id==="po_sf2") && (!m.aId || !m.bId)){
    alert("Semifinalen blir tillgänglig när relevanta kvartsfinaler är klara.");
    return;
  }
  if(m.id==="po_f" && (!m.aId || !m.bId)){
    alert("Finalen blir tillgänglig när båda semifinalerna är klara.");
    return;
  }

  modal.source = "playoffs";
  openMatchInternal(m);
}



function ruleSummary(){
  const r = state.rules;
  const inT = r.inRule==="single" ? "Enkel in" : "Dubbel in";
  const outT = r.outRule==="single" ? "Enkel ut" : "Dubbel ut";
  const legs = r.legsMode==="single" ? "1 leg" : "Bäst av 3";
  return `${r.game} • ${inT} • ${outT} • ${legs}`;
}

function renderMatches(){
  applyStartStamp();
  const ms = state.matches || [];
  const rows=[];
  rows.push(`<tr><th>Match</th><th>Status</th></tr>`);
  ms.forEach(m=>{
    const played = !!m.winnerId;
    const status = played
      ? `<span class="tag ok">${escapeHtml(playerName(m.winnerId))} vann ${m.result?`(${escapeHtml(m.result)})`:``}</span>`
      : `<span class="tag todo">Ej spelad</span>`;
    rows.push(`
      <tr class="matchRow ${played?'played':''}" onclick="openMatch('${m.id}')">
        <td>
          <div class='row' style='align-items:center;gap:8px'>${_avatarBtnViewHtml(m.aId, playerName(m.aId), 'small')}<strong>${escapeHtml(playerName(m.aId))}</strong><span class='muted'>vs</span>${_avatarBtnViewHtml(m.bId, playerName(m.bId), 'small')}<strong>${escapeHtml(playerName(m.bId))}</strong></div>
          <div class="matchMeta">
            <span class="tag">${m.group==='Alla' ? 'Serie' : 'Grupp '+escapeHtml(m.group)}</span>
            ${m.finishedAt ? `<span class="tag">Avsl: ${escapeHtml(formatDateTimeShort(m.finishedAt))}</span>` : ``}
            ${m.avgA || m.avgB ? `<span class="tag">Avg: ${escapeHtml(m.avgA||'–')} / ${escapeHtml(m.avgB||'–')}</span>` : ``}
          </div>
        </td>
        <td>${status}</td>
      </tr>
    `);
  });
  $("matchesTable").innerHTML = rows.join("");
  try{ hydrateAvatarsIn($("matchesTable")); }catch(e){}
}

function computeStandings(playerIds, matches, filterFn){
  const st = {};
  playerIds.forEach(pid => st[pid] = {
    pid,
    played: 0, w: 0, l: 0, pts: 0,
    legsWon: 0, legsLost: 0,
    avgSum: 0, avgCount: 0,
    f9Sum: 0, f9Count: 0,
    coSum: 0, coCount: 0
  });

  (matches || []).forEach(m => {
    if(filterFn && !filterFn(m)) return;

    // Averages
    if(m.avgA !== "" && !isNaN(parseFloat(m.avgA))){
      st[m.aId].avgSum += parseFloat(m.avgA);
      st[m.aId].avgCount += 1;
    }
    if(m.avgB !== "" && !isNaN(parseFloat(m.avgB))){
      st[m.bId].avgSum += parseFloat(m.avgB);
      st[m.bId].avgCount += 1;
    }

    // First 9
    if(m.f9A !== "" && !isNaN(parseFloat(m.f9A))){
      st[m.aId].f9Sum += parseFloat(m.f9A);
      st[m.aId].f9Count += 1;
    }
    if(m.f9B !== "" && !isNaN(parseFloat(m.f9B))){
      st[m.bId].f9Sum += parseFloat(m.f9B);
      st[m.bId].f9Count += 1;
    }

    // Checkout %
    if(m.coA !== "" && !isNaN(parseFloat(m.coA))){
      st[m.aId].coSum += parseFloat(m.coA);
      st[m.aId].coCount += 1;
    }
    if(m.coB !== "" && !isNaN(parseFloat(m.coB))){
      st[m.bId].coSum += parseFloat(m.coB);
      st[m.bId].coCount += 1;
    }

    if(!m.winnerId) return;

    const loserId = (m.winnerId === m.aId) ? m.bId : m.aId;

    // Match bookkeeping
    st[m.winnerId].played += 1;
    st[loserId].played += 1;
    st[m.winnerId].w += 1;
    st[loserId].l += 1;
    st[m.winnerId].pts += 2;

    // Legs bookkeeping (winner score stored first in m.result, e.g. "2-1")
    let wLegs = 0, lLegs = 0;
    if(m.result){
      const mm = String(m.result).match(/(\d+)\s*-\s*(\d+)/);
      if(mm){
        wLegs = parseInt(mm[1], 10);
        lLegs = parseInt(mm[2], 10);
      }
    }else{
      // Fallback for single-leg if result wasn't stored
      try{
        if(state && state.rules && state.rules.legsMode === "single"){
          wLegs = 1; lLegs = 0;
        }
      }catch(e){}
    }

    st[m.winnerId].legsWon  += wLegs;
    st[m.winnerId].legsLost += lLegs;
    st[loserId].legsWon     += lLegs;
    st[loserId].legsLost    += wLegs;
  });

  const arr = Object.values(st).map(x => ({
    ...x,
    avg: x.avgCount ? (x.avgSum / x.avgCount) : null,
    f9:  x.f9Count  ? (x.f9Sum  / x.f9Count)  : null,
    co:  x.coCount  ? (x.coSum  / x.coCount)  : null,
    legDiff: x.legsWon - x.legsLost
  }));

  arr.sort((a,b)=>{
    if(b.pts!==a.pts) return b.pts-a.pts;
    if(b.w!==a.w) return b.w-a.w;
    if(b.legDiff!==a.legDiff) return b.legDiff-a.legDiff;
    if(b.legsWon!==a.legsWon) return b.legsWon-a.legsWon;
    if(a.l!==b.l) return a.l-b.l;
    return playerName(a.pid).localeCompare(playerName(b.pid));
  });

  return arr;
}



function formatDateTimeIso(iso){
  if(!iso) return "";
  const d = new Date(iso);
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
}


function formatDateTimeShort(iso){
  if(!iso) return "";
  const d = new Date(iso);
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  return `${dd}/${mm} ${hh}:${mi}`;
}

function applyStartStamp(){
  const stamp = (state && state.startedAt) ? `Start: ${formatDateTimeIso(state.startedAt)}` : "";
  const ids = ["uiDateMatches","uiDateTable","uiDatePlayoffs","printDate","printDateFinals","printDateMatches","printDateTable"];
  ids.forEach(function(id){
    const el = document.getElementById(id);
    if(el) el.textContent = stamp;
  });
}


function nudgeNumber(id, delta){
  try{
    var el=document.getElementById(id);
    if(!el) return;
    var v=parseInt(String(el.value||"0"),10)||0;
    v=Math.max(0, v + (delta||0));
    el.value=v;
  }catch(e){}
}

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function nudgeNumber(id, delta){
  try{
    var el = document.getElementById(id);
    if(!el) return;
    var v = parseInt(String(el.value||'0'),10);
    if(isNaN(v)) v = 0;
    v = Math.max(0, v + (delta||0));
    el.value = String(v);
  }catch(e){}
}







function standingsTableHtml(standings, opts){
  opts = opts || {};
  var qualifyTop = opts.qualifyTop || 0;
  var title = opts.title || "";
  var sub = opts.sub || "";

  // Bullseye-kolumn (endast när turneringen är markerad som deltävling)
  var showBulls = false;
  var bullsMap = {};
  try{
    showBulls = _seriesEnabled();
    if(showBulls) bullsMap = computeLocalBullTotals() || {};
  }catch(e){ showBulls = false; bullsMap = {}; }

  var rows = standings.map(function(s,i){
    var avg = s.avg==null ? "–" : (Math.round(s.avg*10)/10).toFixed(1);
    var f9 = s.f9==null ? "–" : (Math.round(s.f9*10)/10).toFixed(1);
    var co = s.co==null ? "–" : (Math.round(s.co*10)/10).toFixed(1);
    var bulls = showBulls ? (bullsMap[s.pid]||0) : 0;
    var qual = (qualifyTop && i < qualifyTop);
    var cls = qual ? " class='qual'" : "";
    return `<tr${cls}><td>`+
      `<div class='row standingsPlayerCell'>`
      + `${i+1}.`
      + `${_avatarBtnViewHtml(s.pid, playerName(s.pid), 'small')}`
      + `<button type="button" class="linkbtn clickableName standingsNameBtn" onclick="event.stopPropagation(); openPlayerModal('${s.pid}')">${escapeHtml(playerName(s.pid))}</button>`
      + `</div>`+
      `</td><td>${s.played}</td><td>${s.w}</td><td>${s.l}</td>`+
      (showBulls ? `<td>${s.pts}</td><td>${bulls}</td>` : `<td>${s.pts}</td>`)+
      `<td>${s.legsWon}</td><td>${avg}</td><td>${f9}</td><td>${co}</td></tr>`;
  }).join("");

  var head = `<tr><th>Spelare</th><th>Sp</th><th>V</th><th>F</th><th>P</th>` + (showBulls?`<th>BULL</th>`:``) + `<th>Legs</th><th>Avg</th><th>F9</th><th>Utg %</th></tr>`;
  var info = sub ? `<div class="small">${sub}</div>` : "";
  return `${title?`<div class="row" style="justify-content:space-between;align-items:end"><strong>${escapeHtml(title)}</strong>${info}</div>`:""}<table>${head}${rows}</table>`;
}

function renderStandings(){
  applyStartStamp();
  var hint = "Poäng: 2 för vinst • Vid lika poäng: Vinster → Legskillnad → Vunna legs → Avg → Utg% → F9 → Färre förluster → Namn";
  var leg = document.getElementById("tableLegendBody");
  if(leg){
    leg.innerHTML = `<div><strong>${escapeHtml(hint)}</strong></div>` +
      `<div style="margin-top:4px">Förkortningar: <strong>Sp</strong>=spelade, <strong>V</strong>=vunna, <strong>F</strong>=förlorade, <strong>P</strong>=poäng, <strong>Legs</strong>=vunna–förlorade, <strong>Avg</strong>=snitt, <strong>F9</strong>=första 9, <strong>Utg %</strong>=uttag</div>`;
  }
  if(state.format==="round_robin" || state.format==="round_robin_playoffs"){
    var idsRR = (state.players||[]).map(function(p){return p.id;});
    // Grundspel/serie: alla matcher i state.matches är "Grundspel" för round robin.
    var stRR = computeStandings(idsRR, state.matches, function(m){ return m && m.stage==="Grundspel"; });

    var qualifyTopRR = 0;
    var subRR = "";
    if(state.format==="round_robin_playoffs"){
      var nRR = idsRR.length;
      qualifyTopRR = (nRR >= 8) ? 8 : 4;
      subRR = (qualifyTopRR===8)
        ? "Topp 8 går till slutspel (kvartsfinal: 1–8, 4–5, 2–7, 3–6)"
        : "Topp 4 går till slutspel (semifinal: 1–4, 2–3)";
    }

    var htmlRR = standingsTableHtml(stRR, {title:"Serie", qualifyTop:qualifyTopRR, sub:subRR});

    // Om man valt "Serie" utan slutspel från början: visa möjlighet att aktivera slutspel när serien är klar.
    if(state.format==="round_robin"){
      var ca = canActivatePlayoffsFromSeries();
      if(ca.ok){
        htmlRR += `<div class="row" style="justify-content:flex-end;margin-top:10px;gap:8px;flex-wrap:wrap">`
          + `<button class="btn" type="button" onclick="activatePlayoffsFromSeries()">Aktivera slutspel</button>`
          + `</div>`;
      }
    }

    $("standingsWrap").innerHTML = htmlRR;
    try{ hydrateAvatarsIn($("standingsWrap")); }catch(e){}
    return;
  }
  // Group formats
  var A = computeStandings(state.groups.A||[], state.matches, function(m){ return m.group==="A"; });
  var B = computeStandings(state.groups.B||[], state.matches, function(m){ return m.group==="B"; });
  var C = computeStandings(state.groups.C||[], state.matches, function(m){ return m.group==="C"; });
  var D = computeStandings(state.groups.D||[], state.matches, function(m){ return m.group==="D"; });

  var q = (state.format==="group_playoffs") ? 2 : 0;

  if(state.numGroups===4){
    $("standingsWrap").innerHTML =
      standingsTableHtml(A, {title:"Grupp A", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(B, {title:"Grupp B", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(C, {title:"Grupp C", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(D, {title:"Grupp D", qualifyTop:q});
  }else{
    $("standingsWrap").innerHTML =
      standingsTableHtml(A, {title:"Grupp A", qualifyTop:q}) +
      "<div style='height:10px'></div>" +
      standingsTableHtml(B, {title:"Grupp B", qualifyTop:q});
  }
  try{ hydrateAvatarsIn($("standingsWrap")); }catch(e){};
}


function renderFormatLegend(){
  var el = $("formatLegendBody");
  if(!el) return;

  var html = "";
  html += "<div style='margin-bottom:10px'><strong>Så fungerar uppläggen</strong><br>";
  html += "Välj spelform under <em>Upplägg</em>. När du har lagt till spelare och skapat turneringen genereras matchlistan automatiskt. Resultat du sparar uppdaterar tabeller och slutspel direkt.</div>";

  html += "<div style='margin:10px 0'><strong>Spelformer</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";

  html += "<li><strong>Slutspel</strong>: direkt enkel eliminering. Förlust innebär utslagning och vinnaren går vidare till nästa runda.</li>";
  html += "<li><strong>Alla möter alla (serie)</strong>: varje deltagare möter alla andra. Passar när ni vill spela en ren serie utan slutspel.</li>";
  html += "<li><strong>Serie + slutspel</strong>: först spelas en serie, därefter går de bäst placerade vidare till ett slutspel enligt tabellplacering.</li>";
  html += "<li><strong>Gruppspel</strong>: deltagarna delas in i grupper där alla möter alla inom sin grupp.</li>";
  html += "<li><strong>Gruppspel + slutspel</strong>: gruppspel först, därefter går de bäst placerade i varje grupp vidare till slutspel.</li>";
  html += "</ul>";

  html += "<div style='margin:12px 0 6px 0'><strong>Så visas matcherna</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";
  html += "<li>I matchlistan ser du status, slutresultat och valfri statistik.</li>";
  html += "<li>I slutspelsträdet visas resultat i rutorna och vinnare markeras tydligt.</li>";
  html += "</ul>";

  html += "<div style='margin:12px 0 6px 0'><strong>Funktioner</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";
  html += "<li>Stöd för singel och lag (2‑mot‑2).</li>";
  html += "<li>Val av 301 eller 501 samt enkel/dubbel in och ut.</li>";
  html += "<li>Automatisk tabell, avancemang och slutspel baserat på resultat.</li>";
  html += "<li>Möjlighet att spara turneringar lokalt och fortsätta senare.</li>";
  html += "</ul>";

  html += "<div style='margin:12px 0 6px 0'><strong>Begränsningar</strong></div>";
  html += "<ul style='margin:0; padding-left:18px; line-height:1.4'>";
  html += "<li>Endast enkel eliminering i slutspel (ingen dubbel-eliminering eller placeringsmatcher).</li>";
  html += "<li>Matcher spelas i legs (set-stöd saknas).</li>";
  html += "<li>Seedning och gruppindelning skapas automatiskt och kan inte justeras manuellt.</li>";
  html += "</ul>";

  el.innerHTML = html;
}


function openFormatLegend(){
  try{ renderFormatLegend(); }catch(e){}
  var ov = $("overlayFormatLegend");
  if(ov) ov.classList.remove("hidden");
}
function closeFormatLegend(){
  var ov = $("overlayFormatLegend");
  if(ov) ov.classList.add("hidden");
}

function onFormatChange(){
  var f = $("format") ? $("format").value : (state.format||"");

  // Grupper: visa bara om upplägget är gruppspel
  var wrap = $("numGroupsWrap");
  if(wrap){
    var showGroups = (f==="group_only" || f==="group_playoffs");
    wrap.style.display = showGroups ? "" : "none";
  }

  // Vidare till slutspel (gruppspel): visas bara för Gruppspel + slutspel
  try{
    if(!state.groupQualifyMode) state.groupQualifyMode = "top2";
    var card = document.getElementById('groupQualifyCard');
    var sel = document.getElementById('groupQualifySelect');
    var showQualify = (f === "group_playoffs");
    if(card) card.classList.toggle('hidden', !showQualify);
    if(sel) sel.value = state.groupQualifyMode || "top2";
  }catch(e){}

  // Serie: det finns inga grupper, så "vidare" är implicit (alla)
  if(f === "round_robin" || f === "round_robin_playoffs"){
    state.groupQualifyMode = "all";
  }

  try{ saveState(); }catch(e){}
}

function openTableLegend(){
  // Ensure content is up-to-date
  try{ if(!$("tableLegendBody") || !$("tableLegendBody").innerHTML) renderStandings(); }catch(e){}
  var ov = $("overlayTableLegend");
  if(ov) ov.classList.remove("hidden");
}
function closeTableLegend(){
  var ov = $("overlayTableLegend");
  if(ov) ov.classList.add("hidden");
}

function updateProgress(){
  const total = (state.matches||[]).length;
  const done = (state.matches||[]).filter(m=>!!m.winnerId).length;
  const _pp = $("progressPill"); if(_pp){ _pp.innerHTML = `<strong>${done}</strong> / ${total} klara`; }
  $("rulesPill").innerHTML = `<strong>${escapeHtml(state.rules.game)}</strong> • ${escapeHtml(ruleSummary())}`;
  if ($("rulesPillTable")) $("rulesPillTable").innerHTML = $("rulesPill").innerHTML;
}

function playWalkon(pid){
  var p = playerById(pid); if(!p) return;
  openSpotifyAuto(p.walkonUrl||"");
}

// ===== Deltävling (serie) – bullseye + slutspelspoäng =====
function _seriesEnabled(){
  try{ return !!(state && state.meta && state.meta.isSeriesEvent); }catch(e){ return false; }
}

function computeLocalBullTotals(){
  // Summera bullseyes per spelare från matchernas bullsA/bullsB (bakåtkompatibelt: seriesStats.*.bulls)
  var out = {};
  try{
    var ms = Array.isArray(state.matches) ? state.matches.slice() : [];
    try{ if(state && state.playoffs && Array.isArray(state.playoffs.matches)) ms = ms.concat(state.playoffs.matches); }catch(e){}
    ms.forEach(function(m){
      if(!m) return;
      var aId = m.aId, bId = m.bId;
      var aB = 0, bB = 0;
      if(typeof m.bullsA !== 'undefined' || typeof m.bullsB !== 'undefined'){
        aB = parseInt(String(m.bullsA||0),10) || 0;
        bB = parseInt(String(m.bullsB||0),10) || 0;
      }else if(m.seriesStats){
        try{ aB = parseInt(String((m.seriesStats.A||{}).bulls||0),10) || 0; }catch(e){}
        try{ bB = parseInt(String((m.seriesStats.B||{}).bulls||0),10) || 0; }catch(e){}
      }
      if(aId){ out[aId] = (out[aId]||0) + aB; }
      if(bId){ out[bId] = (out[bId]||0) + bB; }
    });
  }catch(e){}
  return out;
}

function playoffPointConfig(nPlayers){
  // Enkel skalning: större turnering = mer poäng i slutspel
  // 4-8: finalvinst 3p, 9-16: 4p, 17-32: 5p
  var final = 3;
  if(nPlayers>=9 && nPlayers<=16) final = 4;
  if(nPlayers>=17) final = 5;
  return {
    final: final,
    semi: Math.max(0, final-1),
    qf: Math.max(0, final-2),
    r16: Math.max(0, final-3),
    r32: Math.max(0, final-4),
    qual: 0
  };
}

function computeLocalPlayoffPoints(){
  // Summera slutspelspoäng per spelare (kval=0). Kräver winnerId på matcherna.
  var pts = {};
  try{
    var n = (state.players||[]).length;
    var cfg = playoffPointConfig(n);
    var ms = (state && state.playoffs && Array.isArray(state.playoffs.matches)) ? state.playoffs.matches : [];
    ms.forEach(function(m){
      if(!m || !m.winnerId) return;
      var g = String(m.group||'').toUpperCase();
      var add = 0;
      if(g==='F') add = cfg.final;
      else if(g==='SF') add = cfg.semi;
      else if(g==='QF') add = cfg.qf;
      else if(g==='R16') add = cfg.r16;
      else if(g==='R32') add = cfg.r32;
      else if(g==='K' || g==='QUAL') add = cfg.qual;
      pts[m.winnerId] = (pts[m.winnerId]||0) + add;
    });
  }catch(e){}
  return pts;
}
/* Modal */
var modalSidesSwapped = false;
var modalStatsOrderSwapped = false;

function updateModalTitleOrder(){
  // Matchrubriken ska spegla aktuell vänster/höger-ordning i modalen
  var m = (state.matches||[]).find(function(x){return x.id===modal.id;});
  if(!m) return;
  var leftId  = modalSidesSwapped ? m.bId : m.aId;
  var rightId = modalSidesSwapped ? m.aId : m.bId;
  var t = $("modalTitle");
  if(t) t.textContent = playerName(leftId) + " vs " + playerName(rightId);
}

function toggleSides(){
  modalSidesSwapped = !modalSidesSwapped;
  var mm = $("matchModal");
  if(mm) mm.classList.toggle("swapped", modalSidesSwapped);

  // På smala skärmar staplas A/B ofta vertikalt. Då vill vi att den som står först i rubriken
  // också kommer först i reglageordningen (utan att byta vad A/B betyder i datan).
  ensureStatsOrder(modalSidesSwapped);

  updateModalTitleOrder();
}

function _swapTwoChildren(parent){
  if(!parent) return;
  var kids = Array.prototype.slice.call(parent.children || []);
  if(kids.length < 2) return;
  parent.insertBefore(kids[1], kids[0]);
}

function ensureStatsOrder(swapped){
  // Vi vill att den som står först (vänster) också kommer först när reglagen staplas vertikalt.
  // För att inte riskera att A/B-datan blandas ihop byter vi bara DOM-ordning, inte id:n.
  if(!!swapped === !!modalStatsOrderSwapped) return;
  _swapTwoChildren($("avgSplit"));
  _swapTwoChildren($("f9Split"));
  _swapTwoChildren($("coSplit"));
  modalStatsOrderSwapped = !!swapped;
}

function openMatch(matchId){
  // Huvudmatcher + robust fallback för slutspelsmatcher
  if(matchId && String(matchId).indexOf("po_")===0){
    // Om detta är en slutspelsmatch, försök öppna via slutspelslogiken.
    try{
      if(state && state.playoffs && Array.isArray(state.playoffs.matches)){
        // I rent slutspel (knockout) ska man kunna förhandsgranska trädet innan start,
        // men inte spela/spara matcher förrän man tryckt "Starta slutspel".
        if(state.format==="knockout" && !state.playoffs.started){
          alert("Slutspel är inte startat ännu. Tryck 'Starta slutspel' när ni vill börja spela.");
          return;
        }
        var pm = state.playoffs.matches.find(function(x){ return x && x.id===matchId; });
        if(pm){
          modal.source = "playoffs";
          openMatchInternal(pm);
          return;
        }
      }
    }catch(e){}
  }

  var m = (state.matches||[]).find(function(x){return x.id===matchId;});
  if(!m) return;
  modal.source = "main";
  openMatchInternal(m);
}

function openMatchInternal(m){
  modal.id = m.id;

  // Återställ sidbyte när du öppnar en match
  modalSidesSwapped = false;
  var mm = $("matchModal");
  if(mm) mm.classList.remove("swapped");

  // Säkerställ att reglageordningen är återställd när en ny match öppnas
  ensureStatsOrder(false);

  var aName = playerName(m.aId);
  var bName = playerName(m.bId);
  
  var pidA = resolvePlayerId(m.aId) || m.aId;
  var pidB = resolvePlayerId(m.bId) || m.bId;
var titleEl = $("modalTitle");
  if(titleEl){
    titleEl.innerHTML =
      "<span class='matchTitleRow'>"
      + _avatarBtnViewHtml(pidA, aName, 'small')
      + "<span class='matchTitleName'>"+escapeHtml(aName)+"</span>"
      + "<span class='matchTitleVs'>vs</span>"
      + _avatarBtnViewHtml(pidB, bName, 'small')
      + "<span class='matchTitleName'>"+escapeHtml(bName)+"</span>"
      + "</span>";
    setTimeout(function(){ try{ hydrateAvatarsIn(titleEl); }catch(e){} }, 0);
  }
  var ctx = (m.group==='Alla'?'Serie':(m.group==='A' || m.group==='B' ? 'Grupp '+m.group : (m.round||m.group||'')));
  $("modalMeta").textContent = ctx + " • " + ruleSummary();
  try{ hydrateAvatarsIn($("matchModal")); }catch(e){}
  $("winA").textContent = "Vinnare: " + playerName(m.aId);
  $("winB").textContent = "Vinnare: " + playerName(m.bId);
  $("avgALabel").textContent = "Average (" + playerName(m.aId) + ")";
  $("avgBLabel").textContent = "Average (" + playerName(m.bId) + ")";
  $("f9ALabel").textContent = "First 9 (" + playerName(m.aId) + ")";
  $("f9BLabel").textContent = "First 9 (" + playerName(m.bId) + ")";
  $("coALabel").textContent = "Utgång % (" + playerName(m.aId) + ")";
  $("coBLabel").textContent = "Utgång % (" + playerName(m.bId) + ")";

  $("avgA").value = (m.avgA!=null && m.avgA!=="" ? m.avgA : 70.0);
  $("avgB").value = (m.avgB!=null && m.avgB!=="" ? m.avgB : 70.0);
  $("f9A").value = (m.f9A!=null && m.f9A!=="" ? m.f9A : Number($("avgA").value||70.0));
  $("f9B").value = (m.f9B!=null && m.f9B!=="" ? m.f9B : Number($("avgB").value||70.0));
  $("coA").value = (m.coA!=null && m.coA!=="" ? m.coA : 0.0);
  $("coB").value = (m.coB!=null && m.coB!=="" ? m.coB : 0.0);
  $("notes").value = m.notes || "";

  // Bullseye (deltävling): visa bara om turneringen är markerad som deltävling
  try{
    if(!state.meta) state.meta = { isSeriesEvent:false, seriesName:"" };
    var showSeries = !!(state.meta && state.meta.isSeriesEvent);
    var bw = document.getElementById('seriesBonusWrap');
    if(bw) bw.classList.toggle('hidden', !showSeries);
    if(showSeries){
      // bakåtkompatibelt: stöd även gamla exports (seriesStats.A/B.bulls)
      var aB = 0, bB = 0;
      if(typeof m.bullsA !== 'undefined' || typeof m.bullsB !== 'undefined'){
        aB = parseInt(String(m.bullsA||0),10) || 0;
        bB = parseInt(String(m.bullsB||0),10) || 0;
      } else if(m.seriesStats){
        try{ aB = parseInt(String((m.seriesStats.A||{}).bulls||0),10) || 0; }catch(e){}
        try{ bB = parseInt(String((m.seriesStats.B||{}).bulls||0),10) || 0; }catch(e){}
      }
      var ba = document.getElementById('bullsA'); if(ba) ba.value = aB;
      var bb = document.getElementById('bullsB'); if(bb) bb.value = bB;
      var la = document.getElementById('seriesBonusLabelA'); if(la) la.textContent = playerName(m.aId);
      var lb = document.getElementById('seriesBonusLabelB'); if(lb) lb.textContent = playerName(m.bId);
    }
  }catch(e){}
  syncStatSliders();
  try{ resetStatsImportUi(); }catch(e){}

  // Per-match override för utgång (enkel->dubbel). Visas bara när turneringen är Enkel ut.
  const gOut = (state.rules && state.rules.outRule) || "single";
  const wrap = $("outOverrideWrap");
  const chk = $("outOverrideDouble");
  if(wrap && chk){
    if(gOut === "double"){
      wrap.style.display = "none";
      chk.checked = false;
    } else {
      wrap.style.display = "block";
      chk.checked = (m.outRule === "double");
    }
  }

  $("winA").classList.toggle("primary", m.winnerId===m.aId);
  $("winB").classList.toggle("primary", m.winnerId===m.bId);

  renderResultButtons(m);
  renderWalkonInfo(m);

  // Lås om matchen redan är sparad
  var played = !!m.winnerId;
  setModalLocked(played);

  $("overlay").classList.remove("hidden");
document.body.classList.add("modal-open");
  try{ _attachSliderNudges(document.getElementById('matchModal')); }catch(e){}
  try{ document.querySelector("#overlay .modal").scrollTop = 0; }catch(e){}
  // Synka bubblor efter att modalen blivit synlig (mobil-webview kan annars ge 0px-bredd)
  requestAnimationFrame(function(){
    syncStatSliders();
    requestAnimationFrame(syncStatSliders);
  });

}

function renderWalkonInfo(m){
  var pa = playerById(m.aId) || {};
  var pb = playerById(m.bId) || {};
  function detectUrl(p){
    // If walkonUrl is empty but label looks like a spotify link, treat it as url
    var u = (p.walkonUrl||"").trim();
    if(!u){
      var lab = (p.walkonLabel||"").trim();
      if(lab.indexOf("open.spotify.com/")>=0 || lab.indexOf("https://open.spotify.com/")===0 || lab.indexOf("spotify:")===0){
        u = lab;
      }
    }
    return u;
  }
  function detectLabel(p){
    var lab = (p.walkonLabel||"").trim();
    // If label is a URL, show a generic label
    if(lab.indexOf("open.spotify.com/")>=0 || lab.indexOf("https://open.spotify.com/")===0 || lab.indexOf("spotify:")===0){
      return "Walk-on";
    }
    return lab || "Walk-on";
  }
  function line(pid, p){
    if(!(p.walkonLabel || p.walkonUrl)) return "";
    var label = escapeHtml(detectLabel(p));
    var url = detectUrl(p);
    var who = "<strong>"+escapeHtml(playerName(pid))+"</strong>";
    if(url){
      var urlEsc = escapeHtml(url);
      return "🎵 "+who+": "+label+"<br><a class='link' href='"+urlEsc+"' target='_blank' rel='noopener' onclick=\"stopPropagation(event)\">Öppna i Spotify</a>";
    }
    return "🎵 "+who+": "+label;
  }
  var lines = [];
  var la = line(m.aId, pa); if(la) lines.push(la);
  var lb = line(m.bId, pb); if(lb) lines.push(lb);
  $("walkonInfo").innerHTML = lines.length ? lines.join("<hr style='border:none;border-top:1px solid var(--border);margin:10px 0'>")
                                           : "<span class='small'>Inga walk-on songs sparade för den här matchen.</span>";
}

function renderResultButtons(m){
  const wrap = $("resultButtons");
  const hint = $("resultHint");
  wrap.innerHTML = "";
  hint.textContent = "";

  if(state.rules.legsMode === "single"){
    return;
  }

  const opts = ["2-0","2-1"];
  opts.forEach(res=>{
    const btn = document.createElement("button");
    btn.className = "btn secondary";
    btn.textContent = res;
    btn.onclick = function(){
      m.result = res;
      saveState();
      Array.from(wrap.querySelectorAll("button")).forEach(b=>{ b.className="btn secondary"; });
      btn.className = "btn";
      hint.innerHTML = "Valt resultat: <strong>"+res+"</strong>";
    };
    if(m.result === res){
      btn.className = "btn";
      hint.innerHTML = "Valt resultat: <strong>"+res+"</strong>";
    }
    wrap.appendChild(btn);
  });

  if(!m.result) hint.textContent = "Bäst av 3: Välj 2-0 eller 2-1.";
}

function closeModal(){
  try{ setModalLocked(false); }catch(e){}
  $("overlay").classList.add("hidden");
  document.body.classList.remove("modal-open");
}
function getCurrentMatch(){
  // Robust match lookup: fungerar även om modal.source saknas eller om match-id finns i båda listor.
  var id = (modal && modal.id) ? modal.id : null;
  if(!id) return null;

  var fromMain = null;
  try{
    fromMain = (state.matches||[]).find(function(x){ return x && x.id===id; }) || null;
  }catch(e){ fromMain = null; }

  var fromPlayoffs = null;
  try{
    if(state && state.playoffs && Array.isArray(state.playoffs.matches)){
      fromPlayoffs = state.playoffs.matches.find(function(x){ return x && x.id===id; }) || null;
    }
  }catch(e){ fromPlayoffs = null; }

  // Respektera explicit källa – men fall back om den inte hittar matchen.
  if(modal && modal.source==="playoffs") return fromPlayoffs || fromMain;
  if(modal && modal.source==="main") return fromMain || fromPlayoffs;

  // Om källan inte är satt: välj efter id-prefix eller vad som finns.
  if(String(id).indexOf("po_")===0) return fromPlayoffs || fromMain;

  return fromMain || fromPlayoffs;
}

function pickWinner(side){
  var mm = getCurrentMatch();
  if(!mm) return;

  mm.winnerId = (side==="A") ? mm.aId : mm.bId;

  var winA = document.getElementById("winA");
  var winB = document.getElementById("winB");
  if(winA) winA.classList.toggle("primary", mm.winnerId===mm.aId);
  if(winB) winB.classList.toggle("primary", mm.winnerId===mm.bId);

  saveState();
  try{
    if(modal && modal.source==="playoffs"){
      if(state && state.format==="knockout") advancePlayoffWinners();
      else updateFinalFromSemis();
    }
  }catch(e){}
}

function clearMatch(){
  const m = getCurrentMatch();
  if(!m) return;
  m.winnerId = "";
  m.result = "";
  m.avgA = "";
  m.avgB = "";
  m.f9A = "";
  m.f9B = "";
  m.coA = "";
  m.coB = "";
  m.notes = "";
  try{ if(m.seriesStats) delete m.seriesStats; }catch(e){}
  try{ if(typeof m.bullsA!=='undefined') m.bullsA = 0; }catch(e){}
  try{ if(typeof m.bullsB!=='undefined') m.bullsB = 0; }catch(e){}
  try{
    var ba=document.getElementById('bullsA'); if(ba) ba.value=0;
    var bb=document.getElementById('bullsB'); if(bb) bb.value=0;
  }catch(e){}
  $("winA").classList.remove("primary");
  $("winB").classList.remove("primary");
  try{
    if(modal && modal.source==="playoffs" && state && state.format==="knockout"){
      // Rensa nedströms deltagare där denna vinnare tidigare kan ha gått vidare
      advancePlayoffWinners();
    }
  }catch(e){}

  saveState();
  renderResultButtons(m);
  syncStatSliders();
}

function saveMatch(){
  if(state.modalLocked){ alert("Matchen är låst. Tryck på Redigera om du vill ändra."); return; }

  const m = getCurrentMatch();
  if(!m) return;

  if(!m.winnerId){ alert("Välj vinnare först."); return; }

  const a = $("avgA").value.trim();
  const b = $("avgB").value.trim();
  const f9a = $("f9A").value.trim();
  const f9b = $("f9B").value.trim();
  const coa = $("coA").value.trim();
  const cob = $("coB").value.trim();
  if(a && isNaN(parseFloat(a))) { alert("Average för " + playerName(m.aId) + " måste vara ett tal."); return; }
  if(b && isNaN(parseFloat(b))) { alert("Average för " + playerName(m.bId) + " måste vara ett tal."); return; }
  if(f9a && isNaN(parseFloat(f9a))) { alert("First 9 för " + playerName(m.aId) + " måste vara ett tal."); return; }
  if(f9b && isNaN(parseFloat(f9b))) { alert("First 9 för " + playerName(m.bId) + " måste vara ett tal."); return; }
  if(coa && isNaN(parseFloat(coa))) { alert("Utgång % för " + playerName(m.aId) + " måste vara ett tal."); return; }
  if(cob && isNaN(parseFloat(cob))) { alert("Utgång % för " + playerName(m.bId) + " måste vara ett tal."); return; }

  m.avgA = a;
  m.avgB = b;
  m.f9A = f9a;
  m.f9B = f9b;
  m.coA = coa;
  m.coB = cob;
  m.notes = $("notes").value.trim();

  // Bullseye (deltävling): sparas per match (ger inga poäng)
  try{
    if(!state.meta) state.meta = { isSeriesEvent:false, seriesName:"" };
    var enabled = !!(state.meta && state.meta.isSeriesEvent);
    if(enabled){
      var ba = document.getElementById('bullsA');
      var bb = document.getElementById('bullsB');
      m.bullsA = ba ? (parseInt(String(ba.value||"0"),10)||0) : 0;
      m.bullsB = bb ? (parseInt(String(bb.value||"0"),10)||0) : 0;
    } else {
      // Om turneringen inte är deltävling, rensa ev. tidigare bull-data för att undvika förvirring
      if(typeof m.bullsA !== 'undefined') m.bullsA = 0;
      if(typeof m.bullsB !== 'undefined') m.bullsB = 0;
    }
    // Bakåtkompatibelt: rensa gammal bonusdata
    if(m.seriesStats) delete m.seriesStats;
  }catch(e){}

  // Vilket utgångsläge användes faktiskt i matchen?
  // Standard = turneringsvalet, men vid Enkel ut kan man override till Dubbel ut.
  let usedOut = (state.rules && state.rules.outRule) || "single";
  const override = $("outOverrideDouble") && $("outOverrideDouble").checked;
  if(usedOut !== "double" && override){ usedOut = "double"; }
  m.outRule = usedOut;

  if(state.rules.legsMode === "single"){
    m.result = "1-0";
  }else{
    if(!m.result){ alert("Välj resultat (2-0 eller 2-1)."); return; }
  }
  m.finishedAt = new Date().toISOString();
  recordHistoryForMatch(m);

  // === FIX: Säkra att sparning av po_* alltid skrivs till state.playoffs.matches (inte bara en lokal referens) ===
  try{
    if(m && m.id && String(m.id).indexOf("po_")===0 && state && state.playoffs && Array.isArray(state.playoffs.matches)){
      const pm = state.playoffs.matches.find(x => x && x.id===m.id) || null;
      if(pm && pm !== m){
        // Kopiera centrala fält som påverkar status/propagering/rendering
        const keys = ["aId","bId","winnerId","result","avgA","avgB","f9A","f9B","coA","coB","notes","outRule","finishedAt","bullsA","bullsB"];
        for(const k of keys){
          if(Object.prototype.hasOwnProperty.call(m,k)) pm[k] = m[k];
        }
      }
      // Om modalen öppnades via fel källa: tvinga playoffs som källa så övrig logik körs rätt.
      try{ if(typeof modal!=="undefined") modal.source = "playoffs"; }catch(e){}
    }
  }catch(e){}

  try{
    if(modal && modal.source==="playoffs" && m.id && String(m.id).indexOf("po_")===0){
      if(state && state.format==="knockout"){
        advancePlayoffWinners();
      }else{
        // Grupp/serie-slutspel: fyll final (och ev. semifinaler om kvarts finns) från spelade matcher
        updateFinalFromSemis();
      }
      // Spegla ev. po_* som kan finnas i state.matches så trädet alltid får senaste data
      ensurePlayoffsSync();
    }
  }catch(e){}

  autosaveTournament();
  saveState();
  closeModal();
  renderAll();
}

function recordHistoryForMatch(m){
  try{
    if(!m || !m.winnerId) return;
    // just nu: spara historik bara för singel-läge (spelareprofiler)
    if(state.mode && state.mode !== "single") return;
    var res = m.result || (state.rules && state.rules.legsMode==="single" ? "1-0" : "");
    var parts = String(res||"").split("-");
    var aW = parseInt(parts[0]||"0",10) || 0;
    var bW = parseInt(parts[1]||"0",10) || 0;

    function perSide(pid, isA){
      var won = (m.winnerId === pid);
      var legsFor = isA ? aW : bW;
      var legsAgainst = isA ? bW : aW;
      if(!won){ // om denna sida förlorade, byt om så legsFor alltid är dennes legs
        // i res-strängen representerar aW-bW antal lägg för A respektive B oavsett vinnare
      }
      var avg = parseFloat(isA ? m.avgA : m.avgB);
      var f9  = parseFloat(isA ? m.f9A : m.f9B);
      var co  = parseFloat(isA ? m.coA : m.coB);
      if(isNaN(avg)) avg = null;
      if(isNaN(f9)) f9 = null;
      if(isNaN(co)) co = null;
      var opp = isA ? playerName(m.bId) : playerName(m.aId);
      upsertHistoryMatch(pid, {
        matchId: (state.startedAt||'') + '::' + m.id,
        finishedAt: m.finishedAt,
        opponent: opp,
        won: won,
        result: res,
        legsFor: legsFor,
        legsAgainst: legsAgainst,
        avg: avg,
        f9: f9,
        co: co,
        outRule: m.outRule || ((state.rules && state.rules.outRule) ? state.rules.outRule : 'single')
      });
    }
    perSide(m.aId, true);
    perSide(m.bId, false);
  }catch(e){}
}




function renderPlayersStep(){
  // Synka val
  if($("playerSource3")){
    $("playerSource3").value = state.playerSource || "manual";
  }
  const isFile = (false);
  const fileWrap = $("fileImportWrap");
  const manualWrap = $("manualPlayersWrap");
  // Visa "Lägg till spelare i lista" endast efter import av turnering
  try{
    const bar = document.getElementById("importPlayersFromTournamentBar");
    const show = !!(state && state._importedTournament && Array.isArray(state.players) && state.players.length);
    if(bar) bar.style.display = show ? "block" : "none";
  }catch(e){}

  if(fileWrap && manualWrap){
    if(isFile){
      fileWrap.classList.remove("hidden");
      manualWrap.classList.add("hidden");
    }else{
      fileWrap.classList.add("hidden");
      manualWrap.classList.remove("hidden");
    }
  }

  // Förhandsvisning
  if($("playersPreview3")){
    if(state.importedPlayers && state.importedPlayers.length){
      const rows = state.importedPlayers.slice(0,20).map(p => `
        <tr>
          <td>${escapeHtml(p.name||"")}</td>
          <td class="small">${escapeHtml(p.walkonLabel||"")}</td>
          <td class="small">${p.walkonUrl ? `<a href="${escapeHtml(p.walkonUrl)}" target="_blank" rel="noopener">Spotify</a>` : "-"}</td>
          <td class="small">${escapeHtml(p.darts||"")}</td>
        </tr>`).join("");
      $("playersPreview3").innerHTML = `
        <div class="small" style="margin-bottom:8px"><strong>${state.importedPlayers.length}</strong> spelare hittade . Förhandsvisar upp till 20.</div>
        <div class="tablewrap">
          <table>
            <thead><tr><th>Namn</th><th>Walk-on</th><th>Länk</th><th>Pilar</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }else{
      $("playersPreview3").innerHTML = `<div class="small">Ingen fil inläst ännu.</div>`;
    }
  }

  // Växla UI för import/kiosk + singel/lag
  if(!state.entryMode) state.entryMode = "import";
  if(!state.mode) state.mode = "single";
  var ms = document.getElementById("mode");
  if(ms && ms.value) state.mode = ms.value;
  try{ applyEntryUI(); }catch(e){}
}

function onPlayerSource3Change(){
  state.playerSource = $("playerSource3") ? $("playerSource3").value : "manual";
  saveState();
  renderPlayersStep();
}

// Enkel manuella fält-parser (stöd för citattecken)
function parseCSV(text){
  const lines = (text||"").split(/\r?\n/).filter(l => l.trim().length>0);
  if(lines.length===0) return { headers: [], rows: [] };

  function parseLine(line){
    const out=[];
    let cur="", inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch==='"'){
        if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
        else inQ=!inQ;
      }else if(ch===',' && !inQ){
        out.push(cur);
        cur="";
      }else{
        cur+=ch;
      }
    }
    out.push(cur);
    return out.map(s=>s.trim());
  }

  const headers = parseLine(lines[0]).map(h => h.replace(/^\uFEFF/, "").trim().toLowerCase());
  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols = parseLine(lines[i]);
    const row={};
    headers.forEach((h,idx)=> row[h]= (cols[idx]!==undefined ? cols[idx].trim() : ""));
    rows.push(row);
  }
  return { headers, rows };
}

function buildPlayersFromCSV(text){
  const { headers, rows } = parseCSV(text);
  const col = (name)=> headers.includes(name) ? name : null;

  const cDelta = col("delta");
  const cName = col("namn") || col("name");
  const cWalk = col("walkon_visning") || col("walkon") || col("walk-on") || col("walkon_namn");
  const cUrl  = col("spotify_link") || col("spotify") || col("spotify_länk") || col("link");
  const cDarts= col("pilar") || col("darts");

  if(!cName){
    throw new Error("manuella fält saknar kolumnen 'namn'.");
  }

  const out=[];
  const seen=new Set();
  rows.forEach(r=>{
    const delta = (cDelta ? (r[cDelta]||"") : "1").trim();
    if(cDelta && !(delta==="1" || delta.toLowerCase()==="ja" || delta.toLowerCase()==="true")) return;

    const name=(r[cName]||"").trim();
    if(!name) return;
    const key=name.toLowerCase();
    if(seen.has(key)) return;
    seen.add(key);

    const walkonLabel = (cWalk ? (r[cWalk]||"") : "").trim();
    const walkonUrl   = (cUrl  ? (r[cUrl]||"")  : "").trim();
    const darts       = (cDarts? (r[cDarts]||"") : "").trim();

    out.push({ id: uuid(), name, walkonLabel, walkonUrl, darts });
  });
  return out;
}

// ===== XLSX import (minimal, offline) =====
// Läser första bladet (sheet1.xml) och tolkar rubrikerna på rad 1.
async 

// (XLSX-import borttagen)

function looksLikeUrl(s){
  s = (s||"").trim();
  return /^https?:\/\//i.test(s) || /^spotify:/i.test(s);
}

function normalizeDelta(v){
  v = (v==null?"":String(v)).trim().toLowerCase();
  if(!v) return false;
  return (v==="1" || v==="ja" || v==="true" || v==="x" || v==="✅" || v==="y" || v==="yes");
}

function toRawCsvUrl(url){
  url = (url||"").trim();
  // Drive file view -> direct download (kan fortfarande kräva att filen är delad publikt)
  var m = url.match(/drive\.google\.com\/file\/d\/([^\/]+)\//);
  if(m){
    return "https://drive.google.com/uc?export=download&id=" + m[1];
  }
  // Google Sheets share URL -> export csv (gid unknown). We'll keep as-is if already contains export=csv.
  if(url.indexOf("docs.google.com/spreadsheets")>=0 && url.indexOf("export?format=csv")<0 && url.indexOf("gviz/tq")<0){
    // Best effort: use gviz (works without gid for first sheet in many cases)
    var idm = url.match(/spreadsheets\/d\/([^\/]+)/);
    if(idm){
      return "https://docs.google.com/spreadsheets/d/" + idm[1] + "/gviz/tq?tqx=out:csv";
    }
  }
  return url;
}

// Minimal manuella fält parser with quotes support
function parseCsv(text){
  var rows=[];
  var row=[], cur="", inQ=false;
  for(var i=0;i<text.length;i++){
    var ch=text[i];
    if(inQ){
      if(ch === '"'){
        if(text[i+1] === '"'){ cur+='"'; i++; }
        else { inQ=false; }
      }else cur+=ch;
    }else{
      if(ch === '"'){ inQ=true; }
      else if(ch === ','){ row.push(cur); cur=""; }
      else if(ch === '\n'){
        row.push(cur); rows.push(row); row=[]; cur="";
      }else if(ch === '\r'){
        // ignore
      }else cur+=ch;
    }
  }
  if(cur.length || row.length){ row.push(cur); rows.push(row); }
  return rows;
}

// ===== Snabbimport (klistra in tabell) =====
function bulkClear(){
  var ta = document.getElementById('bulkPaste');
  if(ta) ta.value='';
  var st = document.getElementById('bulkStatus');
  if(st) st.textContent = '';
}

function bulkParse(){
  var ta = document.getElementById('bulkPaste');
  var st = document.getElementById('bulkStatus');
  var raw = (ta ? ta.value : '').trim();
  if(!raw){
    if(st) st.textContent = 'Klistra in några rader först.';
    alert('Klistra in några rader först.');
    return;
  }
  var delim = '\t';
  if(raw.indexOf('\t')<0 && raw.indexOf('|')>=0) delim = '|';
  var lines = raw.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  // hoppa över rubrikrad om den finns
  if(lines.length && /\b(delta|namn|walkon|spotify|pilar)\b/i.test(lines[0])) lines.shift();

  var names=[], walkon=[], links=[], darts=[];
  var used=0;
  for(var i=0;i<lines.length;i++){
    var parts = lines[i].split(delim).map(p=>p.trim());
    if(parts.length===1) continue;

    var hasDelta = parts.length>=5 && /^(0|1|ja|nej|true|false|x|✅)$/i.test(parts[0]||'');
    var delta = hasDelta ? parts[0] : '1';
    var name  = hasDelta ? parts[1] : parts[0];
    var w     = hasDelta ? (parts[2]||'') : (parts[1]||'');
    var link  = hasDelta ? (parts[3]||'') : (parts[2]||'');
    var pil   = hasDelta ? (parts[4]||'') : (parts[3]||'');

    if(hasDelta && !normalizeDelta(delta)) continue;
    if(!name) continue;

    // om någon kopierar en klickbar text från Sheets kan den innehålla extra saker – behåll bara URL om vi hittar en
    var m = (link||'').match(/(https?:\/\/[^\s]+|spotify:[^\s]+)/i);
    link = m ? m[1].trim() : (looksLikeUrl(link) ? link.trim() : '');

    names.push(name);
    walkon.push(w);
    links.push(link);
    darts.push(pil);
    used++;
  }

  document.getElementById('players').value = names.join('\n');
  document.getElementById('walkonLabels').value = walkon.join('\n');
  document.getElementById('spotifyLinks').value = links.join('\n');
  document.getElementById('darts').value = darts.join('\n');

  if(st) st.textContent = used ? ('Importerade '+used+' spelare till fälten nedan.') : 'Hittade inga spelare (kolla formatet).';
  // uppdatera ev. förhandsvisning om sidan redan visar spelare
  try{ renderPlayersPreview && renderPlayersPreview(); }catch(e){}
}









// Auto-fetch on load if configured
window.addEventListener("DOMContentLoaded", ()=>{
  // Kiosk-knappar
  try{
    var bs = document.getElementById('btnOpenSpotify');
    if(bs) bs.addEventListener('click', function(){ openSpotify(); });
    var ba = document.getElementById('btnKioskAdd');
    if(ba) ba.addEventListener('click', function(){ kioskAddSingle(); });
    var bat = document.getElementById('btnKioskAddTeam');
    if(bat) bat.addEventListener('click', function(){ kioskAddTeam(); });
  }catch(e){}
  // Enter-tangent sparar i kiosk-läge
  try{
    ['kName','kSpotify','kDarts'].forEach(function(id){
      var el=document.getElementById(id);
      if(el) el.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); kioskAddSingle(); }});
    });
    ['kTeamName','kTeamP1','kTeamP2','kTeamSpotify','kTeamDarts'].forEach(function(id){
      var el=document.getElementById(id);
      if(el) el.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); kioskAddTeam(); }});
    });
  }catch(e){}

  // Ladda ev. sparat läge och rendera på ett säkert sätt (mobil-webbläsare kan annars tyst svälja fel)
  let loaded=false;
  try{ if(typeof loadState === "function") loaded = !!loadState(); }catch(e){ console.error(e); }
  // Om inget vanligt sparat läge finns, försök återställ från autospar
  if(!loaded){
    try{ if(typeof loadAutosaveTournament === "function") loaded = !!loadAutosaveTournament(); }catch(e){ console.error(e); }
    if(loaded){
      try{ saveState(); }catch(e){}
    }
  }
  try{ if(typeof renderAll === "function") renderAll(); }catch(e){ console.error(e); }

  // Serie (deltävling-flagga): koppla UI till state.meta
  try{
    var chk = document.getElementById('isSeriesEvent');
    var wrap = document.getElementById('seriesNameWrap');
    var inp = document.getElementById('seriesName');
    if(!state.meta) state.meta = { isSeriesEvent:false, seriesName:"", bonusProfile:"pulsi" };
    if(chk){
      chk.checked = !!(state.meta && state.meta.isSeriesEvent);
      if(wrap) wrap.style.display = chk.checked ? 'block' : 'none';
      if(inp) inp.value = (state.meta.seriesName||"");
      chk.addEventListener('change', function(){
        try{
          if(!state.meta) state.meta = { isSeriesEvent:false, seriesName:"", bonusProfile:"pulsi" };
          state.meta.isSeriesEvent = !!chk.checked;
          if(wrap) wrap.style.display = chk.checked ? 'block' : 'none';
          saveState();
        }catch(e){}
      });
    }
    if(inp){
      inp.addEventListener('input', function(){
        try{ if(!state.meta) state.meta = { isSeriesEvent:false, seriesName:"", bonusProfile:"pulsi" }; state.meta.seriesName = inp.value || ""; saveState(); }catch(e){}
      });
    }
  }catch(e){}

  // Kiosk/Import – koppla knappar
  try{
    var bi = document.getElementById('btnEntryImport');
    if(bi) bi.addEventListener('click', function(){ try{ setEntryMode('import'); }catch(e){} });
    var bk = document.getElementById('btnEntryKiosk');
    if(bk) bk.addEventListener('click', function(){ try{ setEntryMode('kiosk'); }catch(e){} });

    var s1 = document.getElementById('btnOpenSpotify');
    if(s1) s1.addEventListener('click', function(){ try{ openSpotify(); }catch(e){} });
    var s2 = document.getElementById('btnOpenSpotify2');
    if(s2) s2.addEventListener('click', function(){ try{ openSpotify(); }catch(e){} });

    var add1 = document.getElementById('btnKioskAdd');
    if(add1) add1.addEventListener('click', function(){ try{ kioskAddSingle(); }catch(e){} });
    var add2 = document.getElementById('btnKioskAddTeam');
    if(add2) add2.addEventListener('click', function(){ try{ kioskAddTeam(); }catch(e){} });
    // Se till att rätt vy syns efter laddning
    try{ applyEntryUI(); }catch(e){}
  }catch(e){ console.error(e); }

  // Om sidan öppnas via content:// på Android kan lagring rensas vid uppdatering.
  // Erbjud då återställning via backupfil.
  try{
    const proto = (location && typeof location.protocol==="string") ? location.protocol : "";
    const isContent = proto.startsWith("content");
    if(!loaded && isContent){
      setTimeout(()=>{
        try{
          if(confirm("Ingen sparad session hittades (Android kan rensa lokal lagring när du uppdaterar).\n\nVill du återställa från en backupfil?")){
            const inp = document.getElementById("importBackup");
            if(inp) inp.click();
          }
        }catch(e){}
      }, 50);
    }
  }catch(e){}
  // Autospara: viktigt på Android/content:// där man lätt råkar uppdatera/flippa flikar
  // Förbättring (utan att ändra funktion): debounce på ändringar + backup-intervall, och skydd mot samtidiga spar.
  try{
    const doSave = ()=>{
      try{
        if(window.__LH_SAVING__) return; // undvik re-entrance om flera triggers kommer samtidigt
        window.__LH_SAVING__ = true;
        if(typeof saveState==="function") saveState();
      }catch(e){
        // lämna tyst som tidigare (vill du felsöka kan du logga här)
      }finally{
        window.__LH_SAVING__ = false;
      }
    };

    // Spara alltid vid navigation/avslut
    window.addEventListener("beforeunload", doSave);
    window.addEventListener("pagehide", doSave);

    // Debounce spara när användaren gör ändringar (input/change/click fångar de flesta UI-interaktioner)
    let saveTimer = null;
    const scheduleSave = ()=>{
      try{
        if(saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(doSave, 800);
      }catch(e){}
    };

    document.addEventListener("input", scheduleSave, {passive:true, capture:true});
    document.addEventListener("change", scheduleSave, {passive:true, capture:true});
    document.addEventListener("click", scheduleSave, {passive:true, capture:true});

    // Backup-intervall (färre writes än 5s men samma säkerhet)
    setInterval(doSave, 30000);
  }catch(e){}
  // === Tävlingsform + kiosk-läge (v34) ===

  if(window.__LH_V34_INIT_DONE__) {
    // Init redan gjort – undvik dubbla event listeners
  } else {
    window.__LH_V34_INIT_DONE__ = true;

    try{
    // knappar import/kiosk
    var bI=document.getElementById('btnEntryImport');
    var bK=document.getElementById('btnEntryKiosk');
    if(bI) bI.addEventListener('click', function(){ setEntryMode('import'); });
    if(bK) bK.addEventListener('click', function(){ setEntryMode('kiosk'); });

    // spotify knappar
    var s1=document.getElementById('btnOpenSpotify');
    var s2=document.getElementById('btnOpenSpotify2');
    if(s1) s1.addEventListener('click', openSpotify);
    if(s2) s2.addEventListener('click', openSpotify);

    // spara
    var a1=document.getElementById('btnKioskAdd');
    var a2=document.getElementById('btnKioskAddTeam');
    if(a1) a1.addEventListener('click', kioskAddSingle);
    if(a2) a2.addEventListener('click', kioskAddTeam);
    // mode selector
    var ms=document.getElementById('mode');
    if(ms){
      ms.addEventListener('change', function(){
        state.mode = ms.value;
        if(state.mode!=='single' && state.mode!=='team') state.mode='single';
        applyEntryUI();
        var ks=document.getElementById('kioskStatus'); if(ks) ks.textContent='';
        saveState();
      });
    }
  }catch(e){}
  }

  applyEntryUI();
  setEntryMode(state.entryMode || 'import');

});


// Export/Import av hela turneringen (JSON)
// Export/Import av hela turneringen (JSON) – turneringsfil som är stabil mellan telefoner
// - Behåller legacyformat: hela state på toppnivå (players/matches m.m.)
// - Skickar med profilbilder (IndexedDB) i _avatars som dataURL per avatarKey
// - Rör INTE globala sparade profiler/historik (minskar risken för "fel info" och extra spelare)
function autosaveExportTournament(){
  (async ()=>{
    try{
      saveState(); // spara först

      // Legacy: hela state på toppnivå
      const payload = deepClone(state);
      if(!Array.isArray(payload.players)) payload.players = [];
      if(!Array.isArray(payload.matches)) payload.matches = [];

      payload._exportedAt = new Date().toISOString();
      payload._app = "turneringsapp";
      payload._format = "tournament_v9_state_plus_avatars";

      // Avatars: exportera som dataURL per "avatarKey" (samma nyckel som UI använder)
      payload._avatars = {};
      try{
        if(typeof _idbGet === "function" && typeof _blobToDataURL === "function"){
          for(const p of payload.players){
            if(!p) continue;
            const rawId = p.id || null;
            const rawName = p.name || "";
            const key = resolvePlayerId(rawId) || resolvePlayerId(rawName) || rawId;
            if(!key) continue;

            try{
              const rec = await _idbGet(String(key)); // {blob,mime,updatedAt}
              if(!rec || !rec.blob) continue;
              const url = await _blobToDataURL(rec.blob).catch(()=>null);
              if(url) payload._avatars[String(key)] = url;
            }catch(e){}
          }
        }
      }catch(e){}

      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = (payload && payload.tournamentName ? payload.tournamentName : ("turnering_" + payload.players.length + "spelare")) + ".json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} }, 2000);
    }catch(e){
      alert("Kunde inte exportera turneringen: " + (e && e.message ? e.message : e));
    }
  })();
}

function autosaveHandleImportJsonFile(file){
  if(!file) return;
  const name = (file.name||"").toLowerCase();
  if(!(name.endsWith(".json"))){
    alert("Välj en JSON-fil (.json) som exporterats från appen.");
    return;
  }
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const obj = JSON.parse(String(ev.target.result||""));
      if(!obj || typeof obj !== "object") throw new Error("Ogiltigt innehåll.");
      if(!Array.isArray(obj.players) || !Array.isArray(obj.matches)) throw new Error("Filen ser inte ut som en turnering.");

      // Normalisera/fyll på fält som kan saknas mellan versioner
      state = obj;
      if(!state.rules) state.rules = { game:"301", inRule:"single", outRule:"single", legsMode:"single" };
      if(!state.step) state.step = 1;
      if(!state.format) state.format = "round_robin";
      if(!state.repeats) state.repeats = 1;
      if(!state.numGroups){
        try{
          var keys = state.groups ? Object.keys(state.groups) : [];
          state.numGroups = (keys && keys.length >= 4) ? 4 : 2;
        }catch(e){
          state.numGroups = 2;
        }
      }
      if(!state.groups){
        state.groups = (state.numGroups===4) ? { A: [], B: [], C: [], D: [] } : { A: [], B: [] };
      }else{
        if(state.numGroups===4){
          if(!state.groups.C) state.groups.C = [];
          if(!state.groups.D) state.groups.D = [];
        }
      }
      if(!state.playoffs) state.playoffs = { started:false, matches: [] };
      if(!state.matches) state.matches = [];
      if(!state.players) state.players = [];

      // Vi kör alltid manuell spelarkälla i denna version
      state.playerSource = "manual";
      // Markera att en turnering precis importerats (för att kunna erbjuda "lägg till spelare i lista" på Spelare-sidan)
      try{
        state._importedTournament = true;
        // Säkerställ att importedPlayers finns för UI
        if(!Array.isArray(state.importedPlayers) || !state.importedPlayers.length){
          // Försök bygga från state.players (kan vara strängar eller objekt)
          try{
            const arr = Array.isArray(state.players) ? state.players : [];
            state.importedPlayers = arr.map(p=>{
              if(typeof p === "string") return { name: p };
              if(p && typeof p === "object") return { name: p.name||p.playerName||p.teamName||"", spotify: p.spotify||"", darts: p.darts||"" };
              return { name:"" };
            }).filter(p=> (p.name||"").trim().length>0);
          }catch(e){}
        }
      }catch(e){}


      // Återställ profilbilder om filen innehåller dem
      (async ()=>{
        try{
          const av = obj._avatars;
          if(av && typeof av === "object" && typeof _idbPut === "function"){
            const entries = Object.entries(av);
            for(const [key, dataUrl] of entries){
              if(!key || !dataUrl) continue;
              try{
                const res = await fetch(dataUrl);
                const blob = await res.blob();
                const mime = blob && blob.type ? blob.type : "image/jpeg";
                await _idbPut(String(key), { blob: blob, mime: mime, updatedAt: Date.now() }).catch(()=>null);
                try{ avatarCache[String(key)] = String(dataUrl); }catch(e){}
              }catch(e){}
            }
          }
          try{ hydrateAvatarsIn(document.body); }catch(e){}
        }catch(e){}
      })();

      saveState();
      renderAll();
      alert("Turnering importerad.");
    }catch(e){
      alert("Kunde inte importera: " + (e && e.message ? e.message : e));
    }
  };
  reader.readAsText(file);
}



// Backup (fil) – används som extra säkerhet på Android/content:// där lokal lagring kan rensas vid uppdatering
function downloadAutosaveBackup(){
  try{
    saveState();
    const payload = deepClone(state);
    payload._exportedAt = new Date().toISOString();
    payload._app = "turneringsapp";
    payload._kind = "backup";
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "turnering_autosave.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} }, 2000);
  }catch(e){
    alert("Kunde inte spara backup: " + (e && e.message ? e.message : e));
  }
}

function handleBackupImportFile(file){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const obj = JSON.parse(String(ev.target.result||""));
      if(!obj || typeof obj !== "object") throw new Error("Ogiltigt innehåll.");
      if(!Array.isArray(obj.players) || !Array.isArray(obj.matches)) throw new Error("Filen ser inte ut som en turnering.");

      state = obj;

      // Normalisera/fyll på fält som kan saknas mellan versioner
      if(!state.rules) state.rules = { game:"301", inRule:"single", outRule:"single", legsMode:"single" };
      if(!state.step) state.step = 1;
      if(!state.format) state.format = "round_robin";
      if(!state.repeats) state.repeats = 1;
      // Antal grupper (2 = standard, 4 = utökat)
      if(!state.numGroups){
        try{
          var keys = state.groups ? Object.keys(state.groups) : [];
          state.numGroups = (keys && keys.length >= 4) ? 4 : 2;
        }catch(e){
          state.numGroups = 2;
        }
      }
      if(!state.groups){
        state.groups = (state.numGroups===4) ? { A: [], B: [], C: [], D: [] } : { A: [], B: [] };
      }else{
        // Säkerställ att nycklar finns när man byter/öppnar äldre turneringar
        if(state.numGroups===4){
          if(!state.groups.C) state.groups.C = [];
          if(!state.groups.D) state.groups.D = [];
        }
      }
      if(!state.playoffs) state.playoffs = { started:false, matches: [] };
      if(!state.matches) state.matches = [];
      if(!state.players) state.players = [];

      // Vi kör alltid manuell spelarkälla i denna version
      state.playerSource = "manual";

      saveState();
      renderAll();
      alert("Backup återställd.");
    }catch(e){
      alert("Kunde inte återställa backup: " + (e && e.message ? e.message : e));
    }
  };
  reader.readAsText(file);
}


/* Datumstämplar (skärm + PDF) */
(function(){
  function formatDateLong(d){
    try{
      return d.toLocaleDateString('sv-SE', { year:'numeric', month:'long', day:'numeric' });
    }catch(e){
      // fallback
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${yyyy}-${mm}-${dd}`;
    }
  }
  function setText(id, text){
    const el = document.getElementById(id);
    if(el) el.textContent = text;
  }
  function applyDates(){
    const stamp = (typeof state !== 'undefined' && state && state.startedAt)
      ? `Start: ${formatDateTimeIso(state.startedAt)}`
      : '';

    setText('uiDateMatches', stamp);
    setText('uiDateTable', stamp);
    setText('uiDatePlayoffs', stamp);

    // PDF (datum visas bara uppe till höger)
    setText('printDate', stamp);
    // Turneringens namn högst upp
    const tName = (typeof state !== 'undefined' && state && state.tournamentName) ? state.tournamentName : "Turnering";
    setText('printTournamentName', tName);
  }
  window.applyDates = applyDates;

  // initial
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyDates);
  } else {
  if (window.applyDates) window.applyDates();
  }
  // ensure before print (some browsers re-evaluate DOM)
  window.addEventListener('beforeprint', applyDates);
})();


</script>
<!-- PRINT-ONLY: sammanställning för PDF -->
<div aria-hidden="true" id="printRoot">
<div class="print-header">
<div class="print-title" id="printTournamentName">Turnering</div>
<div class="print-meta"><span id="printDate"></span></div>
</div>
<section class="print-section">
<h1>Slutspel</h1>
<div id="print-finals-content"></div>
</section>
<section class="print-section">
<h1>Tabell</h1>
<div id="print-table-content"></div>
</section>
<section class="print-section page-break">
<h1>Matcher</h1>
<div id="print-matches-content"></div>
</section>
</div>
<!-- Anti pull-to-refresh + varning (nödlås) -->
<script id="antiPullToRefreshScript">
(function () {
  // Nödlås för att minska risken för "pull-to-refresh" på Android/Chrome
  // Viktigt: får INTE blockera klick på knappar (t.ex. "Nästa").
  // Därför blockerar vi endast en tydlig nedåtdrag-gest som startar på "tom yta"
  // och bara när man är längst upp på sidan.

  function ensureBanner() {
    let el = document.getElementById('ptrWarningBanner');
    if (el) return el;
    el = document.createElement('div');
    el.id = 'ptrWarningBanner';
    el.setAttribute('role', 'status');
    el.style.position = 'fixed';
    el.style.left = '12px';
    el.style.right = '12px';
    el.style.top = '10px';
    el.style.zIndex = '99999';
    el.style.padding = '10px 12px';
    el.style.borderRadius = '12px';
    el.style.boxShadow = '0 8px 20px rgba(0,0,0,.18)';
    el.style.background = 'rgba(20, 20, 20, .92)';
    el.style.color = '#fff';
    el.style.fontSize = '14px';
    el.style.display = 'none';
    el.style.alignItems = 'center';
    el.style.justifyContent = 'space-between';
    el.style.gap = '12px';
    el.style.pointerEvents = 'none'; // <-- aldrig blockera klick under bannern

    const msg = document.createElement('div');
    msg.textContent = 'Undvik att dra nedåt för att uppdatera. Använd Exportera för permanent backup.';
    msg.style.lineHeight = '1.2';

    el.appendChild(msg);
    document.body.appendChild(el);
    return el;
  }

  let lastWarnAt = 0;
  function maybeWarn() {
    const now = Date.now();
    if (now - lastWarnAt < 2000) return;
    lastWarnAt = now;
    const b = ensureBanner();
    b.style.display = 'flex';
    window.clearTimeout(b._hideT);
    b._hideT = window.setTimeout(() => { b.style.display = 'none'; }, 3000);
  }

  // CSS-hjälp: stoppa overscroll-bounce där det stöds
  try {
    document.documentElement.style.overscrollBehaviorY = 'none';
    document.body.style.overscrollBehaviorY = 'none';
  } catch (e) {}

  let startY = 0;
  let startX = 0;
  let startTargetIsInteractive = false;

  function isInteractiveTarget(t) {
    if (!t || !t.closest) return false;
    return !!t.closest('button, a, input, select, textarea, label, [role="button"]');
  }

  window.addEventListener('touchstart', function (e) {
    if (!e.touches || e.touches.length !== 1) return;
    startY = e.touches[0].clientY;
    startX = e.touches[0].clientX;
    startTargetIsInteractive = isInteractiveTarget(e.target);
  }, { passive: true });

  window.addEventListener('touchmove', function (e) {
    // Om gesten började på en knapp/input ska vi aldrig blockera (för att inte döda klick)
    if (startTargetIsInteractive) return;

    if (!e.touches || e.touches.length !== 1) return;

    const y = e.touches[0].clientY;
    const x = e.touches[0].clientX;
    const dy = y - startY;
    const dx = Math.abs(x - startX);

    // Bara när vi är längst upp
    const atTop = (window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0) <= 0;

    // Kräv en TYDLIG nedåtdrag-gest (stor tröskel så "tap + mikrorörelse" inte påverkas)
    // Samt begränsa sidled så vi inte stör andra gester.
    if (atTop && dy > 60 && dx < 30) {
      e.preventDefault(); // försök blockera refresh
      maybeWarn();
    }
  }, { passive: false });
})();
</script>
<script id="backButtonGuardScript">
(function () {
  function showPtrBanner() {
    const b = document.getElementById('ptrWarningBanner');
    if (!b) return;
    b.style.display = 'flex';
    window.clearTimeout(b._hideT);
    b._hideT = window.setTimeout(() => { b.style.display = 'none'; }, 3000);
  }

  function safeSaveAll() {
    // Försök spara allt som redan stöds av sidan.
    try { if (typeof saveState === 'function') saveState(); } catch (e) {}
    try { if (typeof autosaveTournament === 'function') autosaveTournament(); } catch (e) {}}

  // OBS: Det går inte att 100% garantera att bakåt aldrig lämnar sidan i alla mobillägen.
  // Därför: 1) blockera så långt webbläsaren tillåter, 2) autospara aggressivt vid varje "lämna"-signal.

  const LOCK_PREFIX = '#__stay__';
  const GUARD_DEPTH = 80;

  function setLockHash() {
    const next = LOCK_PREFIX + Date.now().toString(36);
    try { location.hash = next; } catch (e) {}
  }

  function pushGuards() {
    try {
      for (let i = 0; i < GUARD_DEPTH; i++) {
        history.pushState({ __backGuard: true, i }, '', location.href);
      }
    } catch (e) {}
  }

  function arm() {
    if (!location.hash || !location.hash.startsWith(LOCK_PREFIX)) setLockHash();
    pushGuards();
  }

  // Init
  arm();

  // Spara när sidan riskerar att lämnas / tappas ur minnet
  window.addEventListener('pagehide', safeSaveAll, { capture: true });
  window.addEventListener('beforeunload', safeSaveAll, { capture: true });
  document.addEventListener('visibilitychange', function () {
    if (document.hidden) safeSaveAll();
  }, { capture: true });

  // bfcache-retur
  window.addEventListener('pageshow', function () {
    safeSaveAll();
    arm();
  });

  // Back/forward
  window.addEventListener('popstate', function () {
    showPtrBanner();
    // Försök hoppa fram igen
    try { history.go(1); } catch (e) {}
    arm();
  });

  // Hash-bakåt (t.ex. när historiken annars hade lämnat sidan)
  window.addEventListener('hashchange', function () {
    if (!location.hash || !location.hash.startsWith(LOCK_PREFIX)) {
      safeSaveAll();
      showPtrBanner();
      arm();
    }
  });
})();
</script>
<!-- Back-overlay (visas när användaren försöker gå bakåt) -->
<style>
  
html, body { height: 100%; }
body { padding-bottom: 1px; }
#backGuardOverlay{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.92);
    color: #fff;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 999999;
    padding: 24px;
    text-align: center;
  }
  #backGuardOverlay .panel{
    max-width: 720px;
    width: 100%;
  }
  #backGuardOverlay .title{
    font-size: clamp(22px, 4vw, 34px);
    font-weight: 800;
    margin: 0 0 12px 0;
    line-height: 1.1;
  }
  #backGuardOverlay .msg{
    font-size: clamp(16px, 2.6vw, 22px);
    margin: 0 0 18px 0;
    line-height: 1.35;
  }
  #backGuardOverlay .hint{
    opacity: .9;
    font-size: clamp(14px, 2.2vw, 18px);
    margin: 0 0 22px 0;
    line-height: 1.35;
  }
  #backGuardOverlay .actions{
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }
  #backGuardOverlay button{
    appearance: none;
    border: 0;
    border-radius: 14px;
    padding: 14px 18px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
  }
  #backGuardOverlay .stay{
    background: #ffffff;
    color: #000000;
    min-width: 200px;
  }
  #backGuardOverlay .stay:active{ transform: scale(.99); }
  #backGuardOverlay .export{
    background: transparent;
    color: #ffffff;
    border: 2px solid #ffffff;
    min-width: 200px;
  }
  #backGuardOverlay .export:active{ transform: scale(.99); }
/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>
<div aria-labelledby="backGuardTitle" aria-modal="true" id="backGuardOverlay" role="dialog">
<div class="panel">
<h2 class="title" id="backGuardTitle">Du är på väg att gå bakåt</h2>
<p class="msg">Tryck inte på bakåt-knappen – då kan du förlora data.</p>
<p class="hint">Använd knapparna i sidan och <strong>Exportera</strong> för permanent backup.</p>
<div class="actions">
<button class="stay" id="backGuardStayBtn" type="button">Okej, jag stannar kvar</button>
<button class="export" id="backGuardExportBtn" type="button">Exportera nu</button>
</div>
</div>
</div>
<script>
(function () {
  // Visar pull-to-refresh-bannern (om den finns)
  function showPtrBanner() {
    const b = document.getElementById("ptrWarningBanner");
    if (!b) return;
    b.style.display = "flex";
    clearTimeout(b._hideTimer);
    b._hideTimer = setTimeout(() => { b.style.display = "none"; }, 3000);
  }

  // Visar vår stora svarta overlay
  const overlay = document.getElementById("backGuardOverlay");
  const stayBtn = document.getElementById("backGuardStayBtn");
  const exportBtn = document.getElementById("backGuardExportBtn");

  function showOverlay() {
    if (!overlay) return;
    overlay.style.display = "flex";
  }

  function hideOverlay() {
    if (!overlay) return;
    overlay.style.display = "none";
  }

  if (stayBtn) {
    stayBtn.addEventListener("click", function () {
      hideOverlay();
    });
  }

  if (exportBtn) {
    exportBtn.addEventListener("click", function () {
      // Stäng overlayn så att nedladdningsdialogen syns tydligt
      hideOverlay();

      // Anropa befintlig export-funktion om den finns
      if (typeof autosaveExportTournament === "function") {
        autosaveExportTournament();
      } else if (typeof exportTournament === "function") {
        exportTournament();
      } else if (typeof exportData === "function") {
        exportData();
      } else {
        // Fallback: visa PTR-banner som påminnelse
        showPtrBanner();
        alert("Hittade ingen export-funktion i sidan. Kontrollera att Exportera-knappen finns i Verktyg.");
      }
    });
  }


  // Försök att "hålla kvar" användaren när de trycker bakåt, och visa tydlig varning.
  // OBS: vissa mobil-lägen kan fortfarande lämna sidan direkt, men då hjälper overlayn inte.
  function armBackGuard() {
    // Lägg flera guard-steg, så snabb-dubbeltryck inte räcker.
    try {
      for (let i = 0; i < 8; i++) {
        history.pushState({ __backGuard: true, i }, "", location.href);
      }
    } catch (e) {}
  }

  armBackGuard();

  window.addEventListener("popstate", function () {
    // Visa både overlay och PTR-banner (samma visuella signal som du redan har)
    showOverlay();
    showPtrBanner();

    // Försök stanna kvar
    try { history.go(1); } catch (e) {}
    armBackGuard();
  });

  // Extra: vissa miljöer triggar hashchange snarare än popstate
  window.addEventListener("hashchange", function () {
    showOverlay();
    showPtrBanner();
    armBackGuard();
  });

  // Om sidan kommer tillbaka från bfcache, arma om
  window.addEventListener("pageshow", function (e) {
    if (e && e.persisted) {
      armBackGuard();
    }
  });
})();


// Auto-lägg till när man väljer i rullistan (Steg 5-justering)
function savedAutoAddFromSelect(kind){
  kind = (kind==="team") ? "team" : "single";
  var sel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
  if(!sel) return;
  var v = sel.value;
  if(v==null || v==="") return;
  // Kom ihåg senast valda så Ny/Ändra kan öppna rätt profil även om UI byggs om
  try{
    window.__savedLastSelected = window.__savedLastSelected || { single: '', team: '' };
    window.__savedLastSelected[kind] = String(v||'');
    // bakåtkompatibelt (om annan kod läser dessa)
    if(kind==="team") window.__lastSelectedTeamId = v; else window.__lastSelectedPlayerId = v;
  }catch(e){}
  // Återanvänd befintlig logik för snabb-lägg-till
  try{ savedQuickAdd(kind); }catch(e){}
  // OBS: vi nollställer INTE rullistan längre (behövs för att kunna redigera vald spelare)
}


// ===== Steg 3: Multi-väljare för sparade spelare (så rullistan inte stänger mellan val) =====
var __multiPickState = { open:false, kind:"single" };

function openSavedMultiPicker(kind){
  try{
    kind = (kind==="team") ? "team" : "single";
    __multiPickState.open = true;
    __multiPickState.kind = kind;

    var overlay = document.getElementById("overlayMultiPick");
    var listEl  = document.getElementById("multiPickList");
    if(!overlay || !listEl) return;

    var sel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    if(!sel){
      toast("Hittar inte rullistan.");
      return;
    }

    // Bygg lista från befintliga <option> (exkl. tom/disabled)
    listEl.innerHTML = "";
    var any = false;
    for(var i=0;i<sel.options.length;i++){
      var o = sel.options[i];
      if(!o) continue;
      var id = (o.value||"").trim();
      if(!id) continue;
      if(o.disabled) continue;

      any = true;
      var row = document.createElement("label");
      row.className = "multiPickItem";

      var cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = id;

      var textWrap = document.createElement("div");
      var nm = document.createElement("div");
      nm.className = "name";
      nm.textContent = o.textContent || id;
      textWrap.appendChild(nm);

      row.appendChild(cb);
      row.appendChild(textWrap);
      listEl.appendChild(row);
    }
    if(!any){
      var empty = document.createElement("div");
      empty.className = "small muted";
      empty.textContent = "Inga sparade spelare än. Lägg till en via Ny / Ändra.";
      listEl.appendChild(empty);
    }

    overlay.classList.remove("hidden");
    document.body.classList.add("modal-open");
  }catch(e){
    console.error(e);
  }
}

function closeSavedMultiPicker(apply){
  try{
    var overlay = document.getElementById("overlayMultiPick");
    if(!overlay) return;
    if(apply) applySavedMultiPicker();
    overlay.classList.add("hidden");
    document.body.classList.remove("modal-open");
    __multiPickState.open = false;
  }catch(e){
    console.error(e);
  }
}

function applySavedMultiPicker(){
  try{
    var kind = (__multiPickState && __multiPickState.kind==="team") ? "team" : "single";
    var listEl = document.getElementById("multiPickList");
    if(!listEl) return;
    var checks = listEl.querySelectorAll('input[type="checkbox"]');
    var ids = [];
    checks.forEach(function(cb){ if(cb && cb.checked && cb.value) ids.push(cb.value); });
    if(!ids.length) return;

    var sel = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    if(!sel) return;

    // Lägg till en i taget men utan att användaren behöver öppna listan igen
    ids.forEach(function(id){
      try{
        sel.value = id;
      }catch(e){}
      try{
        savedQuickAdd(kind);
      }catch(e){
        console.error(e);
      }
    });
    try{ sel.value = ""; }catch(e){}
  }catch(e){
    console.error(e);
  }
}

// ===== Steg 5: Modal / popup för Ny spelare =====
var __newPlayerModalState = { open:false, kind:null, movedEl:null, placeholder:null, prevHidden:null };

function refreshNewPlayerModalSelect(kindOverride){
  try{
    var kind = (kindOverride==="team") ? "team" : "single";
    if(!kindOverride){
      try{ kind = (__newPlayerModalState && __newPlayerModalState.kind==="team") ? "team" : "single"; }catch(e){}
    }
    var modalSel = document.getElementById(kind==="team" ? "modalSavedTeamSelect" : "modalSavedPlayerSelect");
    var mainSel  = document.getElementById(kind==="team" ? "savedTeamSelect" : "savedPlayerSelect");
    if(!modalSel || !mainSel) return;

    // Klona alternativen från huvudrullistan
    modalSel.innerHTML = "";
    for(var i=0;i<mainSel.options.length;i++){
      var o = mainSel.options[i];
      if(!o) continue;
      var c = document.createElement("option");
      c.value = o.value;
      c.textContent = o.textContent;
      if(o.disabled) c.disabled = true;
      modalSel.appendChild(c);
    }
    try{ modalSel.value = ""; }catch(e){}
  }catch(e){}
}



function selectModalSavedByName(kind, name){
  try{
    kind = (kind==="team") ? "team" : "single";
    name = (name||"").trim();
    if(!name) return;
    var sel = document.getElementById(kind==="team" ? "modalSavedTeamSelect" : "modalSavedPlayerSelect");
    if(!sel) return;
    // försök matcha mot option-text (namn)
    var targetVal = null;
    for(var i=0;i<sel.options.length;i++){
      var o = sel.options[i];
      if(!o) continue;
      if(((o.textContent||"").trim().toLowerCase()) === name.toLowerCase()){
        targetVal = o.value;
        break;
      }
    }
    if(targetVal!=null){ sel.value = targetVal; }
  }catch(e){}
}
// Kom ihåg senast valda sparade profil så att Ny/Ändra kan redigera även om rullistan nollställs efter snabb-lägg-till
window.__savedLastSelected = window.__savedLastSelected || { single: '', team: '' };

function openNewPlayerModal(kind){
  kind = (kind==="team") ? "team" : "single";
  var overlay = document.getElementById("newPlayerModal");
  var body = document.getElementById("newPlayerModalBody");
  var title = document.getElementById("newPlayerModalTitle");
  if(!overlay || !body) return;

  // 1) Avgör om vi ska redigera en befintlig profil (vald i rullistan) eller skapa ny
  var selectedId = "";
  try{
    if(kind==="team"){
      var selT = document.getElementById("savedTeamSelect");
      selectedId = (selT && selT.value) ? String(selT.value) : "";
    }else{
      var selP = document.getElementById("savedPlayerSelect");
      selectedId = (selP && selP.value) ? String(selP.value) : "";
    }
  }catch(e){ selectedId = ""; }
  if(!selectedId){ try{ selectedId = (window.__savedLastSelected && window.__savedLastSelected[kind]) ? String(window.__savedLastSelected[kind]) : ""; }catch(e){} }
  var isEdit = !!selectedId;

  // 2) Flytta rätt formulär in i modalen (utan att duplicera ID:n)
  var formId = (kind==="team") ? "kioskTeamFields" : "kioskSingleFields";
  var formEl = document.getElementById(formId);
  if(!formEl) return;

  var ph = document.createComment("modal-placeholder");
  formEl.parentNode.insertBefore(ph, formEl);
  var prevHidden = formEl.classList.contains("hidden");
  if(prevHidden) formEl.classList.remove("hidden");

  // 3) Sätt rubrik
  title.textContent = (kind==="team") ? (isEdit ? "Ändra lag" : "Ny lag") : (isEdit ? "Ändra spelare" : "Ny spelare");

  // 4) Se till att vi har ett stabilt id (viktigt för profilbild)
  try{
    window.__modalAvatarPid = window.__modalAvatarPid || { single:null, team:null };
    if(isEdit){
      if(kind==="team") savedEditingTeamId = selectedId; else savedEditingPlayerId = selectedId;
      window.__modalAvatarPid[kind] = selectedId;
    }else{
      // Ny profil: skapa id direkt så att profilbild kan sparas innan man trycker Spara.
      var nid = null;
      try{ nid = cryptoId(); }catch(e){ nid = ("p_"+Date.now()+"_"+Math.random().toString(16).slice(2)); }
      if(kind==="team") savedEditingTeamId = nid; else savedEditingPlayerId = nid;
      window.__modalAvatarPid[kind] = nid;
    }
  }catch(e){}


  // 4.5) Rullista i modalen: välj vilken sparad profil som ska redigeras
  // Detta löser fallet där man vill byta profil *inne i* Ny/Ändra utan att behöva stänga modalen.
  // (Elementet skapas dynamiskt så vi inte behöver hårdkoda mer HTML.)
  var selectRow = null;
  try{
    selectRow = document.createElement("div");
    selectRow.className = "card";
    selectRow.style.cssText = "box-shadow:none;border:1px solid #eef1f6;margin:0 0 10px 0";

    var lbl = document.createElement("div");
    lbl.style.fontWeight = "700";
    lbl.textContent = (kind === "team") ? "Välj sparat lag att ändra" : "Välj sparad spelare att ändra";

    var sub = document.createElement("div");
    sub.className = "small muted";
    sub.textContent = "Välj en profil här för att öppna den i formuläret. Välj tomt för att skapa en ny.";

    var sel = document.createElement("select");
    sel.id = (kind === "team") ? "modalSavedTeamSelect" : "modalSavedPlayerSelect";
    sel.style.cssText = "width:100%;margin-top:8px";

    // Bygg alternativen från sparade profiler (robust – oberoende av UI-timing)
    try{
      sel.innerHTML = "";

      // Tomt val = "skapa ny"
      var emptyOpt = document.createElement("option");
      emptyOpt.value = "";
      emptyOpt.textContent = "— Ny profil —";
      sel.appendChild(emptyOpt);

      var key = (kind === "team") ? SAVED_TEAMS_KEY : SAVED_PLAYERS_KEY;
      var list = _loadSaved(key) || [];
      list.sort(function(a,b){
        var an = (kind === "team" ? (a.teamName||a.name||"") : (a.name||"")).toLowerCase();
        var bn = (kind === "team" ? (b.teamName||b.name||"") : (b.name||"")).toLowerCase();
        if(an<bn) return -1;
        if(an>bn) return 1;
        return 0;
      });

      for(var i=0;i<list.length;i++){
        var it = list[i];
        if(!it) continue;
        var id = (it.id||"").trim();
        if(!id) continue;
        var label = (kind === "team") ? (it.teamName||it.name||id) : (it.name||id);
        var c = document.createElement("option");
        c.value = id;
        c.textContent = label;
        sel.appendChild(c);
      }
    }catch(e){}


    // Förval
    try{ sel.value = selectedId || ""; }catch(e){}

    sel.addEventListener("change", function(){
      try{
        var v = (sel.value||"").trim();
        // Synka huvudrullistan så resten av logiken fortsätter fungera.
        var mainSel = document.getElementById(kind === "team" ? "savedTeamSelect" : "savedPlayerSelect");
        if(mainSel) mainSel.value = v;
        try{
          window.__savedLastSelected = window.__savedLastSelected || { single: "", team: "" };
          window.__savedLastSelected[kind] = v;
        }catch(e){}
        // Byt läge genom att stänga och öppna om modalen (återanvänder befintlig, testad fyll-logik).
        closeNewPlayerModal();
        setTimeout(function(){
          try{ openNewPlayerModal(kind); }catch(e){}
        }, 0);
      }catch(e){}
    });

    selectRow.appendChild(lbl);
    selectRow.appendChild(sub);
    selectRow.appendChild(sel);
  }catch(e){ selectRow = null; }

  // 5) Profilbild-rad
  var avatarRow = document.createElement("div");
  avatarRow.className = "row";
  avatarRow.style.cssText = "justify-content:flex-start;align-items:center;gap:12px;margin:8px 0 10px 0";

  var avatarBtn = document.createElement("button");
  avatarBtn.type = "button";
  avatarBtn.className = "avatarBtn";
  avatarBtn.id = (kind==="team") ? "modalAvatarBtnTeam" : "modalAvatarBtnSingle";
  avatarRow.id = (kind==="team") ? "modalAvatarRowTeam" : "modalAvatarRowSingle";
  avatarBtn.setAttribute("data-avatar-pid", (window.__modalAvatarPid && window.__modalAvatarPid[kind]) ? window.__modalAvatarPid[kind] : "");
  avatarBtn.setAttribute("data-avatar-name", "");
  avatarBtn.innerHTML = "<span></span><img alt='' style='display:none'>";


  // Välj profilbild direkt via filväljare (funkar bättre på Android än extra modal)
  var fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'image/*';
  fileInput.style.display = 'none';
  fileInput.id = (kind==='team') ? 'modalAvatarFileTeam' : 'modalAvatarFileSingle';

  avatarBtn.addEventListener('click', function(){
    try{ fileInput.click(); }catch(e){}
  });

  fileInput.addEventListener('change', function(){
    try{
      var f = (fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
      if(!f) return;
      var pid = null;
      try{ pid = (window.__modalAvatarPid && window.__modalAvatarPid[kind]) ? window.__modalAvatarPid[kind] : null; }catch(e){}
      if(!pid){
        try{ pid = cryptoId(); }catch(e){ pid = ('p_'+Date.now()+'_'+Math.random().toString(16).slice(2)); }
        try{ if(kind==='team') savedEditingTeamId = pid; else savedEditingPlayerId = pid; }catch(e){}
        try{ window.__modalAvatarPid[kind] = pid; }catch(e){}
      }
      avatarBtn.setAttribute('data-avatar-pid', pid||'');

      var r = new FileReader();
      r.onload = function(){
        var dataUrl = String(r.result||'');
        if(!dataUrl) return;
        // Spara i cache + IndexedDB (med localStorage fallback)
        setAvatarDataUrl(pid, dataUrl).finally(function(){
          try{ hydrateAvatarsIn(avatarRow); }catch(e){}
        });
      };
      r.readAsDataURL(f);
    }catch(e){}
  });

  // Visa avatar-knapp + enkel text
  var avatarText = document.createElement('div');
  avatarText.style.display='flex';
  avatarText.style.flexDirection='column';
  avatarText.style.gap='2px';
  var avatarH = document.createElement('div');
  avatarH.style.fontWeight='700';
  avatarH.textContent='Profilbild';
  var avatarP = document.createElement('div');
  avatarP.className='small muted';
  avatarP.textContent='Tryck på avataren för att välja/ändra bild';
  avatarText.appendChild(avatarH);
  avatarText.appendChild(avatarP);

  avatarRow.appendChild(avatarBtn);
  avatarRow.appendChild(avatarText);
  avatarRow.appendChild(fileInput);

  fileInput.addEventListener('change', function(){
    try{
      var f = (fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
      if(!f) return;
      var pid = null;
      try{ pid = (window.__modalAvatarPid && window.__modalAvatarPid[kind]) ? window.__modalAvatarPid[kind] : null; }catch(e){}
      if(!pid) return;
      var r = new FileReader();
      r.onload = function(){
        try{ _setAvatarFromDataURL(pid, r.result); }catch(e){}
      };
      r.readAsDataURL(f);
      // reset så samma fil kan väljas igen
      try{ fileInput.value = ''; }catch(e){}
    }catch(e){}
  });

  // 6) Bygg modal
  body.innerHTML = "";
  try{ if(selectRow) body.appendChild(selectRow); }catch(e){}
  try{ body.appendChild(avatarRow); }catch(e){}
  body.appendChild(formEl);

  // 7) Fyll formulär beroende på edit/ny
  try{
    if(kind==="team"){
      var listT = _loadSaved(SAVED_TEAMS_KEY) || [];
      var recT = isEdit ? listT.find(function(x){ return x && String(x.id)===String(selectedId); }) : null;
      if(recT){
        document.getElementById("kTeamName").value = recT.teamName || "";
        document.getElementById("kTeamP1").value = (recT.members && recT.members[0]) ? recT.members[0] : "";
        document.getElementById("kTeamP2").value = (recT.members && recT.members[1]) ? recT.members[1] : "";
        document.getElementById("kTeamSpotify").value = recT.spotify || "";
        document.getElementById("kTeamDarts").value = recT.darts || "";
        savedEditingTeamOriginalName = recT.teamName || null;
      }else{
        document.getElementById("kTeamName").value = "";
        document.getElementById("kTeamP1").value = "";
        document.getElementById("kTeamP2").value = "";
        document.getElementById("kTeamSpotify").value = "";
        document.getElementById("kTeamDarts").value = "";
        savedEditingTeamOriginalName = null;
      }
      try{ document.getElementById("kTeamName").focus(); }catch(e){}
    }else{
      var listP = _loadSaved(SAVED_PLAYERS_KEY) || [];
      var recP = isEdit ? listP.find(function(x){ return x && String(x.id)===String(selectedId); }) : null;
      if(recP){
        document.getElementById("kName").value = recP.name || "";
        document.getElementById("kSpotify").value = recP.spotify || "";
        document.getElementById("kDarts").value = recP.darts || "";
        savedEditingPlayerOriginalName = recP.name || null;
      }else{
        document.getElementById("kName").value = "";
        document.getElementById("kSpotify").value = "";
        document.getElementById("kDarts").value = "";
        savedEditingPlayerOriginalName = null;
      }
      try{ document.getElementById("kName").focus(); }catch(e){}
    }
  }catch(e){}

  // 8) Uppdatera avatar-knappen (initialer/bild)
  try{
    var nm0 = (kind==="team" ? (document.getElementById("kTeamName")?document.getElementById("kTeamName").value:"") : (document.getElementById("kName")?document.getElementById("kName").value:""));
    nm0 = (nm0||"").trim();
    avatarBtn.setAttribute("data-avatar-name", nm0);
    var spn = avatarBtn.querySelector("span"); if(spn) spn.textContent = _avatarInitials(nm0||"") || "?";
    hydrateAvatarsIn(avatarRow);
  }catch(e){}

  // 9) Visa modal
  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden","false");
  __newPlayerModalState = { open:true, kind:kind, movedEl:formEl, placeholder:ph, prevHidden:prevHidden };

  overlay.onclick = function(ev){
    if(ev.target === overlay){ closeNewPlayerModal(); }
  };
  document.onkeydown = function(ev){
    if(ev.key === "Escape"){ closeNewPlayerModal(); }
  };
}

function openEditPlayerModal(kind){
  kind = (kind==="team") ? "team" : "single";
  var overlay = document.getElementById("newPlayerModal");
  var body = document.getElementById("newPlayerModalBody");
  var title = document.getElementById("newPlayerModalTitle");
  if(!overlay || !body) return;

  var formId = (kind==="team") ? "kioskTeamFields" : "kioskSingleFields";
  var formEl = document.getElementById(formId);
  if(!formEl) return;

  var ph = document.createComment("modal-placeholder");
  formEl.parentNode.insertBefore(ph, formEl);

  var prevHidden = formEl.classList.contains("hidden");
  if(prevHidden) formEl.classList.remove("hidden");

  title.textContent = (kind==="team") ? "Redigera lag" : "Redigera spelare";

  body.innerHTML = "";
  body.appendChild(formEl);

  // Fokusera ett rimligt fält, men rensa inte (det är "Ladda"-läget)
  try{
    if(kind==="team"){
      try{ document.getElementById("kTeamName").focus(); }catch(e){}
    }else{
      try{ document.getElementById("kName").focus(); }catch(e){}
    }
  }catch(e){}

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden","false");

  __newPlayerModalState = { open:true, kind:kind, movedEl:formEl, placeholder:ph, prevHidden:prevHidden };

  overlay.onclick = function(ev){
    if(ev.target === overlay){ closeNewPlayerModal(); }
  };
  document.onkeydown = function(ev){
    if(ev.key === "Escape"){ closeNewPlayerModal(); }
  };
}

function closeNewPlayerModal(){
  try{ window.__fromPlayerRegisterPopup = false; }catch(e){}
  var overlay = document.getElementById("newPlayerModal");
  if(!overlay) return;
  if(!__newPlayerModalState.open) { overlay.classList.add("hidden"); overlay.setAttribute("aria-hidden","true"); return; }

  var formEl = __newPlayerModalState.movedEl;
  var ph = __newPlayerModalState.placeholder;

  try{
    if(ph && ph.parentNode && formEl){
      ph.parentNode.insertBefore(formEl, ph);
      ph.parentNode.removeChild(ph);
    }
    if(formEl && __newPlayerModalState.prevHidden){
      formEl.classList.add("hidden");
    }

  // Parkera "Ta bort vald profil"-knappen utanför vyn (den ska bara synas i modalen)
  try{
    var delPh = (typeof __newPlayerModalState_deletePlaceholder!=="undefined") ? __newPlayerModalState_deletePlaceholder : null;
    if(delPh){
      var delBtn1 = document.getElementById("btnDeleteProfileTop");
      var delBtn2 = document.getElementById("btnDeleteTeamTop");
      var parking = document.getElementById("modalButtonParking");
      if(parking){
        if(delBtn1) parking.appendChild(delBtn1);
        if(delBtn2) parking.appendChild(delBtn2);
      }
      if(delPh.parentNode){ delPh.parentNode.removeChild(delPh); }
    }
    __newPlayerModalState_deletePlaceholder = null;
  }catch(e){}
  }catch(e){}

  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden","true");
  __newPlayerModalState = { open:false, kind:null, movedEl:null, placeholder:null, prevHidden:null };
  try{
    if(window.__reopenPlayerRegisterAfterNewPlayer){
      window.__reopenPlayerRegisterAfterNewPlayer = false;
      if(typeof openPlayerRegisterPopup==="function"){ openPlayerRegisterPopup(); }
    }
  }catch(e){};
}

// Wrapper: spara profil och stäng popupen om det lyckas
function modalSavedSaveNewFromForm(kind){
  try{
    var ok = savedSaveNewFromForm(kind);
    if(ok){ closeNewPlayerModal(); }
  }catch(e){}
}

// Wrapper: lägg till spelare/lag och stäng popupen om det lyckas
function modalKioskAddSingle(){
  try{
    // Om vi använder modalen från Turneringar-popuppen vill vi bara spara profilen (inte lägga till i aktuell turnering)
    if(window.__fromPlayerRegisterPopup){
      var okP = false;
      try{ okP = savedSaveNewFromForm('single'); }catch(e){ okP=false; }
      if(okP){
        try{ window.__fromPlayerRegisterPopup=false; }catch(e){}
        try{ closeNewPlayerModal(); }catch(e){}
        try{ renderPlayerRegisterPopup(); }catch(e){}
      }
      return;
    }

    var nm = (document.getElementById('kName') ? (document.getElementById('kName').value||'').trim() : '');
    // Om vi har laddat en sparad profil i modalen: uppdatera profilen istället för att försöka lägga till igen
    if(savedEditingPlayerId){
      var oldNm = savedEditingPlayerOriginalName || nm;
      var sp = (document.getElementById('kSpotify') ? (document.getElementById('kSpotify').value||'').trim() : '');
      var da = (document.getElementById('kDarts') ? (document.getElementById('kDarts').value||'').trim() : '');
      var okU = savedUpsertFromForm('single');
      if(okU){
        // Uppdatera ev. redan tillagda rader
        try{ _updateAddedSingleLines(oldNm, nm, sp, da); }catch(e){}
        savedEditingPlayerOriginalName = nm;
        // Synka modalens dropdown och avatar-koppling
        try{ refreshNewPlayerModalSelect(); }catch(e){}
        try{ selectModalSavedByName('single', nm); }catch(e){}
        try{
          window.__modalAvatarPid.single = savedEditingPlayerId;
          var btn = document.getElementById('modalAvatarBtnSingle');
          if(btn){ btn.setAttribute('data-avatar-pid', savedEditingPlayerId||''); btn.setAttribute('data-avatar-name', nm||''); hydrateAvatarsIn(btn); }
        }catch(e){}
        // Stäng modalen när uppdateringen lyckas
        try{ closeNewPlayerModal(); }catch(e){}
      }
      return;
    }

    // Annars: normalflöde = spara + lägg till i turneringen
    var ok = kioskAddSingle();
    if(ok){
      try{ refreshNewPlayerModalSelect(); }catch(e){}
      try{ selectModalSavedByName('single', nm); }catch(e){}
      try{
        var pidSaved = (typeof findSavedPlayerIdByName==="function") ? findSavedPlayerIdByName(nm, "single") : null;
        if(pidSaved){ window.__modalAvatarPid.single = pidSaved; }
        var btn = document.getElementById("modalAvatarBtnSingle");
        if(btn){
          btn.setAttribute("data-avatar-pid", (window.__modalAvatarPid.single||""));
          btn.setAttribute("data-avatar-name", nm||"");
          try{ hydrateAvatarsIn(btn); }catch(e){}
        }
      }catch(e){}
    }
  }catch(e){}
}
function modalKioskAddTeam(){
  try{
    var nm = (document.getElementById('kTeamName') ? (document.getElementById('kTeamName').value||'').trim() : '');

    // Uppdateringsläge för lag (laddad profil)
    if(savedEditingTeamId){
      var oldNm = savedEditingTeamOriginalName || nm;
      var p1 = (document.getElementById('kTeamP1') ? (document.getElementById('kTeamP1').value||'').trim() : '');
      var p2 = (document.getElementById('kTeamP2') ? (document.getElementById('kTeamP2').value||'').trim() : '');
      var sp = (document.getElementById('kTeamSpotify') ? (document.getElementById('kTeamSpotify').value||'').trim() : '');
      var da = (document.getElementById('kTeamDarts') ? (document.getElementById('kTeamDarts').value||'').trim() : '');
      var okU = savedUpsertFromForm('team');
      if(okU){
        try{ _updateAddedTeamLines(oldNm, nm, p1, p2, sp, da); }catch(e){}
        savedEditingTeamOriginalName = nm;
        try{ refreshNewPlayerModalSelect(); }catch(e){}
        try{ selectModalSavedByName('team', nm); }catch(e){}
        try{
          window.__modalAvatarPid.team = savedEditingTeamId;
          var btn = document.getElementById('modalAvatarBtnTeam');
          if(btn){ btn.setAttribute('data-avatar-pid', savedEditingTeamId||''); btn.setAttribute('data-avatar-name', nm||''); hydrateAvatarsIn(btn); }
        }catch(e){}
        try{ closeNewPlayerModal(); }catch(e){}
      }
      return;
    }

    var ok = kioskAddTeam();
    if(ok){
      try{ refreshNewPlayerModalSelect(); }catch(e){}
      try{ selectModalSavedByName('team', nm); }catch(e){}
      try{
        var pidSaved = (typeof findSavedPlayerIdByName==="function") ? findSavedPlayerIdByName(nm, "team") : null;
        if(pidSaved){ window.__modalAvatarPid.team = pidSaved; }
        var btn = document.getElementById("modalAvatarBtnTeam");
        if(btn){
          btn.setAttribute("data-avatar-pid", (window.__modalAvatarPid.team||""));
          btn.setAttribute("data-avatar-name", nm||"");
          try{ hydrateAvatarsIn(btn); }catch(e){}
        }
      }catch(e){}
    }
  }catch(e){}
}

// Öppnar "Ny / Ändra" beroende på om en spelare är vald i en select.
// selectId är valfri: default är "savedPlayerSelect" (Spelare-fliken).
function openNewOrEditPlayerModal(kind, selectId){
  try{
    kind = (kind === "team") ? "team" : "single";

    // Hitta rätt select (huvudvyn) och kom ihåg valet.
    var fallbackId = (kind === "team") ? "savedTeamSelect" : "savedPlayerSelect";
    var sel = document.getElementById(selectId || fallbackId);
    var pid = (sel && sel.value) ? String(sel.value).trim() : "";
    try{
      window.__savedLastSelected = window.__savedLastSelected || { single: "", team: "" };
      if(pid) window.__savedLastSelected[kind] = pid;
    }catch(e){}

    // Öppna samma modal oavsett (den avgör själv Ny vs Ändra utifrån valt id)
    openNewPlayerModal(kind);
  }catch(e){
    // Om något går fel, fall back till "ny"
    try{ openNewPlayerModal((kind === "team") ? "team" : "single"); }catch(_e){}
  }
}


// Se till att "Ta bort vald profil" inte ligger i huvudvyn (den hanteras i modalen)
document.addEventListener("DOMContentLoaded", function(){
  try{
    var parking = document.getElementById("modalButtonParking");
    if(!parking) return;
    var b1 = document.getElementById("btnDeleteProfileTop");
    var b2 = document.getElementById("btnDeleteTeamTop");
    if(b1) parking.appendChild(b1);
    if(b2) parking.appendChild(b2);
  }catch(e){}
});

// Fallback: enkel toast om den inte redan finns
if(typeof window.toast !== "function"){
  window.toast = function(msg){
    try{
      var el = document.getElementById("___toast");
      if(!el){
        el = document.createElement("div");
        el.id = "___toast";
        el.style.position = "fixed";
        el.style.left = "50%";
        el.style.bottom = "18px";
        el.style.transform = "translateX(-50%)";
        el.style.background = "rgba(17,24,39,0.92)";
        el.style.color = "#fff";
        el.style.padding = "10px 12px";
        el.style.borderRadius = "12px";
        el.style.fontSize = "14px";
        el.style.zIndex = "999999";
        el.style.maxWidth = "92vw";
        el.style.textAlign = "center";
        el.style.boxShadow = "0 10px 30px rgba(0,0,0,0.25)";
        el.style.opacity = "0";
        el.style.pointerEvents = "none";
        document.body.appendChild(el);
      }
      el.textContent = msg;
      el.style.transition = "opacity 120ms ease";
      el.style.opacity = "1";
      clearTimeout(window.___toastT);
      window.___toastT = setTimeout(function(){ el.style.opacity = "0"; }, 1600);
    }catch(e){
      alert(msg);
    }
  };
}


// ---- Avatars (profilbilder): IndexedDB store 'avatars' keyed by playerId ----
const AVATAR_DB_NAME = "dart_avatars_db_v1";
const AVATAR_STORE = "avatars";
const avatarCache = {}; // playerId -> dataURL

let __avatar = {
  open:false,
  playerId:null,
  playerName:"",
  img:null,
  zoom:1,
  offsetX:0,
  offsetY:0,
  dragging:false,
  dragStartX:0,
  dragStartY:0,
  baseOffsetX:0,
  baseOffsetY:0
};
// Håller koll på vilket playerId som avatar-modalen ska kopplas till i "Ny / Ändra"-modalen.
// Viktigt: savedEditingPlayerId nollställs efter Spara, så vi behöver en separat källa för avatar-kopplingen.
window.__modalAvatarPid = window.__modalAvatarPid || { single:null, team:null };


function avatarOverlayClick(e){
  // stäng vid klick utanför
  closeAvatarModal();
}

function _avatarInitials(name){
  name = (name||"").trim();
  if(!name) return "?";
  const parts = name.split(/\s+/).filter(Boolean);
  const a = (parts[0]||"").charAt(0).toUpperCase();
  const b = (parts.length>1 ? (parts[parts.length-1]||"").charAt(0).toUpperCase() : "");
  return (a + b) || a || "?";
}

function _avatarBtnHtml(pid, name){
  pid = (pid==null? "" : String(pid));
  name = (name==null? "" : String(name));
  const init = _avatarInitials(name) || "?";
  return "<button class='avatarBtn small' type='button'"
    + " data-avatar-pid='" + escapeAttr(pid) + "'"
    + " data-avatar-name='" + escapeAttr(name) + "'"
    + " onclick=\"openAvatarModalResolved('" + escapeJs(pid) + "', '" + escapeJs(name) + "')\">"
    + "<span class='avatarInitials'>" + escapeHtml(init) + "</span>"
    + "<img alt='' style='display:none'>"
    + "</button>";
}


function _avatarBtnViewHtml(pid, name, sizeClass){
  // Read-only avatar for matches (shows profile picture / initials but never opens picker)
  pid = (pid==null? "" : String(pid));
  name = (name==null? "" : String(name));
  sizeClass = sizeClass || "small";
  const init = _avatarInitials(name) || "?";
  return "<div class='avatarBtn " + escapeAttr(sizeClass) + " avatarReadOnly'"
    + " data-avatar-pid='" + escapeAttr(pid) + "'"
    + " data-avatar-name='" + escapeAttr(name) + "'>"
    + "<span class='avatarInitials'>" + escapeHtml(init) + "</span>"
    + "<img alt='' style='display:none'>"
    + "</div>";
}


function _findSavedPlayerByName(name){
  const list = _loadSaved(SAVED_PLAYERS_KEY);
  const low = (name||"").trim().toLowerCase();
  return list.find(p => ((p.name||"").trim().toLowerCase()===low)) || null;
}
function _findSavedTeamByName(name){
  const list = _loadSaved(SAVED_TEAMS_KEY);
  const low = (name||"").trim().toLowerCase();
  return list.find(p => ((p.teamName||"").trim().toLowerCase()===low)) || null;
}

function _avatarPlayerIdFromAddedTitle(title){
  // För "Tillagda"-listan (som har namn): mappa via sparade profiler om möjligt
  if(state.mode==='team'){
    const t=_findSavedTeamByName(title);
    return t ? t.id : null;
  }else{
    const p=_findSavedPlayerByName(title);
    return p ? p.id : null;
  }
}

function _idbOpen(){
  return new Promise((resolve,reject)=>{
    try{
      const req = indexedDB.open(AVATAR_DB_NAME, 1);
      req.onupgradeneeded = function(ev){
        const db = req.result;
        if(!db.objectStoreNames.contains(AVATAR_STORE)){
          db.createObjectStore(AVATAR_STORE);
        }
      };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error || new Error("IndexedDB error"));
    }catch(e){ reject(e); }
  });
}
function _idbGet(playerId){
  return _idbOpen().then(db=>{
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(AVATAR_STORE, "readonly");
        const st = tx.objectStore(AVATAR_STORE);
        const rq = st.get(playerId);
        rq.onsuccess = ()=>resolve(rq.result || null);
        rq.onerror = ()=>reject(rq.error);
      }catch(e){ reject(e); }
    });
  });
}
function _idbPut(playerId, record){
  return _idbOpen().then(db=>{
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(AVATAR_STORE, "readwrite");
        const st = tx.objectStore(AVATAR_STORE);
        st.put(record, playerId);
        tx.oncomplete = ()=>resolve(true);
        tx.onerror = ()=>reject(tx.error);
      }catch(e){ reject(e); }
    });
  });
}
function _idbDel(playerId){
  return _idbOpen().then(db=>{
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(AVATAR_STORE, "readwrite");
        const st = tx.objectStore(AVATAR_STORE);
        st.delete(playerId);
        tx.oncomplete = ()=>resolve(true);
        tx.onerror = ()=>reject(tx.error);
      }catch(e){ reject(e); }
    });
  });
}

function _blobToDataURL(blob){
  return new Promise((resolve,reject)=>{
    try{
      const r = new FileReader();
      r.onload = ()=>resolve(r.result);
      r.onerror = ()=>reject(r.error);
      r.readAsDataURL(blob);
    }catch(e){ reject(e); }
  });
}



function _dataURLToBlob(dataURL){
  try{
    const parts = String(dataURL||'').split(',');
    if(parts.length<2) return null;
    const meta = parts[0];
    const b64 = parts[1];
    const m = /data:([^;]+);base64/.exec(meta);
    const mime = m ? m[1] : 'image/png';
    const bin = atob(b64);
    const len = bin.length;
    const arr = new Uint8Array(len);
    for(let i=0;i<len;i++) arr[i]=bin.charCodeAt(i);
    return new Blob([arr], {type:mime});
  }catch(e){ return null; }
}

async function _setAvatarFromDataURL(playerId, dataURL){
  try{
    if(!playerId || !dataURL) return false;
    playerId = String(playerId);
    avatarCache[playerId] = String(dataURL);
    const blob = _dataURLToBlob(dataURL);
    if(blob){
      await _idbPut(playerId, { blob: blob, ts: Date.now() });
    }
    // uppdatera alla avatar-knappar i DOM
    try{ hydrateAvatarsIn(document); }catch(e){}
    return true;
  }catch(e){ return false; }
}
function resolvePlayerId(anyIdOrName){
  // Return the best avatar key (playerId) for a reference that may be:
  // - a saved profile id
  // - a tournament/runtime id
  // - a player name
  //
  // We *prefer* saved profile ids (because avatars are stored per saved profile).
  if(!anyIdOrName) return null;

  // Helper: find saved profile id by id or name (single/team)
  function _findSavedId(ref){
    try{
      const sp = (typeof loadSavedProfiles==="function") ? loadSavedProfiles() : null;
      if(sp && Array.isArray(sp.single)){
        for(const p of sp.single){
          if(p && (p.id===ref || p.name===ref)) return p.id || null;
        }
      }
      if(sp && Array.isArray(sp.team)){
        for(const p of sp.team){
          if(p && (p.id===ref || p.name===ref)) return p.id || null;
        }
      }
    }catch(e){}
    return null;
  }

  // 1) If it's already a saved id or matches a saved profile by name, use that.
  const savedHit = _findSavedId(anyIdOrName);
  if(savedHit) return savedHit;

  // 2) If it's a runtime/tournament id, try to map via the runtime player's name -> saved profile id.
  try{
    if(state && Array.isArray(state.players)){
      const runtime = state.players.find(p=>p && p.id===anyIdOrName);
      if(runtime && runtime.name){
        const byName = _findSavedId(runtime.name);
        if(byName) return byName;
        // No saved profile match, fallback to runtime id
        return runtime.id;
      }
    }
  }catch(e){}

  // 3) If it's a name, try runtime players by name (fallback)
  try{
    if(state && Array.isArray(state.players)){
      const runtimeByName = state.players.find(p=>p && p.name===anyIdOrName);
      if(runtimeByName) return runtimeByName.id;
    }
  }catch(e){}

  return null;
}

// Backwards-compat: vissa delar av koden använder camelCase-versionen.
// Den här wrappern gör att avatarval fungerar i både popupen och i spelare-fliken.
function setAvatarDataUrl(playerId, dataUrl){
  return _setAvatarFromDataURL(playerId, dataUrl);
}

function getAvatarDataURL(playerId){
  if(!playerId) return Promise.resolve(null);
  if(avatarCache[playerId]) return Promise.resolve(avatarCache[playerId]);
  return _idbGet(playerId).then(rec=>{
    if(!rec || !rec.blob) return null;
    return _blobToDataURL(rec.blob).then(url=>{
      avatarCache[playerId]=url;
      return url;
    });
  }).catch(()=>null);
}

function hydrateAvatarsIn(root){
  root = root || document;
  const nodes = root.querySelectorAll ? root.querySelectorAll("[data-avatar-pid]") : [];
  nodes.forEach(node=>{
    const rawPid = node.getAttribute("data-avatar-pid");
    const name = node.getAttribute("data-avatar-name") || "";
    // Resolve to the best key for avatar storage (prefer saved profile id)
    const resolvedPid = resolvePlayerId(rawPid) || resolvePlayerId(name) || rawPid;

    // If we resolved to something better, update the node so future clicks use the right key
    if(resolvedPid && resolvedPid !== rawPid){
      node.setAttribute("data-avatar-pid", resolvedPid);
    }

    const img = node.querySelector("img");
    const initialsSpan = node.querySelector("span");

    // default initials
    if(initialsSpan){
      initialsSpan.textContent = _avatarInitials(name) || "?";
      initialsSpan.style.display = "";
    }
    if(img){ img.style.display = "none"; }

    if(!resolvedPid){
      if(img){ img.removeAttribute("src"); img.style.display="none"; }
      if(initialsSpan){ initialsSpan.style.display=""; }
      return;
    }

    getAvatarDataURL(resolvedPid).then(url=>{
      if(!url){
        // show initials, hide image
        if(img){ img.removeAttribute("src"); img.style.display="none"; }
        if(initialsSpan){ initialsSpan.style.display=""; }
        return;
      }
      // show image
      if(img){
        img.src = url;
        img.style.display = "block";
        if(initialsSpan){ initialsSpan.style.display="none"; }
      }else{
        const im = document.createElement("img");
        im.alt = "avatar";
        im.src = url;
        node.innerHTML = "";
        node.appendChild(im);
      }
    });
  });
}



function openAvatarModalResolved(playerIdOrName, playerName){
  const resolved = resolvePlayerId(playerIdOrName) || resolvePlayerId(playerName) || playerIdOrName || null;
  openAvatarModal(resolved, playerName || "");
}

function openAvatarModal(playerId, playerName){
  if(!playerId){
    if(typeof toast==="function") toast("Spara profilen först för att kunna lägga till bild.");
    else alert("Spara profilen först för att kunna lägga till bild.");
    return;
  }
  __avatar.open=true;
  __avatar.playerId=playerId;
  __avatar.playerName=playerName||"";
  __avatar.img=null;
  __avatar.zoom=1;
  __avatar.offsetX=0;
  __avatar.offsetY=0;

  const who = document.getElementById("avatarWho");
  if(who) who.textContent = (playerName||"");

  const overlay = document.getElementById("avatarOverlay");
  if(overlay) overlay.style.display="flex";

  const file = document.getElementById("avatarFile");
  if(file) file.value="";

  const zoom = document.getElementById("avatarZoom");
  if(zoom) zoom.value="1";

  // Ladda befintlig bild till canvas (om finns)
  getAvatarDataURL(playerId).then(url=>{
    if(url){
      const im = new Image();
      im.onload = ()=>{ __avatar.img=im; _avatarFitAndDraw(); };
      im.src = url;
    }else{
      _avatarDrawInitials();
    }
  });

  _avatarBindCanvas();
}

function closeAvatarModal(){
  __avatar.open=false;
  const overlay = document.getElementById("avatarOverlay");
  if(overlay) overlay.style.display="none";
  // uppdatera UI där avatars syns
  try{ hydrateAvatarsIn(document); }catch(e){}
}

function _avatarCanvas(){
  return document.getElementById("avatarCanvas");
}

function _avatarDrawInitials(){
  const c=_avatarCanvas(); if(!c) return;
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle="#f3f4f6"; ctx.fillRect(0,0,c.width,c.height);
  ctx.fillStyle="#111827";
  ctx.font="900 84px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(_avatarInitials(__avatar.playerName), c.width/2, c.height/2);
}

function _avatarFitAndDraw(){
  const c=_avatarCanvas(); if(!c) return;
  const im=__avatar.img;
  if(!im){ _avatarDrawInitials(); return; }

  // Fit image to cover the square at zoom 1
  const cw=c.width, ch=c.height;
  const scaleBase = Math.max(cw/im.width, ch/im.height);
  const scale = scaleBase * (__avatar.zoom||1);

  const drawW = im.width*scale;
  const drawH = im.height*scale;

  // Default center if offsets not set
  let x = (cw - drawW)/2 + (__avatar.offsetX||0);
  let y = (ch - drawH)/2 + (__avatar.offsetY||0);

  // clamp so we don't show empty space
  const minX = cw - drawW, maxX = 0;
  const minY = ch - drawH, maxY = 0;
  if(drawW <= cw){ x = (cw-drawW)/2; }
  else{ x = Math.min(maxX, Math.max(minX, x)); }
  if(drawH <= ch){ y = (ch-drawH)/2; }
  else{ y = Math.min(maxY, Math.max(minY, y)); }

  __avatar.offsetX = x - (cw - drawW)/2;
  __avatar.offsetY = y - (ch - drawH)/2;

  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,cw,ch);
  ctx.fillStyle="#f8fafc"; ctx.fillRect(0,0,cw,ch);
  ctx.drawImage(im, x, y, drawW, drawH);

  // subtle crop border
  ctx.strokeStyle="rgba(0,0,0,.15)";
  ctx.lineWidth=2;
  ctx.strokeRect(1,1,cw-2,ch-2);
}

function _avatarBindCanvas(){
  const c=_avatarCanvas(); if(!c || c.__bound) return;
  c.__bound=true;

  c.addEventListener("pointerdown", (e)=>{
    if(!__avatar.open) return;
    __avatar.dragging=true;
    __avatar.dragStartX=e.clientX;
    __avatar.dragStartY=e.clientY;
    __avatar.baseOffsetX=__avatar.offsetX||0;
    __avatar.baseOffsetY=__avatar.offsetY||0;
    c.setPointerCapture(e.pointerId);
  });
  c.addEventListener("pointermove", (e)=>{
    if(!__avatar.open || !__avatar.dragging) return;
    const dx = e.clientX - __avatar.dragStartX;
    const dy = e.clientY - __avatar.dragStartY;
    __avatar.offsetX = (__avatar.baseOffsetX||0) + dx;
    __avatar.offsetY = (__avatar.baseOffsetY||0) + dy;
    _avatarFitAndDraw();
  });
  c.addEventListener("pointerup", (e)=>{
    __avatar.dragging=false;
    try{ c.releasePointerCapture(e.pointerId); }catch(err){}
  });
  c.addEventListener("pointercancel", ()=>{
    __avatar.dragging=false;
  });
}

function avatarOnFile(files){
  if(!files || !files[0]) return;
  const f=files[0];
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = ()=>{
    try{ URL.revokeObjectURL(url); }catch(e){}
    __avatar.img = im;
    __avatar.zoom = 1;
    __avatar.offsetX = 0;
    __avatar.offsetY = 0;
    _avatarFitAndDraw();
  };
  im.src = url;
}

function avatarSetZoom(val){
  __avatar.zoom = parseFloat(val||"1") || 1;
  _avatarFitAndDraw();
}

function _canvasToBlob(canvas, type, quality){
  return new Promise((resolve)=>{
    try{
      canvas.toBlob((b)=>resolve(b), type, quality);
    }catch(e){ resolve(null); }
  });
}

async function saveAvatar(){
  if(!__avatar.playerId) return;
  if(!__avatar.img){
    // Spara "ingen" bild? Vi tolkar som rensa
    await clearAvatar();
    return;
  }
  const c = _avatarCanvas(); if(!c) return;

  // Rendera till 256x256
  const out = document.createElement("canvas");
  out.width = 256; out.height = 256;
  const octx = out.getContext("2d");
  // Vi vill använda samma transform som preview: återskapa draw i 260x260 och skala till 256
  // Rita preview-canvas och skala ner
  octx.drawImage(c, 0, 0, out.width, out.height);

  // WebP först, annars JPEG
  let blob = await _canvasToBlob(out, "image/webp", 0.85);
  let mime = "image/webp";
  if(!blob){
    blob = await _canvasToBlob(out, "image/jpeg", 0.85);
    mime = "image/jpeg";
  }
  if(!blob){
    if(typeof toast==="function") toast("Kunde inte spara bilden.");
    else alert("Kunde inte spara bilden.");
    return;
  }

  await _idbPut(__avatar.playerId, { blob: blob, mime: mime, updatedAt: Date.now() }).catch(()=>null);
  avatarCache[__avatar.playerId] = await _blobToDataURL(blob).catch(()=>null);

  // uppdatera UI direkt
  try{ hydrateAvatarsIn(document); }catch(e){}
  if(typeof toast==="function") toast("Profilbild sparad.");
  closeAvatarModal();
}

async function clearAvatar(){
  if(!__avatar.playerId) return;
  await _idbDel(__avatar.playerId).catch(()=>null);
  delete avatarCache[__avatar.playerId];
  _avatarDrawInitials();
  try{ hydrateAvatarsIn(document); }catch(e){}
  if(typeof toast==="function") toast("Profilbild borttagen.");
}


</script>

<div id="modalButtonParking" class="hidden"></div>

<!-- ===== Steg 5: Modal för Ny spelare ===== -->
<div id="newPlayerModal" class="modalOverlay hidden" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modalSheet" id="newPlayerModalSheet">
    <div class="modalHeader">
      <h3 id="newPlayerModalTitle" style="margin-top:0">Ny spelare</h3>
    </div>
    <p class="modalSub" id="newPlayerModalSub">Fyll i uppgifter och spara.</p>
    <div id="newPlayerModalBody"></div>
  </div>
</div>


<!-- Avatar modal -->
<div id="avatarOverlay" onclick="avatarOverlayClick(event)">
  <div id="avatarModal" onclick="event.stopPropagation()">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
      <h3>Profilbild</h3>
      <button class="btn secondary" type="button" onclick="closeAvatarModal()">Stäng</button>
    </div>
    <div id="avatarWho" class="muted" style="margin-top:-2px;margin-bottom:10px"></div>

    <div id="avatarCropWrap">
      <div>
        <div id="avatarCanvasWrap">
          <canvas id="avatarCanvas" width="260" height="260"></canvas>
        </div>
        <div class="muted" id="avatarHint" style="margin-top:8px">Dra för att flytta. Använd zoom.</div>
      </div>

      <div style="flex:1;min-width:200px">
        <label>Välj bild</label>
        <input id="avatarFile" type="file" accept="image/*" onchange="avatarOnFile(this.files)"/>
        <label style="margin-top:10px">Zoom</label>
        <input id="avatarZoom" type="range" min="1" max="3" step="0.01" value="1" oninput="avatarSetZoom(this.value)"/>
        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
          <button class="btn primary" type="button" onclick="saveAvatar()">Spara</button>
          <button class="btn danger secondary" type="button" onclick="clearAvatar()">Rensa bild</button>
        </div>
        <div class="muted" style="margin-top:10px">Bilden sparas lokalt på enheten.</div>
      </div>
    </div>
  </div>
</div>


<script>
// ===== v84 Patch: Knockout med kval (upp till 32), slumpa om + start-lås, matcher syns i Match-fliken =====
(function(){
  // ---- helpers ----
  function largestPowerOfTwoLE(n){ let p=1; while(p*2<=n) p*=2; return p; }
  function shuffle(a){ a=a.slice(); for(let i=a.length-1;i>0;i--){ let j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  // ---- build knockout incl qual, with explicit links for advancement ----
  // Returns flat list of match objects compatible with state.matches/openMatch/saveMatch:
  // {id, aId, bId, winnerId, result, round, nextId, nextSlot}
  function buildKnockoutWithQual(playerIds){
    const n = playerIds.length;
    if(n < 2) return [];

    const capped = playerIds.slice(0,32); // max 32
    const ids = shuffle(capped);

    const target = largestPowerOfTwoLE(ids.length);       // 4/8/16/32
    const qualCount = ids.length - target;                // number of play-in matches
    const out = [];

    // Decide round keys that will exist for main bracket (from target down to final)
    const mainRounds = [];
    if(target >= 32) mainRounds.push({key:"r16", label:"Sextondelsfinal", size:32});
    if(target >= 16) mainRounds.push({key:"r8",  label:"Åttondelsfinal",  size:16});
    if(target >= 8)  mainRounds.push({key:"r4",  label:"Kvartsfinal",     size:8});
    if(target >= 4)  mainRounds.push({key:"r2",  label:"Semifinal",       size:4});
    mainRounds.push({key:"r1", label:"Final", size:2});

    // Map internal ids to the ids that playoffs-bracket view expects (po_*),
    // at least for 4/8 players. For 16/32 keep r*_i ids (no bracket view for those).
    function mapId(key, idx){
      if(target === 4){
        if(key === "r2") return `po_sf${idx+1}`;
        if(key === "r1") return `po_f`;
      }
      if(target === 8){
        if(key === "r4") return `po_qf${idx+1}`;
        if(key === "r2") return `po_sf${idx+1}`;
        if(key === "r1") return `po_f`;
      }
      return `${key}_${idx}`;
    }

    function mkMatch(id, roundLabel, group){
      return {
        id,
        stage:"Slutspel",
        group: group || "",
        round: roundLabel,
        aId:null, bId:null,
        winnerId:null,
        result:"",
        avgA:"", avgB:"", f9A:"", f9B:"", coA:"", coB:"",
        notes:"",
        nextId:null,
        nextSlot:null
      };
    }

    // Create main round match shells
    const roundMatches = {};
    mainRounds.forEach(r=>{
      const mcount = r.size/2;
      roundMatches[r.key]=[];
      for(let i=0;i<mcount;i++){
        const id = mapId(r.key, i);
        const group =
          (r.key==="r4") ? "QF" :
          (r.key==="r2") ? "SF" :
          (r.key==="r1") ? "F"  : r.key.toUpperCase();
        const label = (r.key==="r1") ? "Final" : `${r.label}${mcount>1 ? " "+(i+1) : ""}`;
        roundMatches[r.key].push(mkMatch(id, label.trim(), group));
      }
    });

    // Wire advancement between main rounds
    for(let ri=0; ri<mainRounds.length-1; ri++){
      const cur = mainRounds[ri].key;
      const nxt = mainRounds[ri+1].key;
      roundMatches[cur].forEach((m, idx)=>{
        const nextMatchIndex = Math.floor(idx/2);
        const slot = (idx%2===0) ? "aId" : "bId";
        m.nextId = mapId(nxt, nextMatchIndex);
        m.nextSlot = slot;
      });
    }

    // Qual matches (feed into FIRST main round): po_k1..po_kN
    const qual = [];
    for(let i=0;i<qualCount;i++){
      qual.push(mkMatch(`po_k${i+1}`, `Kval ${i+1}`, "K"));
      qual[i].aId = ids[i*2] || null;
      qual[i].bId = ids[i*2+1] || null;
    }

    // Participants that skip qual
    const direct = ids.slice(qualCount*2);

    // Build slots for first main round = target participants
    const firstKey = mainRounds[0].key;
    const slots = [];
    for(let i=0;i<qualCount;i++) slots.push({fromQual:true, idx:i});
    direct.forEach(pid => slots.push({pid}));

    const filled = shuffle(slots);

    // Fill first round matches
    roundMatches[firstKey].forEach(m=>{
      const s1 = filled.shift() || null;
      const s2 = filled.shift() || null;
      m.aId = s1 && s1.pid ? s1.pid : null;
      m.bId = s2 && s2.pid ? s2.pid : null;

      // store placeholders as metadata for rendering labels in playoffs view
      m._aFromQual = (s1 && s1.fromQual) ? s1.idx : null; // 0-based
      m._bFromQual = (s2 && s2.fromQual) ? s2.idx : null; // 0-based
    });

    // Wire qual -> first round: each qual winner will occupy a specific placeholder slot.
    const firstRound = roundMatches[firstKey];
    const placeholderSlots = [];
    firstRound.forEach(m=>{
      if(m._aFromQual!==null && m._aFromQual!==undefined) placeholderSlots.push({matchId:m.id, slot:"aId", qualIndex:m._aFromQual});
      if(m._bFromQual!==null && m._bFromQual!==undefined) placeholderSlots.push({matchId:m.id, slot:"bId", qualIndex:m._bFromQual});
    });
    placeholderSlots.sort((x,y)=>x.qualIndex-y.qualIndex);

    qual.forEach((qm, i)=>{
      const ps = placeholderSlots.find(s=>s.qualIndex===i);
      if(ps){
        qm.nextId = ps.matchId;
        qm.nextSlot = ps.slot;
      }
    });

    // Flatten in play-order: Qual first, then main rounds in order
    qual.forEach(m=>out.push(m));
    mainRounds.forEach(r=>{
      roundMatches[r.key].forEach(m=>out.push(m));
    });

    // Auto-advance BYE (if only one side present) repeatedly until stable
    function applyByes(){
      let changed=false;
      out.forEach(m=>{
        if(m.winnerId) return;

        // Only real BYE when opponent truly missing.
        // If slot is reserved for "Vinnare Kval X" (placeholder) we must NOT auto-decide.
        const aIsReal = !!m.aId;
        const bIsReal = !!m.bId;
        const aWaitingQual = (m._aFromQual !== null && m._aFromQual !== undefined);
        const bWaitingQual = (m._bFromQual !== null && m._bFromQual !== undefined);

        if(aIsReal && !bIsReal && !bWaitingQual){
          m.winnerId = m.aId;
          m.result = "BYE";
          changed = true;
        }else if(!aIsReal && bIsReal && !aWaitingQual){
          m.winnerId = m.bId;
          m.result = "BYE";
          changed = true;
        }
      });
      if(changed) advanceFromAllWinners();
      return changed;
    }

    function advanceFromAllWinners(){
      const byId = {};
      out.forEach(m=>byId[m.id]=m);
      out.forEach(m=>{
        if(!m.winnerId || !m.nextId || !m.nextSlot) return;
        const nm = byId[m.nextId];
        if(!nm) return;
        if(nm[m.nextSlot] !== m.winnerId){
          // If the slot is changing, clear downstream winners to avoid stale brackets
          nm[m.nextSlot] = m.winnerId;
          nm.winnerId = null;
          nm.result = "";
        }
      });
    }

    // initial propagate from any BYE winners
    advanceFromAllWinners();
    // loop BYEs a few times to settle
    for(let k=0;k<10;k++){
      if(!applyByes()) break;
    }

    return out;
  }

  // ---- override buildKnockoutBracket used by createTournament ----

  window.buildKnockoutBracket = function(playerIds){
    return buildKnockoutWithQual(playerIds);
  };

  // ---- Add controls in playoffs step (reuse existing container if present) ----
  function ensurePlayoffControls(){
    const host = document.querySelector("#playoffsStep .sectionHeader, #playoffsStep header, #playoffsStep h2, #playoffsStep h3, #playoffsStep .section-title, #playoffsStep") 
      || document.querySelector("#playoffsStep") || document.body;
    if(!host) return;

    // Visa bara "Slumpa om slutspel" när formatet är rent slutspel (knockout).
    // I andra format (grupp/serie + slutspel) ska slutspelet styras av placeringar och inte slumpas om här.
    if(state.format !== "knockout"){
      const b1 = document.getElementById("shufflePlayoffsBtn");
      if(b1){
        const w = b1.closest(".row") || b1.parentElement;
        if(w) w.remove();
      }
      const b2 = document.getElementById("startPlayoffsBtn");
      if(b2){
        const w2 = b2.closest(".row") || b2.parentElement;
        if(w2) w2.remove();
      }
      return;
    }

    // Undvik dubbla kontroller
    if(document.getElementById("shufflePlayoffsBtn")) return;

    const wrap = document.createElement("div");
    wrap.className = "row";
    wrap.style.cssText = "gap:8px;margin:8px 0;flex-wrap:wrap;";
    wrap.innerHTML = `<button id="shufflePlayoffsBtn" class="btn secondary">Slumpa om slutspel</button>`;
    host.appendChild(wrap);

    document.getElementById("shufflePlayoffsBtn").onclick = function(){
      if(state.playoffs && state.playoffs.started){
        alert("Slutspelet är startat och kan inte slumpas om.");
        return;
      }
      const ids = (state.players||[]).map(p=>p.id);
      const po = buildKnockoutWithQual(ids);
      state.playoffs = state.playoffs || {started:false, matches:[]};
      state.playoffs.matches = po;
      state.matches = po; // sync
      autosaveTournament(); saveState(); renderAll();
    };
  }

  // ---- Patch renderPlayoffs to keep your old bracket look, but also show kval in schema (already does) ----
  // We only ensure controls exist and that state.matches is synced.
  const _origRenderPlayoffs = window.renderPlayoffs;
  window.renderPlayoffs = function(){
    try{ ensurePlayoffControls(); }catch(e){}
    try{
      if(state.format==="knockout"){
        // keep matches in matchflik synced
        if(state.playoffs && state.playoffs.matches) state.matches = state.playoffs.matches;
      }
    }catch(e){}
    return _origRenderPlayoffs();
  };

  // ---- Patch renderMatches (knockout): keep SAME look as other formats, but use runda + väntar/spelbar ----
  const _origRenderMatches = window.renderMatches;
  window.renderMatches = function(){
    if(state.format!=="knockout") return _origRenderMatches();

    applyStartStamp();
    const ms = state.matches || [];
    const rows=[];
    rows.push(`<tr><th>Match</th><th>Status</th></tr>`);
    ms.forEach(m=>{
      const started = !!(state.playoffs && state.playoffs.started);
      const ready = !!(m.aId && m.bId);
      const playable = started && ready;
      const played = !!m.winnerId;

      const labelA = m.aId ? playerName(m.aId) : (m._aFromQual!=null ? `Vinnare Kval ${m._aFromQual+1}` : "—");
      const labelB = m.bId ? playerName(m.bId) : (m._bFromQual!=null ? `Vinnare Kval ${m._bFromQual+1}` : "—");

      const status = played
        ? `<span class="tag ok">${escapeHtml(playerName(m.winnerId))} vann ${m.result?`(${escapeHtml(m.result)})`:``}</span>`
        : (playable ? `<span class="tag todo">Spelbar</span>` : `<span class="tag">Väntar</span>`);

      // "Runda"-tagg i meta, men samma meta-rad som övriga format
      const roundTag = m.round ? escapeHtml(m.round) : "Slutspel";

      rows.push(`
        <tr class="matchRow ${played?'played':''} ${playable?'':'disabled'}" ${playable?`onclick="openMatch('${m.id}')"`:''}>
          <td>
            <div class='row' style='align-items:center;gap:8px'>
              ${m.aId ? _avatarBtnViewHtml(m.aId, playerName(m.aId), 'small') : `<span class="avatar small">${escapeHtml((labelA||'—').slice(0,2).toUpperCase())}</span>`}
              <strong>${escapeHtml(labelA)}</strong>
              <span class='muted'>vs</span>
              ${m.bId ? _avatarBtnViewHtml(m.bId, playerName(m.bId), 'small') : `<span class="avatar small">${escapeHtml((labelB||'—').slice(0,2).toUpperCase())}</span>`}
              <strong>${escapeHtml(labelB)}</strong>
            </div>
            <div class="matchMeta">
              <span class="tag">${roundTag}</span>
              ${m.finishedAt ? `<span class="tag">Avsl: ${escapeHtml(formatDateTimeShort(m.finishedAt))}</span>` : ``}
              ${m.avgA || m.avgB ? `<span class="tag">Avg: ${escapeHtml(m.avgA||'–')} / ${escapeHtml(m.avgB||'–')}</span>` : ``}
            </div>
          </td>
          <td>${status}</td>
        </tr>
      `);
    });
    $("matchesTable").innerHTML = rows.join("");
    try{ hydrateAvatarsIn($("matchesTable")); }catch(e){}
  };

  // ---- Lock openMatch before start for knockout, and also block if participants missing ----
  const _origOpenMatch = window.openMatch;
  window.openMatch = function(matchId){
    if(state.format==="knockout"){
      if(!state.playoffs || !state.playoffs.started){ alert("Tryck på 'Starta slutspel' innan du kan öppna matcher."); return; }
      const m = (state.matches||[]).find(x=>x.id===matchId);
      if(!m || !m.aId || !m.bId){ alert("Matchen är inte redo ännu."); return; }
    }
    return _origOpenMatch(matchId);
  };

  // ---- Advance winners after saving match ----
  const _origSaveMatch = window.saveMatch;
  window.saveMatch = function(){
    _origSaveMatch();
    try{
      if(state.format!=="knockout") return;
      const ms = state.matches || [];
      const byId = {};
      ms.forEach(m=>byId[m.id]=m);
      // propagate winners
      ms.forEach(m=>{
        if(!m.winnerId || !m.nextId || !m.nextSlot) return;
        const nm = byId[m.nextId];
        if(!nm) return;
        if(nm[m.nextSlot] !== m.winnerId){
          nm[m.nextSlot] = m.winnerId;
          nm.winnerId = null;
          nm.result = "";
        }
      });
      // Apply BYE auto-wins and propagate a few times
      for(let k=0;k<10;k++){
        let changed=false;
        ms.forEach(m=>{
          if(m.winnerId) return;
          if(m.aId && !m.bId){ m.winnerId=m.aId; m.result="BYE"; changed=true; }
          else if(!m.aId && m.bId){ m.winnerId=m.bId; m.result="BYE"; changed=true; }
        });
        if(!changed) break;
        ms.forEach(m=>{
          if(!m.winnerId || !m.nextId || !m.nextSlot) return;
          const nm = byId[m.nextId];
          if(!nm) return;
          if(nm[m.nextSlot] !== m.winnerId){
            nm[m.nextSlot]=m.winnerId;
            nm.winnerId=null;
            nm.result="";
          }
        });
      }

      state.playoffs = state.playoffs || {started:true,matches:ms};
      state.playoffs.matches = ms;
      autosaveTournament(); saveState();
      renderAll();
    }catch(e){}
  };

  // ---- Keep manual player inputs stable when navigating back (avoid "forget tournament") ----
  const _origRenderPlayersStep = window.renderPlayersStep;
  window.renderPlayersStep = function(){
    _origRenderPlayersStep();
    try{
      // If a tournament already exists, prefill manual inputs from state.players (so Back doesn't "lose" it)
      if(!state.players || !state.players.length) return;
      // Find common player name inputs: ids like pName1.. or playerName1.. (best-effort)
      const inputs = Array.from(document.querySelectorAll("input[type='text'], textarea"))
        .filter(el=>/name/i.test(el.id||"") && (/(player|p)name/i.test(el.id||"")));
      if(!inputs.length) return;

      const hasAny = inputs.some(inp=>String(inp.value||"").trim().length>0);
      if(hasAny) return; // don't overwrite user edits

      // Fill sequentially
      let i=0;
      inputs.forEach(inp=>{
        if(i<state.players.length){
          inp.value = state.players[i].name || "";
          i++;
        }
      });
    }catch(e){}
  };

})();
</script>


<!-- === OFFLINE-FIRST START + LOCAL HUB (rebased on v98 core) === -->
<style>
  
html, body { height: 100%; }
body { padding-bottom: 1px; }
.overlayScreen{position:fixed;inset:0;z-index:99999;background:linear-gradient(180deg,#0b2442,#08192f);display:none;align-items:center;justify-content:center;padding:24px;overflow:auto}
  .overlayScreen.active{display:flex}
  .overlayScreen .panel{width:min(720px,100%);margin-top:0;background:rgba(255,255,255,.92);border-radius:18px;padding:18px 18px 22px;box-shadow:0 20px 60px rgba(0,0,0,.35)}
  .overlayScreen h2{margin:0 0 6px;font-size:22px}
  .overlayScreen p{margin:0 0 14px;color:#334155}
  .overlayScreen .row{display:flex;gap:12px;flex-wrap:wrap}
  .overlayScreen .row .btn{flex:1 1 220px}
  .overlayScreen .hint{margin-top:10px;font-size:13px;color:#475569}
  .overlayScreen .list{margin-top:14px;border-top:1px solid #e5e7eb;padding-top:12px}
  .overlayScreen .item{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 0;border-bottom:1px solid #eef2f7}
  .overlayScreen .item .meta{min-width:0;flex:1}
  .overlayScreen .item .meta strong{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .overlayScreen .item .actions{display:flex;gap:8px;align-items:center}
  .overlayScreen .smalllink{margin-top:10px;font-size:13px;color:#0b2442;text-decoration:underline;cursor:pointer;display:inline-block}
  .miniList{max-height:260px;overflow:auto;border:1px solid #e5e7eb;border-radius:14px;padding:6px 12px;background:#fff}
  .miniList .item{padding:10px 0}
  .miniList .actions .btn{padding:9px 12px;font-size:14px}
  .bracketNav{display:none !important}

/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>

<div id="startScreen" class="splashScreen active" aria-hidden="false" style="cursor:pointer">
  <div class="splashTitle">DART-TURNERING</div>
  <div class="splashCard">
    <div class="startHero" aria-hidden="true">
        <div class="boardWrap">
    <svg viewBox="0 0 200 200" role="img" aria-label="Darttavla">
      <circle cx="100" cy="100" r="98" fill="#0f0f0f"/>
      <path d="M 100.000 4.000 A 96 96 0 0 1 129.666 8.699 L 108.652 73.370 A 28 28 0 0 0 100.000 72.000 Z" fill="#111"/><path d="M 129.666 8.699 A 96 96 0 0 1 156.427 22.334 L 116.458 77.348 A 28 28 0 0 0 108.652 73.370 Z" fill="#f3f1e6"/><path d="M 156.427 22.334 A 96 96 0 0 1 177.666 43.573 L 122.652 83.542 A 28 28 0 0 0 116.458 77.348 Z" fill="#111"/><path d="M 177.666 43.573 A 96 96 0 0 1 191.301 70.334 L 126.630 91.348 A 28 28 0 0 0 122.652 83.542 Z" fill="#f3f1e6"/><path d="M 191.301 70.334 A 96 96 0 0 1 196.000 100.000 L 128.000 100.000 A 28 28 0 0 0 126.630 91.348 Z" fill="#111"/><path d="M 196.000 100.000 A 96 96 0 0 1 191.301 129.666 L 126.630 108.652 A 28 28 0 0 0 128.000 100.000 Z" fill="#f3f1e6"/><path d="M 191.301 129.666 A 96 96 0 0 1 177.666 156.427 L 122.652 116.458 A 28 28 0 0 0 126.630 108.652 Z" fill="#111"/><path d="M 177.666 156.427 A 96 96 0 0 1 156.427 177.666 L 116.458 122.652 A 28 28 0 0 0 122.652 116.458 Z" fill="#f3f1e6"/><path d="M 156.427 177.666 A 96 96 0 0 1 129.666 191.301 L 108.652 126.630 A 28 28 0 0 0 116.458 122.652 Z" fill="#111"/><path d="M 129.666 191.301 A 96 96 0 0 1 100.000 196.000 L 100.000 128.000 A 28 28 0 0 0 108.652 126.630 Z" fill="#f3f1e6"/><path d="M 100.000 196.000 A 96 96 0 0 1 70.334 191.301 L 91.348 126.630 A 28 28 0 0 0 100.000 128.000 Z" fill="#111"/><path d="M 70.334 191.301 A 96 96 0 0 1 43.573 177.666 L 83.542 122.652 A 28 28 0 0 0 91.348 126.630 Z" fill="#f3f1e6"/><path d="M 43.573 177.666 A 96 96 0 0 1 22.334 156.427 L 77.348 116.458 A 28 28 0 0 0 83.542 122.652 Z" fill="#111"/><path d="M 22.334 156.427 A 96 96 0 0 1 8.699 129.666 L 73.370 108.652 A 28 28 0 0 0 77.348 116.458 Z" fill="#f3f1e6"/><path d="M 8.699 129.666 A 96 96 0 0 1 4.000 100.000 L 72.000 100.000 A 28 28 0 0 0 73.370 108.652 Z" fill="#111"/><path d="M 4.000 100.000 A 96 96 0 0 1 8.699 70.334 L 73.370 91.348 A 28 28 0 0 0 72.000 100.000 Z" fill="#f3f1e6"/><path d="M 8.699 70.334 A 96 96 0 0 1 22.334 43.573 L 77.348 83.542 A 28 28 0 0 0 73.370 91.348 Z" fill="#111"/><path d="M 22.334 43.573 A 96 96 0 0 1 43.573 22.334 L 83.542 77.348 A 28 28 0 0 0 77.348 83.542 Z" fill="#f3f1e6"/><path d="M 43.573 22.334 A 96 96 0 0 1 70.334 8.699 L 91.348 73.370 A 28 28 0 0 0 83.542 77.348 Z" fill="#111"/><path d="M 70.334 8.699 A 96 96 0 0 1 100.000 4.000 L 100.000 72.000 A 28 28 0 0 0 91.348 73.370 Z" fill="#f3f1e6"/>
      <path d="M 100.000 30.000 A 70 70 0 0 1 121.631 33.426 L 119.159 41.034 A 62 62 0 0 0 100.000 38.000 Z" fill="#c21f2f"/><path d="M 121.631 33.426 A 70 70 0 0 1 141.145 43.369 L 136.443 49.841 A 62 62 0 0 0 119.159 41.034 Z" fill="#1f8a4c"/><path d="M 141.145 43.369 A 70 70 0 0 1 156.631 58.855 L 150.159 63.557 A 62 62 0 0 0 136.443 49.841 Z" fill="#c21f2f"/><path d="M 156.631 58.855 A 70 70 0 0 1 166.574 78.369 L 158.966 80.841 A 62 62 0 0 0 150.159 63.557 Z" fill="#1f8a4c"/><path d="M 166.574 78.369 A 70 70 0 0 1 170.000 100.000 L 162.000 100.000 A 62 62 0 0 0 158.966 80.841 Z" fill="#c21f2f"/><path d="M 170.000 100.000 A 70 70 0 0 1 166.574 121.631 L 158.966 119.159 A 62 62 0 0 0 162.000 100.000 Z" fill="#1f8a4c"/><path d="M 166.574 121.631 A 70 70 0 0 1 156.631 141.145 L 150.159 136.443 A 62 62 0 0 0 158.966 119.159 Z" fill="#c21f2f"/><path d="M 156.631 141.145 A 70 70 0 0 1 141.145 156.631 L 136.443 150.159 A 62 62 0 0 0 150.159 136.443 Z" fill="#1f8a4c"/><path d="M 141.145 156.631 A 70 70 0 0 1 121.631 166.574 L 119.159 158.966 A 62 62 0 0 0 136.443 150.159 Z" fill="#c21f2f"/><path d="M 121.631 166.574 A 70 70 0 0 1 100.000 170.000 L 100.000 162.000 A 62 62 0 0 0 119.159 158.966 Z" fill="#1f8a4c"/><path d="M 100.000 170.000 A 70 70 0 0 1 78.369 166.574 L 80.841 158.966 A 62 62 0 0 0 100.000 162.000 Z" fill="#c21f2f"/><path d="M 78.369 166.574 A 70 70 0 0 1 58.855 156.631 L 63.557 150.159 A 62 62 0 0 0 80.841 158.966 Z" fill="#1f8a4c"/><path d="M 58.855 156.631 A 70 70 0 0 1 43.369 141.145 L 49.841 136.443 A 62 62 0 0 0 63.557 150.159 Z" fill="#c21f2f"/><path d="M 43.369 141.145 A 70 70 0 0 1 33.426 121.631 L 41.034 119.159 A 62 62 0 0 0 49.841 136.443 Z" fill="#1f8a4c"/><path d="M 33.426 121.631 A 70 70 0 0 1 30.000 100.000 L 38.000 100.000 A 62 62 0 0 0 41.034 119.159 Z" fill="#c21f2f"/><path d="M 30.000 100.000 A 70 70 0 0 1 33.426 78.369 L 41.034 80.841 A 62 62 0 0 0 38.000 100.000 Z" fill="#1f8a4c"/><path d="M 33.426 78.369 A 70 70 0 0 1 43.369 58.855 L 49.841 63.557 A 62 62 0 0 0 41.034 80.841 Z" fill="#c21f2f"/><path d="M 43.369 58.855 A 70 70 0 0 1 58.855 43.369 L 63.557 49.841 A 62 62 0 0 0 49.841 63.557 Z" fill="#1f8a4c"/><path d="M 58.855 43.369 A 70 70 0 0 1 78.369 33.426 L 80.841 41.034 A 62 62 0 0 0 63.557 49.841 Z" fill="#c21f2f"/><path d="M 78.369 33.426 A 70 70 0 0 1 100.000 30.000 L 100.000 38.000 A 62 62 0 0 0 80.841 41.034 Z" fill="#1f8a4c"/>
      <path d="M 100.000 4.000 A 96 96 0 0 1 129.666 8.699 L 127.812 14.405 A 90 90 0 0 0 100.000 10.000 Z" fill="#c21f2f"/><path d="M 129.666 8.699 A 96 96 0 0 1 156.427 22.334 L 152.901 27.188 A 90 90 0 0 0 127.812 14.405 Z" fill="#1f8a4c"/><path d="M 156.427 22.334 A 96 96 0 0 1 177.666 43.573 L 172.812 47.099 A 90 90 0 0 0 152.901 27.188 Z" fill="#c21f2f"/><path d="M 177.666 43.573 A 96 96 0 0 1 191.301 70.334 L 185.595 72.188 A 90 90 0 0 0 172.812 47.099 Z" fill="#1f8a4c"/><path d="M 191.301 70.334 A 96 96 0 0 1 196.000 100.000 L 190.000 100.000 A 90 90 0 0 0 185.595 72.188 Z" fill="#c21f2f"/><path d="M 196.000 100.000 A 96 96 0 0 1 191.301 129.666 L 185.595 127.812 A 90 90 0 0 0 190.000 100.000 Z" fill="#1f8a4c"/><path d="M 191.301 129.666 A 96 96 0 0 1 177.666 156.427 L 172.812 152.901 A 90 90 0 0 0 185.595 127.812 Z" fill="#c21f2f"/><path d="M 177.666 156.427 A 96 96 0 0 1 156.427 177.666 L 152.901 172.812 A 90 90 0 0 0 172.812 152.901 Z" fill="#1f8a4c"/><path d="M 156.427 177.666 A 96 96 0 0 1 129.666 191.301 L 127.812 185.595 A 90 90 0 0 0 152.901 172.812 Z" fill="#c21f2f"/><path d="M 129.666 191.301 A 96 96 0 0 1 100.000 196.000 L 100.000 190.000 A 90 90 0 0 0 127.812 185.595 Z" fill="#1f8a4c"/><path d="M 100.000 196.000 A 96 96 0 0 1 70.334 191.301 L 72.188 185.595 A 90 90 0 0 0 100.000 190.000 Z" fill="#c21f2f"/><path d="M 70.334 191.301 A 96 96 0 0 1 43.573 177.666 L 47.099 172.812 A 90 90 0 0 0 72.188 185.595 Z" fill="#1f8a4c"/><path d="M 43.573 177.666 A 96 96 0 0 1 22.334 156.427 L 27.188 152.901 A 90 90 0 0 0 47.099 172.812 Z" fill="#c21f2f"/><path d="M 22.334 156.427 A 96 96 0 0 1 8.699 129.666 L 14.405 127.812 A 90 90 0 0 0 27.188 152.901 Z" fill="#1f8a4c"/><path d="M 8.699 129.666 A 96 96 0 0 1 4.000 100.000 L 10.000 100.000 A 90 90 0 0 0 14.405 127.812 Z" fill="#c21f2f"/><path d="M 4.000 100.000 A 96 96 0 0 1 8.699 70.334 L 14.405 72.188 A 90 90 0 0 0 10.000 100.000 Z" fill="#1f8a4c"/><path d="M 8.699 70.334 A 96 96 0 0 1 22.334 43.573 L 27.188 47.099 A 90 90 0 0 0 14.405 72.188 Z" fill="#c21f2f"/><path d="M 22.334 43.573 A 96 96 0 0 1 43.573 22.334 L 47.099 27.188 A 90 90 0 0 0 27.188 47.099 Z" fill="#1f8a4c"/><path d="M 43.573 22.334 A 96 96 0 0 1 70.334 8.699 L 72.188 14.405 A 90 90 0 0 0 47.099 27.188 Z" fill="#c21f2f"/><path d="M 70.334 8.699 A 96 96 0 0 1 100.000 4.000 L 100.000 10.000 A 90 90 0 0 0 72.188 14.405 Z" fill="#1f8a4c"/>
      <circle cx="100" cy="100" r="26" fill="#0f0f0f"/>
      <circle cx="100" cy="100" r="18" fill="#1f8a4c"/>
      <circle cx="100" cy="100" r="8" fill="#c21f2f"/>
      <circle cx="100" cy="100" r="98" fill="none" stroke="rgba(255,255,255,0.14)" stroke-width="2"/>
      <circle cx="100" cy="100" r="70" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="1.5"/>
      <circle cx="100" cy="100" r="62" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="1.5"/>
      <circle cx="100" cy="100" r="96" fill="none" stroke="rgba(255,255,255,0.10)" stroke-width="1.5"/>
      <circle cx="100" cy="100" r="90" fill="none" stroke="rgba(255,255,255,0.10)" stroke-width="1.5"/>
    </svg>
  </div>

      <div class="heroDart d1"><span class="flight"></span><span class="shaft"></span><span class="tip"></span></div>
      <div class="heroDart d2"><span class="flight"></span><span class="shaft"></span><span class="tip"></span></div>
      <div class="heroDart d3"><span class="flight"></span><span class="shaft"></span><span class="tip"></span></div>
    </div>
  </div>
  <div class="splashHint">Tryck för att fortsätta…</div>
</div>

<div id="localHubScreen" class="overlayScreen" aria-hidden="true">
  <div class="panel">
    <h2>Turneringar</h2>
    <p>Skapa ny eller öppna en sparad turnering.</p>

    <div class="row" style="gap:10px;flex-wrap:wrap;align-items:stretch">
      <button class="btn" id="btnHubNew">➕ Skapa ny turnering</button>
      <label class="btn secondary" style="cursor:pointer">📥 Importera turnering
        <input id="hubImportJson" type="file" accept="application/json,.json" hidden>
      </label>
      <button class="btn secondary" id="btnHubPlayers" type="button">👤 Spelare</button>
    </div>

    <!-- Online-stomme (UI + flöden, utan Firebase än) -->
    <div class="card" style="margin:14px 0 0; box-shadow:none; border:1px solid #eef1f6">
      <div class="row between" style="align-items:center;gap:10px">
        <div>
          <div style="font-size:18px;font-weight:900;line-height:1.1">Online</div>
          <div class="small muted" style="margin-top:4px">Skapa eller anslut med kod. (Test-stomme – ingen publicering än)</div>
        </div>
        <span class="pill" title="Online"><span aria-hidden="true">🌍</span> online</span>
      </div>
      <div class="row" style="gap:10px;flex-wrap:wrap;align-items:stretch;margin-top:12px">
        <button class="btn" id="btnCreateOnline" type="button">🌍 Skapa online-turnering</button>
        <button class="btn secondary" id="btnJoinOnline" type="button">🔑 Anslut med kod</button>
      </div>
      <div class="hint" style="margin-top:10px">Standard är fortfarande lokal/offline när du skapar turnering via “Skapa ny turnering”.</div>
    </div>

    <div class="list" style="margin-top:14px">
      <div style="font-weight:800;margin:0 0 8px">Mina lokala turneringar</div>
      <div class="miniList" id="hubList"><em>Inga sparade turneringar ännu.</em></div>
      </div>

    <div class="list" style="margin-top:14px">
      <div style="font-weight:800;margin:0 0 8px">Mina online-turneringar <span class="muted" aria-hidden="true">🌍</span></div>
      <div class="miniList" id="hubOnlineOwned"><em>Inga online-turneringar ännu.</em></div>
    </div>

    <div class="list" style="margin-top:14px">
      <div style="font-weight:800;margin:0 0 8px">Online-turneringar jag deltar i <span class="muted" aria-hidden="true">🌍</span></div>
      <div class="miniList" id="hubOnlineJoined"><em>Inga anslutna online-turneringar ännu.</em></div>
    </div>

    </div>
</div>

<!-- Player register popup (snabbgenvag fran Turneringar) -->
<div class="overlay hidden" id="playerRegisterOverlay" onclick="closePlayerRegisterPopup()">
  <div class="modal" onclick="stopPropagation(event)">
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <h3 style="margin:0">Spelare</h3>
        <div class="small muted" id="accountStatusText" style="margin-top:4px"></div>
        
      </div>
      <button class="btn secondary" type="button" onclick="closePlayerRegisterPopup()">Stäng</button>
    </div>
    <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:10px">
      <button class="btn" type="button" onclick="openAuthOverlay()">Logga in / Skapa konto</button>
      <button class="btn secondary" type="button" onclick="logoutAccount()">Logga ut</button>
    </div>
    <div style="margin-top:12px" class="row">
      <button class="btn secondary" type="button" onclick="window.__fromPlayerRegisterPopup=true; window.__reopenPlayerRegisterAfterNewPlayer=true; closePlayerRegisterPopup(); openNewOrEditPlayerModal('single','playerRegisterSelect');">Ny / Ändra</button>
    </div>
    <div id="playerRegisterBody" style="margin-top:12px"></div>
  </div>
</div>

<!-- Auth overlay (UI-stomme: sparar konto lokalt, kopplas till "min spelare" senare) -->
<div class="overlay hidden" id="authOverlay" onclick="closeAuthOverlay()">
  <div class="modal" onclick="stopPropagation(event)">
    <div class="row" style="justify-content:space-between;align-items:center;gap:10px">
      <h3 style="margin:0">Konto</h3>
      <button class="btn secondary" type="button" onclick="closeAuthOverlay()">Stäng</button>
    </div>

    <div class="card" style="box-shadow:none;border:1px solid #eef1f6;margin-top:12px">
      <div class="hint" style="margin:0">Det här är en lokal test-stomme. Sen kopplar vi på Firebase Auth + Firestore.</div>
      <div style="margin-top:10px">
        <label class="small muted">Namn</label>
        <input id="authName" type="text" placeholder="Ditt namn" style="width:100%">
      </div>
      <div style="margin-top:10px">
        <label class="small muted">Avatar (valfritt, emoji eller kort text)</label>
        <input id="authAvatar" type="text" placeholder="🎯" style="width:100%">
      </div>
      <div class="btnbar" style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn" type="button" onclick="saveAccountFromAuthForm()">Spara / Logga in</button>
        <button class="btn secondary" type="button" onclick="prefillFromSavedPlayer()">Hämta från sparad spelare</button>
      </div>
      <div class="small muted" style="margin-top:10px" id="authInfoText"></div>
    </div>
  </div>
</div>

<!-- Join online overlay (kod) -->
<div class="overlay hidden" id="joinOnlineOverlay" onclick="closeJoinOnlineOverlay()">
  <div class="modal" onclick="stopPropagation(event)">
    <div class="row" style="justify-content:space-between;align-items:center;gap:10px">
      <h3 style="margin:0">Anslut till online-turnering</h3>
      <button class="btn secondary" type="button" onclick="closeJoinOnlineOverlay()">Stäng</button>
    </div>
    <div class="card" style="box-shadow:none;border:1px solid #eef1f6;margin-top:12px">
      <label class="small muted">Kod</label>
      <input id="joinOnlineCode" type="text" placeholder="Ex: 4F7KQ2" style="width:100%;text-transform:uppercase">
      <div class="btnbar" style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn" type="button" onclick="joinOnlineByCodeFromUI()">Anslut</button>
        <button class="btn secondary" type="button" onclick="closeJoinOnlineOverlay()">Avbryt</button>
      </div>
      <div class="small muted" style="margin-top:10px">När du ansluter hamnar turneringen i listan. Själva matchsynk kommer senare.</div>
    </div>
  </div>
</div>

<script>
(function(){
  const LIB_PREFIX = "dart_tournament_v98_";
  const LEGACY_KEY = (typeof STORAGE_KEY !== "undefined") ? STORAGE_KEY : "turneringsapp_v2_2";
  const AUTOSAVE = (typeof AUTOSAVE_KEY !== "undefined") ? AUTOSAVE_KEY : "turneringsapp_autosave_v1";

  let INITIAL_STATE = null;

  function show(id){
    const start = document.getElementById("startScreen");
    const hub = document.getElementById("localHubScreen");
    if(start){ start.classList.remove("active"); start.setAttribute("aria-hidden","true"); }
    if(hub){ hub.classList.remove("active"); hub.setAttribute("aria-hidden","true"); }
    const el = document.getElementById(id);
    if(!el) return;
    el.classList.add("active");
    el.setAttribute("aria-hidden","false");
  }
  function hideAll(){
    document.getElementById("startScreen").classList.remove("active");
    document.getElementById("localHubScreen").classList.remove("active");
    document.getElementById("startScreen").setAttribute("aria-hidden","true");
    document.getElementById("localHubScreen").setAttribute("aria-hidden","true");
  }

  function nowIso(){ return new Date().toISOString(); }

  function loadJson(key){
    try{
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : null;
    }catch(e){ return null; }
  }
  function saveJson(key, obj){
    try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){}
  }

  // ===== Online-stomme (lokal data, ingen Firebase än) =====
  const ACCOUNT_KEY = "dart_account_v1";
  const ONLINE_KEY = "dart_online_tournaments_v1";

  function loadAccount(){
    const a = loadJson(ACCOUNT_KEY);
    if(!a || typeof a !== 'object') return null;
    if(!a.uid) return null;
    return a;
  }
  function saveAccount(acc){
    try{ saveJson(ACCOUNT_KEY, acc); }catch(e){}
  }
  function clearAccount(){
    try{ localStorage.removeItem(ACCOUNT_KEY); }catch(e){}
  }

  function uid(){
    // Enkel lokal UID – ersätts av Firebase UID senare
    return "u_" + Math.random().toString(36).slice(2,10) + Date.now().toString(36);
  }

  function loadOnlineList(){
    const list = loadJson(ONLINE_KEY);
    return Array.isArray(list) ? list : [];
  }
  function saveOnlineList(list){
    try{ saveJson(ONLINE_KEY, list); }catch(e){}
  }

  function genCode(){
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let out = "";
    for(let i=0;i<6;i++) out += alphabet[Math.floor(Math.random()*alphabet.length)];
    return out;
  }

  function renderAccountStatus(){
    const el = document.getElementById('accountStatusText');
    const info = document.getElementById('authInfoText');
    const a = loadAccount();
    const txt = a ? `Inloggad som: <strong>${escapeHtml(a.name||'Spelare')}</strong>${a.avatar ? ` <span aria-hidden="true">${escapeHtml(a.avatar)}</span>` : ''}` : 'Inte inloggad.';
    if(el) el.innerHTML = txt;
    if(info) info.innerHTML = a ? `UID (lokal): <code>${escapeHtml(a.uid)}</code>` : 'Skapa ett lokalt konto nu. Sen byter vi till Firebase Auth.';

    // Visa/dölj logout-knappen i spelarpopupen
    try{
      const pop = document.getElementById('playerRegisterOverlay');
      if(pop){
        const btns = pop.querySelectorAll('button');
        btns.forEach(function(b){
          if(b && b.textContent && b.textContent.trim().toLowerCase() === 'logga ut'){
            b.style.display = a ? '' : 'none';
          }
        });
      }
    }catch(e){}
  }

  function renderOnlineLists(){
    const ownedHost = document.getElementById('hubOnlineOwned');
    const joinedHost = document.getElementById('hubOnlineJoined');
    if(!ownedHost || !joinedHost) return;

    const a = loadAccount();
    const list = loadOnlineList().slice().sort((x,y)=>new Date(y.updatedAt||y.createdAt) - new Date(x.updatedAt||x.createdAt));

    const owned = a ? list.filter(t=>t && t.ownerUid === a.uid) : [];
    const joined = a ? list.filter(t=>t && t.ownerUid !== a.uid && Array.isArray(t.participants) && t.participants.includes(a.uid)) : [];

    function renderOne(host, items, emptyText){
      if(!a){
        host.innerHTML = '<em>Logga in för att se dina online-turneringar.</em>';
        return;
      }
      if(!items.length){
        host.innerHTML = `<em>${escapeHtml(emptyText)}</em>`;
        return;
      }
      host.innerHTML = items.map(t=>{
        const dt = (t.updatedAt||t.createdAt) ? new Date(t.updatedAt||t.createdAt).toLocaleString() : "";
        const badge = '<span class="pill" title="Online"><span aria-hidden="true">🌍</span> online</span>';
        return `
          <div class="item">
            <div class="meta">
              <strong>${escapeHtml(t.name||'Online-turnering')}</strong>
              <small>${escapeHtml(dt)} · Kod: <code>${escapeHtml(t.code||'')}</code></small>
            </div>
            <div class="actions">
              <button class="btn secondary" type="button" onclick="__onlineOpen('${escapeHtml(t.code||'')}')">Öppna</button>
              <button class="btn secondary" type="button" onclick="__onlineShare('${escapeHtml(t.code||'')}')">Dela kod</button>
            </div>
          </div>
        `;
      }).join('');
    }

    renderOne(ownedHost, owned, 'Inga online-turneringar ännu.');
    renderOne(joinedHost, joined, 'Inga anslutna online-turneringar ännu.');
  }

  // UI actions (exponeras globalt eftersom HTML använder onclick)
  window.openAuthOverlay = function(){
    const ov = document.getElementById('authOverlay');
    if(!ov) return;
    const a = loadAccount();
    const name = document.getElementById('authName');
    const av = document.getElementById('authAvatar');
    if(name) name.value = a ? (a.name||'') : '';
    if(av) av.value = a ? (a.avatar||'') : '';
    renderAccountStatus();
    ov.classList.remove('hidden');
  };
  window.closeAuthOverlay = function(){
    const ov = document.getElementById('authOverlay');
    if(ov) ov.classList.add('hidden');
  };
  window.saveAccountFromAuthForm = function(){
    const name = (document.getElementById('authName')?.value || '').trim();
    const avatar = (document.getElementById('authAvatar')?.value || '').trim();
    if(!name){ alert('Skriv ett namn.'); return; }
    const existing = loadAccount();
    const acc = {
      uid: existing?.uid || uid(),
      name,
      avatar,
      createdAt: existing?.createdAt || nowIso(),
      updatedAt: nowIso()
    };
    saveAccount(acc);
    renderAccountStatus();
    try{ renderOnlineLists(); }catch(e){}
    alert('Klart! Konto sparat lokalt.');
  };
  window.prefillFromSavedPlayer = function(){
    // Försök hitta en rimlig kandidat i state.players om appen redan har spelare sparade.
    try{
      const ps = (state && Array.isArray(state.players)) ? state.players : [];
      if(!ps.length){ alert('Ingen sparad spelare hittades i den aktuella turneringen.'); return; }
      const p = ps[0];
      const name = document.getElementById('authName');
      const av = document.getElementById('authAvatar');
      if(name) name.value = (p.name||'').trim();
      if(av) av.value = (p.avatar||'').trim();
    }catch(e){ alert('Kunde inte hämta spelare.'); }
  };
  window.logoutAccount = function(){
    if(!loadAccount()){ return; }
    if(!confirm('Logga ut? (Kontot tas bort lokalt i den här test-versionen)')) return;
    clearAccount();
    renderAccountStatus();
    try{ renderOnlineLists(); }catch(e){}
  };

  window.openJoinOnlineOverlay = function(){
    const ov = document.getElementById('joinOnlineOverlay');
    if(!ov) return;
    const inp = document.getElementById('joinOnlineCode');
    if(inp) inp.value = '';
    ov.classList.remove('hidden');
    setTimeout(function(){ try{ inp && inp.focus(); }catch(e){} }, 30);
  };
  window.closeJoinOnlineOverlay = function(){
    const ov = document.getElementById('joinOnlineOverlay');
    if(ov) ov.classList.add('hidden');
  };
  window.joinOnlineByCodeFromUI = function(){
    const a = loadAccount();
    if(!a){ alert('Logga in först.'); return; }
    const raw = (document.getElementById('joinOnlineCode')?.value || '').trim().toUpperCase();
    if(!raw){ alert('Skriv en kod.'); return; }
    const list = loadOnlineList();
    const t = list.find(x=>x && String(x.code||'').toUpperCase() === raw);
    if(!t){ alert('Ingen online-turnering hittades med den koden (i den här test-versionen).'); return; }
    if(!Array.isArray(t.participants)) t.participants = [];
    if(!t.participants.includes(a.uid)) t.participants.push(a.uid);
    t.updatedAt = nowIso();
    saveOnlineList(list);
    closeJoinOnlineOverlay();
    try{ renderOnlineLists(); }catch(e){}
    alert('Ansluten!');
  };

  window.createOnlineTournamentFromUI = function(){
    const a = loadAccount();
    if(!a){ alert('Logga in först.'); return; }
    const name = (prompt('Namn på online-turnering:', 'Ny online-turnering') || '').trim();
    if(!name) return;
    const list = loadOnlineList();
    let code = genCode();
    while(list.some(x=>x && x.code === code)) code = genCode();
    const t = {
      code,
      name,
      ownerUid: a.uid,
      participants: [a.uid],
      createdAt: nowIso(),
      updatedAt: nowIso()
    };
    list.push(t);
    saveOnlineList(list);
    try{ renderOnlineLists(); }catch(e){}
    alert('Online-turnering skapad! Kod: ' + code);
  };

  window.__onlineOpen = function(code){
    alert('"Öppna" för online är bara en stomme just nu.\nKod: ' + code + '\n\nNästa steg: koppla turneringen till Firestore och synka matcher/spelare.');
  };
  window.__onlineShare = function(code){
    try{
      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(String(code||''));
        alert('Koden kopierad: ' + code);
        return;
      }
    }catch(e){}
    prompt('Kopiera koden:', String(code||''));
  };

  // Exponera en global hjälpfunktion så kärnlogiken (saveState/autosave) kan
  // uppdatera turneringsbiblioteket när man spelar en sparad turnering.
  // Utan detta kan matcher se ut att "inte sparas" när man öppnar turneringen igen.
  function persistCurrentToLibrary(){
    try{
      if(!state || !state.tournamentId) return;
      const id = String(state.tournamentId);
      const key = LIB_PREFIX + id;
      const existing = loadJson(key) || null;
      const createdAt = (existing && existing.createdAt) || state.createdAt || nowIso();
      const name = (state.tournamentName || (existing && existing.name) || "Turnering");
      const wrapper = {
        id: id,
        name: name,
        createdAt: createdAt,
        updatedAt: nowIso(),
        state: state
      };
      saveJson(key, wrapper);
    }catch(e){}
  }

  window.__hubPersistCurrent = function(){
    persistCurrentToLibrary();
  };

  function ensureInitialState(){
    if(INITIAL_STATE) return;
    try{
      // capture the current in-memory state as default template
      INITIAL_STATE = JSON.parse(JSON.stringify(state));
    }catch(e){
      INITIAL_STATE = { step:1, mode:"single", format:"round_robin", entryMode:"import", players:[], rules:{game:"301",inRule:"single",outRule:"single",legsMode:"single"} };
    }
  }

  function listTournamentKeys(){
    try{
      return Object.keys(localStorage).filter(k=>k.startsWith(LIB_PREFIX));
    }catch(e){ return []; }
  }

  function importLegacyIfNeeded(){
    try{
      const hasAny = listTournamentKeys().length > 0;
      if(hasAny) return;
      const legacy = loadJson(LEGACY_KEY) || null;
      if(!legacy) return;

      const id = "legacy_" + Date.now();
      const wrapper = {
        id,
        name: "Tidigare turnering",
        createdAt: nowIso(),
        updatedAt: nowIso(),
        state: legacy
      };
      saveJson(LIB_PREFIX + id, wrapper);
      // set tournamentId on loaded legacy state to keep future saves in library
      try{
        legacy.tournamentId = id;
        legacy.tournamentName = wrapper.name;
        legacy.createdAt = wrapper.createdAt;
      }catch(e){}
      saveJson(LEGACY_KEY, legacy);
    }catch(e){}
  }

  function hubRender(){
    const host = document.getElementById("hubList");
    const keys = listTournamentKeys();
    if(!keys.length){
      host.innerHTML = "<em>Inga sparade turneringar ännu.</em>";
      return;
    }
    const items = keys.map(k=>loadJson(k)).filter(Boolean).sort((a,b)=>{
      return new Date(b.updatedAt||b.createdAt) - new Date(a.updatedAt||a.createdAt);
    });

    host.innerHTML = items.map(t=>{
      const dt = (t.updatedAt||t.createdAt) ? new Date(t.updatedAt||t.createdAt).toLocaleString() : "";
      return `
        <div class="item">
          <div class="meta">
            <button class="linklike" type="button" onclick="__hubRename('${t.id}')" style="font-weight:800;background:none;border:none;padding:0;margin:0;text-align:left;cursor:pointer;text-decoration:underline">${escapeHtml(t.name||"Namnlös turnering")}</button>
            <small>${escapeHtml(dt)}</small>
          </div>
          <div class="actions">
            <button class="btn secondary" type="button" onclick="__hubOpen('${t.id}')">Öppna</button>
            <button class="btn secondary" type="button" onclick="__hubRename('${t.id}')">Byt namn</button>
            <button class="btn secondary" type="button" onclick="__hubDelete('${t.id}')">Radera</button>
          </div>
        </div>
      `;
    }).join("");

    // Online + konto UI
    try{ renderAccountStatus(); }catch(e){}
    try{ renderOnlineLists(); }catch(e){}
  }

  function startRender(){
    const host = document.getElementById("startRecentList");
    if(!host) return;
    const keys = listTournamentKeys();
    if(!keys.length){
      host.innerHTML = "<em>Inga sparade turneringar ännu.</em>";
      return;
    }
    const items = keys.map(k=>loadJson(k)).filter(Boolean).sort((a,b)=>{
      return new Date(b.updatedAt||b.createdAt) - new Date(a.updatedAt||a.createdAt);
    });
    host.innerHTML = items.map(t=>{
      const dt = (t.updatedAt||t.createdAt) ? new Date(t.updatedAt||t.createdAt).toLocaleString() : "";
      return `
        <div class="item">
          <div class="meta">
            <strong>${escapeHtml(t.name||"Namnlös turnering")}</strong>
            <small>${escapeHtml(dt)}</small>
          </div>
          <div class="actions">
            <button class="btn secondary" type="button" onclick="__hubOpen('${t.id}')">Öppna</button>
            <button class="btn secondary" type="button" onclick="__hubRename('${t.id}')">Byt namn</button>
          </div>
        </div>
      `;
    }).join("");
  }



  // Exponera minimala helpers globalt så att andra delar av appen kan navigera hit
  // utan att trigga back-guard (ingen history/hash används).
  window.__showLocalHub = function(){
    try{
      show("localHubScreen");
      try{ importLegacyIfNeeded(); }catch(e){}
      try{ hubRender(); }catch(e){}
    }catch(e){}
  };
  window.__showStartScreen = function(){
    try{ show("startScreen"); }catch(e){}
    try{ startRender(); }catch(e){}
  };

  function escapeHtml(s){
    return String(s||"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  window.__hubOpen = function(id){
    const wrap = loadJson(LIB_PREFIX + id);
    if(!wrap || !wrap.state) return;
    try{
      state = wrap.state;
      state.tournamentId = wrap.id;
      state.tournamentName = wrap.name || state.tournamentName || "Turnering";
      state.createdAt = wrap.createdAt || state.createdAt || nowIso();
      state.updatedAt = nowIso();
      // persist back to legacy key for backward compatibility with v98 core
      saveJson(LEGACY_KEY, state);
      // also update autosave pointer
      try{ autosaveTournament(); }catch(e){}
      hideAll();
      try{ renderAll(); }catch(e){}
    }catch(e){}
  };

  
  window.__hubRename = function(id){
    try{
      const key = LIB_PREFIX + id;
      const wrap = loadJson(key);
      if(!wrap) return;
      const current = wrap.name || "Ny turnering";
      const name = prompt("Nytt namn på turneringen:", current);
      if(name === null) return;
      const trimmed = name.trim();
      if(!trimmed) return;
      wrap.name = trimmed;
      wrap.updatedAt = nowIso();
      saveJson(key, wrap);

      // Om det är den aktiva turneringen, uppdatera även state
      if(state && state.tournamentId === id){
        state.tournamentName = trimmed;
        try{ autosaveTournament(); }catch(e){}
      }

      hubRender();
    }catch(e){ console.error(e); }
  };
window.__hubDelete = function(id){
    if(!confirm("Radera turneringen?")) return;
    try{ localStorage.removeItem(LIB_PREFIX + id); }catch(e){}
    hubRender();
  };

  function newTournament(){
    ensureInitialState();
    const namePrompt = prompt("Namn på turneringen (t.ex. Fredagsturnering):", "Ny turnering");
    if(namePrompt===null){ return; }
    const name = (String(namePrompt||"").trim() || "Ny turnering");
    const id = "t_" + Date.now();
    state = JSON.parse(JSON.stringify(INITIAL_STATE));
    state.tournamentId = id;
    state.tournamentName = name.trim() || "Ny turnering";
    state.createdAt = nowIso();
    state.updatedAt = nowIso();
    try{ state._importedTournament = false; }catch(e){}
    try{ state.importedPlayers = []; }catch(e){}


    
    // Rensa spelarfält i UI + state så en ny turnering alltid är helt tom
    try{
      if(state){ state.players = []; }
      var taPlayers = document.getElementById("players"); if(taPlayers) taPlayers.value = "";
      var taSpotify = document.getElementById("spotifyLinks"); if(taSpotify) taSpotify.value = "";
      var taDarts = document.getElementById("darts"); if(taDarts) taDarts.value = "";
      var selSaved = document.getElementById("savedPlayerSelect"); if(selSaved) selSaved.value = "";
      var selSavedTeam = document.getElementById("savedTeamSelect"); if(selSavedTeam) selSavedTeam.value = "";
      var nm = document.getElementById("kName"); if(nm) nm.value = "";
      var sp = document.getElementById("kSpotify"); if(sp) sp.value = "";
      var da = document.getElementById("kDarts"); if(da) da.value = "";
    }catch(e){}

// Rensa ev. valda/tillagda spelare från tidigare turnering (”spökanvändare”)
    try{
      if(window.kioskSelectedPlayers) window.kioskSelectedPlayers = [];
      if(window.kioskSelectedIds) window.kioskSelectedIds = [];
      if(window.kioskTeam) window.kioskTeam = [];
      if(window.teamSelection) window.teamSelection = [];
      if(window.selectedPlayers) window.selectedPlayers = [];
      var kList = document.getElementById("kioskTeamList");
      if(kList) kList.innerHTML = "";
    }catch(e){}


    // Save immediately
    saveJson(LIB_PREFIX + id, { id, name: state.tournamentName, createdAt: state.createdAt, updatedAt: state.updatedAt, state });
    saveJson(LEGACY_KEY, state);
    try{ autosaveTournament(); }catch(e){}
    hideAll();
    try{ renderAll(); }catch(e){}
  }

  function resumeLatest(){
    // Prefer autosave
    try{
      const ok = (typeof loadAutosaveTournament === "function") ? loadAutosaveTournament() : false;
      if(ok){
        // ensure has id
        if(!state.tournamentId){
          importLegacyIfNeeded();
          // try attach legacy id if created
          const keys = listTournamentKeys();
          const latest = keys.map(k=>loadJson(k)).filter(Boolean).sort((a,b)=>new Date(b.updatedAt||b.createdAt)-new Date(a.updatedAt||a.createdAt))[0];
          if(latest){
            state.tournamentId = latest.id;
            state.tournamentName = latest.name || state.tournamentName;
          }
        }
        hideAll();
        try{ renderAll(); }catch(e){}
        return;
      }
    }catch(e){}

    // If no autosave, open hub list and let user choose
    show("localHubScreen");
    hubRender();
  }

  function mirrorToLibrary(){
    try{
      if(!state) return;
      if(!state.tournamentId) return;
      const id = state.tournamentId;
      const key = LIB_PREFIX + id;
      const prev = loadJson(key) || { id, createdAt: state.createdAt || nowIso() };
      const name = state.tournamentName || prev.name || "Turnering";
      const wrap = {
        id,
        name,
        createdAt: prev.createdAt || state.createdAt || nowIso(),
        updatedAt: nowIso(),
        state: state
      };
      saveJson(key, wrap);
    }catch(e){}
  }

  // Wrap saveState + autosaveTournament to always mirror to library
  const _saveState = window.saveState;
  window.saveState = function(){
    try{ if(typeof _saveState === "function") _saveState(); }catch(e){}
    mirrorToLibrary();
  };
  const _autosave = window.autosaveTournament;
  window.autosaveTournament = function(){
    try{ if(typeof _autosave === "function") _autosave(); }catch(e){}
    mirrorToLibrary();
  };

  document.addEventListener("DOMContentLoaded", function(){
    ensureInitialState();
    importLegacyIfNeeded();


    var __btnOnline = document.getElementById("btnStartOnline");
    if(__btnOnline){
      __btnOnline.addEventListener("click", function(){
        alert("Online kommer senare. Just nu fungerar bara lokala turneringar.");
      });
    }

    // Hub-knappar (bind bara en gang)
    (function(){
      var b = document.getElementById("btnHubNew");
      if(b && !b.dataset.boundNewTournament){
        b.dataset.boundNewTournament = "1";
        b.addEventListener("click", function(ev){
          try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){}
          newTournament();
        });
      }
    })();

    // Splash (första sidan): tryck eller vänta för att gå vidare till Turneringar
    var splash = document.getElementById("startScreen");
    function goHub(){
      try{ show("localHubScreen"); }catch(e){}
      try{ hubRender(); }catch(e){}
    }
    if(splash){
      splash.addEventListener('click', function(){ goHub(); });
      // kort "blixtra till" innan hubben visas
      setTimeout(function(){
        // visa hubben om användaren inte redan gått vidare
        if(document.getElementById('startScreen') && document.getElementById('startScreen').classList.contains('active')){
          goHub();
        }
      }, 650);
    }
    // Hub-knappar
    var hubImp = document.getElementById('hubImportJson');
    if(hubImp) hubImp.addEventListener('change', function(){
      try{ if(this.files && this.files[0]) autosaveHandleImportJsonFile(this.files[0]); }catch(e){}
      this.value='';
      try{ hubRender(); }catch(e){}
    });

    var hubPlayers = document.getElementById('btnHubPlayers');
    if(hubPlayers) hubPlayers.addEventListener('click', function(){
      try{ openPlayerRegisterPopup(); }catch(e){}
    });

    // Online-stomme: skapa / anslut
    var btnCreateOnline = document.getElementById('btnCreateOnline');
    if(btnCreateOnline) btnCreateOnline.addEventListener('click', function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){}
      try{ createOnlineTournamentFromUI(); }catch(e){}
    });
    var btnJoinOnline = document.getElementById('btnJoinOnline');
    if(btnJoinOnline) btnJoinOnline.addEventListener('click', function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){}
      try{ openJoinOnlineOverlay(); }catch(e){}
    });

    var hubShowApp = document.getElementById('btnHubShowApp');
    if(hubShowApp) hubShowApp.addEventListener('click', function(){
      try{ hideAll(); }catch(e){}
      try{ state._playerRegisterOnly = false; }catch(e){}
      try{ state.step = 1; saveState(); }catch(e){}
      try{ renderAll(); }catch(e){}
      try{ window.scrollTo(0,0); }catch(e){}
    });
// Start i splash
    show("startScreen");
    try{ importLegacyIfNeeded(); }catch(e){}
    try{ startRender(); }catch(e){}
});
})();
</script>


<script>
(function(){
  function addBackButton(){
    // (v5) Inaktiverad: Start-knappen finns nu i stegraden längst ned.
    return;
    try{
      var step1 = document.getElementById("step1");
      if(!step1) return;

      // Avoid duplicates
      if(step1.querySelector(".btn-back-setup")) return;

      var header = step1.querySelector("h2") || step1.querySelector("h1") || step1.firstElementChild;
      if(!header) header = step1;

      var bar = document.createElement("div");
      bar.className = "row btn-back-setup";
      bar.style.gap = "10px";
      bar.style.marginTop = "12px";

      // Quick: go to Turneringar (screen before Upplägg)
      var btnLocal = document.createElement("button");
      btnLocal.textContent = "Start";
      btnLocal.className = "btn secondary";
      btnLocal.type = "button";
      btnLocal.onclick = function(){
        try{
          if(typeof hubRender === "function") hubRender();
        }catch(e){}
        var hub = document.getElementById("localHubScreen");
        var start = document.getElementById("startScreen");
        if(hub){
          hub.classList.add("active");
          hub.setAttribute("aria-hidden","false");
        }
        if(start){
          start.classList.remove("active");
          start.setAttribute("aria-hidden","true");
        }
      };

      // Quick: go to första sidan (Dart-turneringar)
      var btnHome = document.createElement("button");
      btnHome.textContent = "Hem";
      btnHome.className = "btn secondary";
      btnHome.type = "button";
      btnHome.onclick = function(){
        var hub = document.getElementById("localHubScreen");
        var start = document.getElementById("startScreen");
        if(start){
          start.classList.add("active");
          start.setAttribute("aria-hidden","false");
        }
        if(hub){
          hub.classList.remove("active");
          hub.setAttribute("aria-hidden","true");
        }
      };

      bar.appendChild(btnLocal);
      bar.appendChild(btnHome);

      // Place near the top of Upplägg instead of at the very bottom
      if(header && header.parentNode){
        header.parentNode.insertBefore(bar, header.nextSibling);
      }else{
        step1.insertBefore(bar, step1.firstChild);
      }
    }catch(e){}
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", addBackButton);
  }else{
    addBackButton();
  }
})();
</script>


<!-- === v98 LocalHub patch v3: show added players on load by syncing textareas from state.players === -->
<script>
(function(){
  function syncAddedToInputs(){
    try{
      if(!window.state) return;
      // Only sync when on step 3 (Spelare) or when player UI exists
      var playersTA = document.getElementById("players");
      var teamNames = document.getElementById("teamNames");

      // Single mode: fill #players from state.players if empty
      if(playersTA && (!playersTA.value || !playersTA.value.trim())){
        if(Array.isArray(state.players) && state.players.length){
          var names = state.players.filter(p=>p && p.type!=="team").map(p=>p.name||"").filter(Boolean);
          if(names.length){
            playersTA.value = names.join("\n");
          }
        }
      }

      // Team mode: fill team fields from state.players if empty
      if(teamNames && (!teamNames.value || !teamNames.value.trim())){
        if(Array.isArray(state.players) && state.players.length){
          var teams = state.players.filter(p=>p && p.type==="team");
          if(teams.length){
            var m1 = document.getElementById("teamMember1");
            var m2 = document.getElementById("teamMember2");
            teamNames.value = teams.map(t=>t.teamName||"").join("\n");
            if(m1) m1.value = teams.map(t=>t.member1||"").join("\n");
            if(m2) m2.value = teams.map(t=>t.member2||"").join("\n");
          }
        }
      }

      // Re-render the "Tillagda" list
      try{ if(typeof renderKioskList === "function") renderKioskList(); }catch(e){}
    }catch(e){}
  }

  // Hook into step navigation
  var _goStep = window.goStep;
  window.goStep = function(n){
    if(typeof _goStep === "function") _goStep(n);
    if(Number(n) === 3){
      syncAddedToInputs();
    }
  };

  // Also run after opening a tournament (renderAll is called)
  var _renderAll = window.renderAll;
  window.renderAll = function(){
    if(typeof _renderAll === "function") _renderAll();
    // If we're on players step after load, sync
    try{
      var nums = (typeof getStepNums === "function") ? getStepNums() : null;
      var stepPlayers = 3;
      if(nums && nums.players) stepPlayers = nums.players;
      if(state && Number(state.step) === Number(stepPlayers)){
        syncAddedToInputs();
      }
    }catch(e){}
  };

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", syncAddedToInputs);
  }else{
    syncAddedToInputs();
  }
})();
</script>


<!-- === v98 LocalHub patch v4: render Tillagda from state.players even if textarea cleared by kiosk mode === -->
<script>
(function(){
  function ensurePlayersTextareaFromState(){
    try{
      var ta = document.getElementById("players");
      if(!ta) return;
      var lines = (ta.value||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      if(lines.length) return;
      if(Array.isArray(state.players) && state.players.length){
        var names = state.players.filter(p=>p && p.type!=="team").map(p=>p.name||"").filter(Boolean);
        if(names.length) ta.value = names.join("\n");
      }
    }catch(e){}
  }

  // Patch renderKioskList so it falls back to state.players if textarea is empty
  var _renderKioskList = window.renderKioskList;
  window.renderKioskList = function(){
    try{
      // If single mode and textarea empty but state.players exists, sync it first
      if(window.state && state.mode!=='team'){
        ensurePlayersTextareaFromState();
      }
    }catch(e){}
    try{ return (typeof _renderKioskList === "function") ? _renderKioskList() : undefined; }
    finally{}
  };

  // When entering step 3, force a sync + list render after renderPlayersStep potentially toggled UI
  var _goStep = window.goStep;
  window.goStep = function(n){
    if(typeof _goStep === "function") _goStep(n);
    if(Number(n) === 3){
      try{
        // run after current call stack so applyEntryUI has finished
        setTimeout(function(){
          ensurePlayersTextareaFromState();
          try{ if(typeof window.renderKioskList==="function") window.renderKioskList(); }catch(e){}
        }, 0);
      }catch(e){}
    }
  };

  // Also after renderAll if we land on step3 (e.g., after loading tournament)
  var _renderAll = window.renderAll;
  window.renderAll = function(){
    var r = (typeof _renderAll === "function") ? _renderAll() : undefined;
    try{
      if(window.state && Number(state.step) === 3){
        setTimeout(function(){
          ensurePlayersTextareaFromState();
          try{ if(typeof window.renderKioskList==="function") window.renderKioskList(); }catch(e){}
        }, 0);
      }
    }catch(e){}
    return r;
  };

})();
</script>


<!-- === Auto-resume v6: återgå automatiskt där du slutade när du kommer tillbaka från t.ex. Spotify === -->
<script>
(function(){
  function showStart(){
    try{
      var start = document.getElementById("startScreen");
      var hub   = document.getElementById("localHubScreen");
      if(start){ start.classList.add("active"); start.setAttribute("aria-hidden","false"); }
      if(hub){ hub.classList.remove("active"); hub.setAttribute("aria-hidden","true"); }
    }catch(e){}
  }

  function hideEntryOverlays(){
    try{
      var start = document.getElementById("startScreen");
      var hub   = document.getElementById("localHubScreen");
      if(start){ start.classList.remove("active"); start.setAttribute("aria-hidden","true"); }
      if(hub){ hub.classList.remove("active"); hub.setAttribute("aria-hidden","true"); }
    }catch(e){}
  }

  function hasProgress(){
    try{
      if(!window.state) return false;
      if(state.tournamentId) return true;
      if(state.tid || state.id) return true;
      if(Array.isArray(state.players) && state.players.length) return true;
      if(Array.isArray(state.matches) && state.matches.length) return true;
      if(state.step && Number(state.step) > 1) return true;
      return false;
    }catch(e){ return false; }
  }

  function tryResume(reason){
    try{
      if(typeof ensureInitialState === "function") ensureInitialState();
      if(typeof importLegacyIfNeeded === "function") importLegacyIfNeeded();
    }catch(e){}

    try{
      var ok = (typeof loadAutosaveTournament === "function") ? loadAutosaveTournament() : false;
      if(ok && hasProgress()){
        hideEntryOverlays();
        try{ if(typeof renderAll === "function") renderAll(); }catch(e){}
        return true;
      }
    }catch(e){}
    return false;
  }

  // Vid första start: försök återgå direkt, annars visa start.
  function onBoot(){
    if(!tryResume("boot")) showStart();
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", onBoot);
  }else{
    onBoot();
  }

  // När man kommer tillbaka från en annan app (Spotify etc.)
  window.addEventListener("pageshow", function(){ tryResume("pageshow"); });
  document.addEventListener("visibilitychange", function(){
    if(document.visibilityState === "visible") tryResume("visible");
  });
})();
</script>


<!-- === Patch v6: (A) players list sync per tournamentId, (B) stronger playoffs seeding/rebuild === -->
<script>
(function(){
  // --- A) Players tab: avoid showing previous tournament's "Tillagda" ---
  var __lastTidForPlayersUI = null;

  function getTid(){
    try{ return (window.state && (state.tid || state.tournamentId || state.id)) ? (state.tid || state.tournamentId || state.id) : null; }catch(e){ return null; }
  }

  function syncPlayersUI(force){
    try{
      if(!window.state) return;
      var tid = getTid();
      if(force || (tid && tid !== __lastTidForPlayersUI)){
        __lastTidForPlayersUI = tid;

        // Clear inputs first to avoid mixing tournaments
        var ta = document.getElementById("players");
        if(ta) ta.value = "";

        var teamNames = document.getElementById("teamNames");
        var m1 = document.getElementById("teamMember1");
        var m2 = document.getElementById("teamMember2");
        if(teamNames) teamNames.value = "";
        if(m1) m1.value = "";
        if(m2) m2.value = "";

        // Fill from state.players
        if(Array.isArray(state.players) && state.players.length){
          if(state.mode === "team"){
            var teams = state.players.filter(p=>p && p.type==="team");
            if(teams.length){
              if(teamNames) teamNames.value = teams.map(t=>t.teamName||"").filter(Boolean).join("\n");
              if(m1) m1.value = teams.map(t=>t.member1||"").filter(Boolean).join("\n");
              if(m2) m2.value = teams.map(t=>t.member2||"").filter(Boolean).join("\n");
            }
          }else{
            var names = state.players.filter(p=>p && p.type!=="team").map(p=>p.name||"").filter(Boolean);
            if(ta && names.length) ta.value = names.join("\n");
          }
        }
      }

      // Render "Tillagda"
      try{ if(typeof window.renderKioskList === "function") window.renderKioskList(); }catch(e){}
    }catch(e){}
  }

  // Hook into tournament open (our hub uses openTournamentById)
  var _openTournamentById = window.openTournamentById;
  window.openTournamentById = function(id){
    var r = (typeof _openTournamentById === "function") ? _openTournamentById(id) : undefined;
    try{
      // After load + render, sync player UI for this tournament
      setTimeout(function(){ syncPlayersUI(true); }, 0);
    }catch(e){}
    return r;
  };

  // Also when resuming latest
  var _resumeLatest = window.resumeLatest;
  window.resumeLatest = function(){
    var r = (typeof _resumeLatest === "function") ? _resumeLatest() : undefined;
    try{ setTimeout(function(){ syncPlayersUI(true); }, 0); }catch(e){}
    return r;
  };

  // When entering players step, sync based on tournamentId
  var _goStep = window.goStep;
  window.goStep = function(n){
    if(typeof _goStep === "function") _goStep(n);
    if(Number(n) === 3){
      try{ setTimeout(function(){ syncPlayersUI(false); }, 0); }catch(e){}
    }
  };

  // --- B) Slutspel: seed/rebuild robustly ---
  function safeTop2FromGroup(letter){
    try{
      var ids = (state.groups && state.groups[letter]) ? (state.groups[letter] || []) : [];
      // If standings can't be computed (e.g., weird data), fallback to current group order
      var st = [];
      try{ st = computeStandings(ids, state.matches, function(m){ return m.group===letter; }); }catch(e){ st = []; }
      if(!st || st.length===0){
        return (ids || []).slice(0,2);
      }
      return st.slice(0,2).map(x=>x.pid);
    }catch(e){
      try{ return ((state.groups && state.groups[letter]) ? state.groups[letter] : []).slice(0,2); }catch(_){ return ["",""]; }
    }
  }

  // Wrap buildPlayoffsPreview to use safe top2 fallback
  var _buildPlayoffsPreview = window.buildPlayoffsPreview;
  window.buildPlayoffsPreview = function(){
    // Temporarily override top2FromGroup during preview build
    var _top2 = window.top2FromGroup;
    window.top2FromGroup = safeTop2FromGroup;
    try{
      return (typeof _buildPlayoffsPreview === "function") ? _buildPlayoffsPreview() : null;
    }finally{
      window.top2FromGroup = _top2;
    }
  };

  // Rebuild playoffs if started but missing participants (empty aId/bId)
  function playoffsHasHoles(){
    try{
      if(!state.playoffs || !state.playoffs.matches || !state.playoffs.matches.length) return true;
      var ms = state.playoffs.matches;

      // "Hål" ska bara betyda att första rundan saknar seedade deltagare.
      // I grupp/serie+slutspel är det normalt att semifinal/final saknar deltagare innan föregående runda är spelad.
      var hasQF = false;
      for(var i=0;i<ms.length;i++){
        var m = ms[i];
        if(m && m.id==="po_qf1"){ hasQF = true; break; }
      }

      if(hasQF){
        var qfIds = ["po_qf1","po_qf2","po_qf3","po_qf4"];
        for(var k=0;k<qfIds.length;k++){
          var id = qfIds[k];
          var mm = ms.find(function(x){ return x && x.id===id; });
          if(mm && (!mm.aId || !mm.bId)) return true;
        }
        return false;
      }else{
        // Första rundan är semifinaler (t.ex. 2 grupper / topp-4 från serie)
        var sfIds = ["po_sf1","po_sf2"];
        for(var k2=0;k2<sfIds.length;k2++){
          var id2 = sfIds[k2];
          var mm2 = ms.find(function(x){ return x && x.id===id2; });
          if(mm2 && (!mm2.aId || !mm2.bId)) return true;
        }
        return false;
      }
    }catch(e){ return true; }
  }

  var _ensurePlayoffs = window.ensurePlayoffs;
  window.ensurePlayoffs = function(){
    try{
      if(state && state.format && (state.format==="group_playoffs" || state.format==="round_robin_playoffs")){
        // If already started but has holes -> rebuild
        if(state.playoffs && state.playoffs.started && playoffsHasHoles()){
          state.playoffs = null;
        }
      }
    }catch(e){}
    return (typeof _ensurePlayoffs === "function") ? _ensurePlayoffs() : false;
  };

  // When entering playoffs step, if started and has holes -> rebuild then render
  var _renderPlayoffs = window.renderPlayoffs;
  window.renderPlayoffs = function(){
    try{
      if(state && (state.format==="group_playoffs" || state.format==="round_robin_playoffs")){
        if(state.playoffs && state.playoffs.started && playoffsHasHoles()){
          state.playoffs = null;
          try{ if(typeof window.ensurePlayoffs==="function") window.ensurePlayoffs(); }catch(e){}
        }
      }
    }catch(e){}
    return (typeof _renderPlayoffs === "function") ? _renderPlayoffs() : undefined;
  };

})();
</script>


<!-- === Patch v7: Slutspel robust seeding + debug seeds === -->
<script>
(function(){

  // ----- Safe standings (avoid crashes, handle partial results) -----
  var __origComputeStandings = window.computeStandings;
  window.computeStandings = function(playerIds, matches, filterFn){
    try{
      // Try original first
      if(typeof __origComputeStandings === "function"){
        return __origComputeStandings(playerIds, matches, filterFn);
      }
    }catch(e){
      // fall through to safe impl
    }

    // Safe minimal implementation
    var ids = (playerIds||[]).slice();
    var st = {};
    ids.forEach(function(pid){
      st[pid] = { pid: pid, played:0, w:0, l:0, pts:0, legsWon:0, legsLost:0,
                 avgSum:0, avgCount:0, f9Sum:0, f9Count:0, coSum:0, coCount:0 };
    });

    (matches||[]).forEach(function(m){
      try{
        if(filterFn && !filterFn(m)) return;
        if(!m || !m.aId || !m.bId) return;
        if(!st[m.aId] || !st[m.bId]) return; // ignore foreign matches
        // Only count decided matches
        var winner = (m.winnerId || m.winner || "");
        if(!winner) return;

        st[m.aId].played += 1;
        st[m.bId].played += 1;

        // legs
        var la = parseInt(m.legsA,10); if(isNaN(la)) la = 0;
        var lb = parseInt(m.legsB,10); if(isNaN(lb)) lb = 0;
        st[m.aId].legsWon += la; st[m.aId].legsLost += lb;
        st[m.bId].legsWon += lb; st[m.bId].legsLost += la;

        if(winner === m.aId){
          st[m.aId].w += 1; st[m.bId].l += 1; st[m.aId].pts += 2;
        }else if(winner === m.bId){
          st[m.bId].w += 1; st[m.aId].l += 1; st[m.bId].pts += 2;
        }

        // averages / f9 / co if present
        function addNum(obj, keySum, keyCnt, v){
          var x = parseFloat(v);
          if(v!=="" && !isNaN(x)){ obj[keySum]+=x; obj[keyCnt]+=1; }
        }
        addNum(st[m.aId], "avgSum","avgCount", m.avgA);
        addNum(st[m.bId], "avgSum","avgCount", m.avgB);
        addNum(st[m.aId], "f9Sum","f9Count", m.f9A);
        addNum(st[m.bId], "f9Sum","f9Count", m.f9B);
        addNum(st[m.aId], "coSum","coCount", m.coA);
        addNum(st[m.bId], "coSum","coCount", m.coB);

      }catch(e){}
    });

    var arr = ids.map(function(pid){
      var o = st[pid];
      o.avg = o.avgCount ? (o.avgSum/o.avgCount) : 0;
      o.f9 = o.f9Count ? (o.f9Sum/o.f9Count) : 0;
      o.co = o.coCount ? (o.coSum/o.coCount) : 0;
      o.diff = (o.legsWon - o.legsLost);
      return o;
    });

    arr.sort(function(a,b){
      if(b.pts !== a.pts) return b.pts - a.pts;
      if(b.diff !== a.diff) return b.diff - a.diff;
      if(b.legsWon !== a.legsWon) return b.legsWon - a.legsWon;
      if(b.avg !== a.avg) return b.avg - a.avg;
      return (a.pid||"").localeCompare(b.pid||"");
    });

    return arr;
  };

  // ----- Safe top2FromGroup (never empty) -----
  window.top2FromGroup = function(groupLetter){
    try{
      var ids = (window.state && state.groups && state.groups[groupLetter]) ? (state.groups[groupLetter]||[]) : [];
      if(!ids || ids.length===0) return ["",""];
      var st = [];
      try{
        st = window.computeStandings(ids, state.matches, function(m){ return m && m.group===groupLetter; });
      }catch(e){ st = []; }
      if(!st || st.length===0){
        return ids.slice(0,2);
      }
      var top = st.slice(0,2).map(function(x){ return x && x.pid ? x.pid : ""; });
      // if still empty, fallback to ids
      if(!top[0]) top[0] = ids[0] || "";
      if(!top[1]) top[1] = ids[1] || "";
      return top;
    }catch(e){
      try{ return ((state.groups && state.groups[groupLetter]) ? state.groups[groupLetter] : []).slice(0,2); }catch(_){ return ["",""]; }
    }
  };

  // ----- EnsurePlayoffs: rebuild if preview is empty/holes -----
  var __origEnsurePlayoffs = window.ensurePlayoffs;
  window.ensurePlayoffs = function(){
    try{
      if(state && state.playoffs && state.playoffs.matches && state.playoffs.matches.length){
        // ok
      }else{
        // if started but empty -> wipe
        if(state && state.playoffs && state.playoffs.started){
          state.playoffs = null;
        }
      }
    }catch(e){}
    if(typeof __origEnsurePlayoffs === "function") return __origEnsurePlayoffs();
    return false;
  };

  // ----- Debug: show seeds A1/A2/B1/B2 + preview length on Slutspel -----
  function setPlayoffsDebug(){
    try{
      var box = document.getElementById("tourneySummary");
      if(!box) return;
      if(!window.state || !state.groups) return;
      var A = top2FromGroup("A");
      var B = top2FromGroup("B");
      function nm(id){ try{ return playerName(id) || "—"; }catch(e){ return "—"; } }
      var preview = null;
      try{ preview = buildPlayoffsPreview(); }catch(e){ preview = null; }
      var len = (preview && preview.length) ? preview.length : 0;
      box.innerHTML = '<div class="hint" style="margin:0">'
        + '<span class="pill" style="display:inline-block;margin-right:8px">A1: '+escapeHtml(nm(A[0]))+'</span>'
        + '<span class="pill" style="display:inline-block;margin-right:8px">A2: '+escapeHtml(nm(A[1]))+'</span>'
        + '<span class="pill" style="display:inline-block;margin-right:8px">B1: '+escapeHtml(nm(B[0]))+'</span>'
        + '<span class="pill" style="display:inline-block;margin-right:8px">B2: '+escapeHtml(nm(B[1]))+'</span>'
        + '<span class="pill" style="display:inline-block">preview: '+len+'</span>'
        + '</div>';
    }catch(e){}
  }

  var __origRenderPlayoffs = window.renderPlayoffs;
  window.renderPlayoffs = function(){
    var r = (typeof __origRenderPlayoffs === "function") ? __origRenderPlayoffs() : undefined;
    setTimeout(setPlayoffsDebug, 0);
    return r;
  };

})();

/*** PATCH v11: robust grupp->slutspel seedning (top2FromGroup) ***/
(function(){
  function uniq(arr){
    var out=[], seen={};
    (arr||[]).forEach(function(x){
      if(!x) return;
      var k = String(x);
      if(seen[k]) return;
      seen[k]=1; out.push(x);
    });
    return out;
  }

  // Override top2FromGroup so it ALWAYS finds two spelare om gruppen finns.
  window.top2FromGroup = function(groupLetter){
    groupLetter = (groupLetter||"").toString().trim();

    // 1) Försök med state.groups[letter]
    var ids = [];
    try{
      var g = state && state.groups ? state.groups[groupLetter] : null;
      if(Array.isArray(g)){
        ids = g.map(function(x){
          if(!x) return "";
          if(typeof x === "string") return x;
          if(typeof x === "number") return String(x);
          if(typeof x === "object" && x.id) return String(x.id);
          return "";
        }).filter(Boolean);
      }
    }catch(e){}

    // 2) Fallback: härled från gruppmatcherna
    if(!ids || ids.length < 2){
      try{
        var ms = Array.isArray(state.matches) ? state.matches : [];
        var fromMatches = [];
        ms.forEach(function(m){
          if(!m) return;
          if(m.stage !== "Gruppspel") return;
          if((m.group||"") !== groupLetter) return;
          if(m.aId) fromMatches.push(m.aId);
          if(m.bId) fromMatches.push(m.bId);
        });
        ids = uniq(fromMatches);
      }catch(e){}
    }

    // 3) Om vi fortfarande saknar: ge tomt (låter UI visa placeholder)
    if(!ids || ids.length < 2){
      return ["",""];
    }

    // 4) Räkna tabell och returnera topp 2
    try{
      var st = computeStandings(ids, state.matches, function(m){ return m && m.stage==="Gruppspel" && (m.group||"")===groupLetter; });
      var top = (st||[]).slice(0,2).map(function(x){ return x.pid; });
      return [top[0]||ids[0]||"", top[1]||ids[1]||""];
    }catch(e){
      // Sista fallback: första två
      return [ids[0]||"", ids[1]||""];
    }
  };

  // Säkerhet: när man trycker "Starta slutspel" i group_playoffs, bygg alltid om preview precis då.
  var _ensurePlayoffs = window.ensurePlayoffs;
  window.ensurePlayoffs = function(){
    if(state && state.format==="group_playoffs"){
      // Om grupperna finns men playoffs blir tomt, tvinga preview-rebuild.
      if(state.playoffs && state.playoffs.started && Array.isArray(state.playoffs.matches) && state.playoffs.matches.length){
        return true;
      }
      var chk = canStartPlayoffsNow();
      if(!chk.ok) return false;
      var preview = buildPlayoffsPreview();
      if(!preview) return false;
      state.playoffs = { started:true, matches: preview };
      saveState();
      return true;
    }
    return _ensurePlayoffs ? _ensurePlayoffs() : false;
  };
})();

</script>


  <div style="display:flex; gap:8px; flex: 0 0 auto;">
        
        <button id="btnDismissFullHint" type="button" aria-label="Stäng" style="
            border:0; padding:10px 12px; border-radius:12px; font-weight:700;
            background:rgba(255,255,255,0.12); color:#fff; cursor:pointer;">×</button>
      </div>
    </div>
  </div>


<script>



<script>
  (function () {
    if (!('serviceWorker' in navigator)) return;
    window.addEventListener('load', function () {
      navigator.serviceWorker.register('./sw.js').catch(function (err) {
        console.warn('ServiceWorker registration failed:', err);
      });
    });
  })();
</script>


<style>
  /* Installera-app-popup (ersätter PWA-status) */
  #installOverlay{position:fixed;inset:0;z-index:99999;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.35);backdrop-filter:blur(6px)}
  #installCard{width:min(520px, calc(100vw - 28px));background:#fff;border-radius:18px;padding:18px 16px 14px 16px;
    box-shadow:0 18px 60px rgba(0,0,0,.25);border:1px solid rgba(0,0,0,.06)}
  #installCard h3{margin:0 0 6px 0;font-size:18px}
  #installCard p{margin:0 0 10px 0;line-height:1.35}
  #installCard .muted{opacity:.75;font-size:13px}
  #installCard .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  #installCard .btnPrimary{flex:1;min-width:160px}
  #installCard .btnGhost{min-width:120px}
  #installCard .x{position:absolute;right:12px;top:10px;border:none;background:transparent;font-size:20px;opacity:.55}
  #installCard .x:active{transform:scale(.98)}
  #installCard .status{margin-top:10px;font-size:13px;line-height:1.35;display:none}
  #installCard .status.show{display:block}
/* Splash */
.splashScreen{position:fixed;inset:0;z-index:99999;background:#0b2442;display:none;align-items:center;justify-content:center;flex-direction:column;padding:24px}
.splashScreen.active{display:flex}
.splashTitle{position:absolute;top:44px;left:0;right:0;text-align:center;color:#fff;font-weight:900;letter-spacing:.14em;text-transform:uppercase}
.splashCard{width:min(420px,86vw);background:rgba(255,255,255,.10);border-radius:22px;padding:18px}
.splashHint{position:absolute;top:24px;right:20px;color:rgba(255,255,255,.7);font-size:13px}
</style>

<div id="installOverlay" aria-hidden="true">
  <div id="installCard" role="dialog" aria-modal="true" style="position:relative">
    <button class="x" id="installClose" aria-label="Stäng">×</button>
    <h3>Installera appen</h3>
    <p>För bästa upplevelse: helskärm, appkänsla och snabbare åtkomst.</p>
    <p class="muted">Du kan fortsätta i webbläsaren om du vill.</p>
    <div class="row">
      <button class="btn primary btnPrimary" id="installBtn" type="button">Installera app</button>
      <button class="btn secondary btnGhost" id="installLater" type="button">Inte nu</button>
    </div>
    <div class="status" id="installStatus">
      När du har tryckt på <b>Installera</b>, vänta några sekunder – appen kan öppnas automatiskt åt dig.
      <span class="muted">Om den inte öppnas direkt: leta upp den på startskärmen/appenyn.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // Visa inte om man redan kör som installerad app
  function isStandalone(){
    return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
  }
  var overlay = document.getElementById('installOverlay');
  var card = document.getElementById('installCard');
  var btnInstall = document.getElementById('installBtn');
  var btnLater = document.getElementById('installLater');
  var btnClose = document.getElementById('installClose');
  var status = document.getElementById('installStatus');

  if(!overlay || !btnInstall) return;
  if(isStandalone()) return;

  var LS_KEY = 'install_prompt_dismissed_v1';
  var deferred = null;

  function hide(){
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden','true');
  }
  function show(){
    if(localStorage.getItem(LS_KEY)==='1') return;
    overlay.style.display = 'flex';
    overlay.setAttribute('aria-hidden','false');
    status.classList.remove('show');
    btnInstall.disabled = false;
  }

  // Stäng på klick utanför
  overlay.addEventListener('click', function(e){
    if(e.target === overlay){ hide(); }
  });
  btnLater.addEventListener('click', function(){
    localStorage.setItem(LS_KEY,'1');
    hide();
  });
  btnClose.addEventListener('click', function(){
    hide();
  });

  // Fånga webbläsarens install-event
  window.addEventListener('beforeinstallprompt', function(e){
    try{
      e.preventDefault();
      deferred = e;
      // Visa popupen så fort den är möjlig att installera
      show();
    }catch(err){}
  });

  // Installera-knappen
  btnInstall.addEventListener('click', async function(){
    if(!deferred){
      // Om webbläsaren inte erbjuder prompten (ej installbar just nu)
      status.textContent = "Installering är inte tillgänglig just nu i webbläsaren. Öppna menyn (⋮) och välj 'Installera app' / 'Lägg till på startskärmen' om alternativet finns.";
      status.classList.add('show');
      return;
    }
    try{
      btnInstall.disabled = true;
      status.classList.add('show');
      deferred.prompt();
      await deferred.userChoice.catch(function(){});
      deferred = null;
      // Vi stänger inte direkt här – vissa webbläsare visar 'Öppna' själva
    }catch(err){
      btnInstall.disabled = false;
    }
  });

  // När appen installerats: stäng och visa inte igen
  window.addEventListener('appinstalled', function(){
    try{ localStorage.setItem(LS_KEY,'1'); }catch(e){}
    hide();
  });

  // Om webbläsaren aldrig triggar beforeinstallprompt, visas ingen popup (bättre än att störa).
})();
</script>




<!-- === Serie-hubb (import/export) === -->
<section id="seriesHubScreen" class="screen" aria-hidden="true" style="display:none; padding-top:86px; padding-bottom: calc(var(--bottomnav-h) + 18px);">
  <div class="card" style="max-width:980px; margin:16px auto">
    <div class="row" style="justify-content:space-between; align-items:center; gap:10px">
      <h2 style="margin:0">Serie-hubb</h2>
      <button class="btn secondary" onclick="closeSeriesHub()">Stäng</button>
    </div>
    <div class="hint" style="margin-top:6px">
      Ladda upp exporterade deltävlingar (JSON) och bygg en serietabell. Om namnen inte matchar säkert får du välja.
    </div>

    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:12px">
      <label class="btn" style="cursor:pointer">Ladda upp deltävlingar
        <input id="seriesHubFiles" type="file" accept="application/json,.json" multiple hidden onchange="handleSeriesHubFiles(this.files); this.value='';" />
      </label>
      <button class="btn secondary" onclick="clearSeriesHub()">Rensa hubb</button>
      <button class="btn secondary" onclick="exportSeriesHubState()">Exportera serie (JSON)</button>
      <label class="btn secondary" style="cursor:pointer">Importera serie
        <input type="file" accept="application/json,.json" hidden onchange="importSeriesHubState(this.files[0]); this.value='';" />
      </label>
    </div>

    <div id="seriesHubEvents" style="margin-top:14px"></div>

    <div id="seriesHubResolve" style="margin-top:14px"></div>

    <div id="seriesHubTable" style="margin-top:14px"></div>
  </div>
</section>

<!-- Player detail (Serie-hubb) -->
<div class="overlay hidden" id="seriesHubPlayerOverlay" onclick="this.classList.add('hidden')">
  <div class="modal" onclick="stopPropagation(event)">
    <div class="row" style="justify-content:space-between;align-items:center;gap:10px">
      <h3 style="margin:0" id="seriesHubPlayerTitle">Spelare</h3>
      <button class="btn secondary" type="button" onclick="document.getElementById('seriesHubPlayerOverlay').classList.add('hidden')">Stäng</button>
    </div>
    <div id="seriesHubPlayerBody" style="margin-top:10px"></div>
  </div>
</div>

<script>
// ===== Serie-hubb (sammanställ flera deltävlingar) =====
(function(){
  var HUB_KEY = 'dart_series_hub_v1';
  var hub = null;
  var _hubPrevScrollY = 0;

  function _canonName(n){
    return String(n||'').trim().toLowerCase().replace(/\s+/g,' ');
  }

  function loadHub(){
    if(hub) return hub;
    try{ hub = JSON.parse(localStorage.getItem(HUB_KEY)||'null'); }catch(e){ hub = null; }
    if(!hub || typeof hub!=='object') hub = { version:1, roster:[], events:[], mappings:{}, createdAt:new Date().toISOString(), updatedAt:new Date().toISOString() };
    if(!hub.roster) hub.roster=[];
    if(!hub.events) hub.events=[];
    if(!hub.mappings) hub.mappings={};
    return hub;
  }

  function saveHub(){
    try{ var h=loadHub(); h.updatedAt=new Date().toISOString(); localStorage.setItem(HUB_KEY, JSON.stringify(h)); }catch(e){}
  }

  function showHub(){
    var el = document.getElementById('seriesHubScreen');
    if(!el) return;
    // Visa Serie-hubb som en egen "sida": dölj appens main-innehåll
    try{
      _hubPrevScrollY = (window.scrollY || window.pageYOffset || 0);
      var main = document.getElementById('appMain');
      if(main) main.style.display = 'none';
      // Markera skärm (för ev. CSS/logik)
      try{ document.body.dataset.screen = 'seriesHubScreen'; }catch(e){}
    }catch(e){}
    el.style.display = 'block';
    el.classList.add('active');
    el.setAttribute('aria-hidden','false');
    renderHub();
    try{ window.scrollTo(0,0); }catch(e){}
  }

  function hideHub(){
    var el = document.getElementById('seriesHubScreen');
    if(!el) return;
    el.classList.remove('active');
    el.setAttribute('aria-hidden','true');
    el.style.display = 'none';
    // Återgå till appens main-innehåll
    try{
      var main = document.getElementById('appMain');
      if(main) main.style.display = '';
      // Nollställ skärmflagga (låt resten av appen styra detta)
      try{ if(document.body && document.body.dataset) delete document.body.dataset.screen; }catch(e){}
      try{ window.scrollTo(0, _hubPrevScrollY || 0); }catch(e){}
    }catch(e){}
  }

  function upsertRoster(name){
    var h = loadHub();
    var canon = _canonName(name);
    var existing = h.roster.find(function(r){ return r && r.canon===canon; });
    if(existing) return existing.id;
    var id = (typeof cryptoId==='function') ? cryptoId() : ('sp_'+Math.random().toString(16).slice(2));
    h.roster.push({ id:id, name:String(name||''), canon:canon, aliases:[String(name||'')] });
    return id;
  }

  function addAlias(rosterId, name){
    var h=loadHub();
    var r = h.roster.find(function(x){ return x && x.id===rosterId; });
    if(!r) return;
    var nm = String(name||'');
    if(!r.aliases) r.aliases=[];
    if(r.aliases.indexOf(nm)===-1) r.aliases.push(nm);
  }

  function eventKey(ev){
    return String(ev.tournamentId || ev.id || ev.name || ev.fileName || 'event');
  }

  function extractEventPlayers(data){
    // Stöd både spelare och lag
    var arr = [];
    try{
      if(Array.isArray(data.players) && data.players.length) arr = data.players;
      else if(Array.isArray(data.teams) && data.teams.length) arr = data.teams;
    }catch(e){}
    return arr.map(function(p){
      if(!p) return null;
      var name = p.name || p.title || p.label || '';
      return { id: p.id || null, name: String(name||'') };
    }).filter(function(x){ return x && x.name; });
  }

  function extractAllMatches(data){
    var out = [];
    try{ if(Array.isArray(data.matches)) out = out.concat(data.matches); }catch(e){}
    try{ if(data.playoffs && Array.isArray(data.playoffs.matches)) out = out.concat(data.playoffs.matches); }catch(e){}
    return out;
  }

  function mapPlayersForEvent(ev){
    var h = loadHub();
    var players = extractEventPlayers(ev.data||{});
    var key = eventKey(ev);

    // detect duplicates within event (same canonical)
    var seen = {};
    players.forEach(function(p){
      var c = _canonName(p.name);
      seen[c] = (seen[c]||0)+1;
    });

    players.forEach(function(p){
      var nm = p.name;
      var canon = _canonName(nm);
      var mapKey = key + '|' + nm;
      if(h.mappings[mapKey]) return; // already resolved

      // if duplicate canon within same event -> leave unresolved
      if(seen[canon] && seen[canon] > 1){
        return;
      }

      // try match roster by canon
      var r = h.roster.find(function(x){ return x && x.canon===canon; });
      if(r){
        h.mappings[mapKey] = r.id;
        addAlias(r.id, nm);
      }else{
        // create new roster entry
        var rid = upsertRoster(nm);
        h.mappings[mapKey] = rid;
      }
    });
  }

  function upsertEvent(ev){
    var h=loadHub();
    var key = eventKey(ev);
    var idx = h.events.findIndex(function(x){ return eventKey(x)===key; });
    if(idx>=0) h.events[idx]=ev;
    else h.events.push(ev);
  }

  function handleFiles(fileList){
    var files = Array.prototype.slice.call(fileList||[]);
    if(!files.length) return;
    var pending = files.length;
    files.forEach(function(f){
      var fr = new FileReader();
      fr.onload = function(){
        try{
          var data = JSON.parse(String(fr.result||'{}'));
          var ev = {
            tournamentId: data.tournamentId || (data.meta && data.meta.tournamentId) || null,
            name: (data.meta && (data.meta.title||data.meta.name)) || data.title || data.name || f.name,
            fileName: f.name,
            uploadedAt: new Date().toISOString(),
            data: data
          };
          if(!ev.tournamentId){
            // fallback stable-ish id based on fileName
            ev.tournamentId = 'file:' + f.name;
          }
          upsertEvent(ev);
          mapPlayersForEvent(ev);
          saveHub();
        }catch(e){
          alert('Kunde inte läsa filen '+f.name+' (ogiltig JSON).');
        }finally{
          pending -= 1;
          if(pending<=0){
            renderHub();
          }
        }
      };
      fr.onerror = function(){
        pending -= 1;
        if(pending<=0) renderHub();
      };
      fr.readAsText(f);
    });
  }

  function unresolvedMappings(){
    var h=loadHub();
    var unresolved = [];
    (h.events||[]).forEach(function(ev){
      var key = eventKey(ev);
      var players = extractEventPlayers(ev.data||{});
      // dup-canon in event
      var canonCount = {};
      players.forEach(function(p){ canonCount[_canonName(p.name)] = (canonCount[_canonName(p.name)]||0)+1; });

      players.forEach(function(p){
        var mk = key + '|' + p.name;
        var canon = _canonName(p.name);
        if(canonCount[canon] > 1){
          unresolved.push({ eventKey:key, eventName: ev.name, playerName:p.name, reason:'Dubblettnamn i samma deltävling' });
          return;
        }
        if(!h.mappings[mk]){
          unresolved.push({ eventKey:key, eventName: ev.name, playerName:p.name, reason:'Okänd spelare' });
        }
      });
    });
    return unresolved;
  }

  function renderResolve(unr){
    var box = document.getElementById('seriesHubResolve');
    if(!box) return;
    if(!unr.length){
      box.innerHTML = '';
      return;
    }
    var h=loadHub();
    var opts = '<option value="">Välj…</option>' + (h.roster||[]).map(function(r){
      return '<option value="'+escapeHtml(r.id)+'">'+escapeHtml(r.name)+'</option>';
    }).join('') + '<option value="__new__">+ Ny spelare</option>';

    var html = '<div class="card" style="margin:0">'
      + '<div style="font-weight:800">Matcha spelare</div>'
      + '<div class="hint" style="margin-top:4px">För att sammanställa serien behöver vi veta vilka namn som är samma person.</div>'
      + '<div style="margin-top:10px; overflow:auto">'
      + '<table class="tbl" style="min-width:700px">'
      + '<tr><th>Deltävling</th><th>Namn i filen</th><th>Orsak</th><th>Matcha mot</th></tr>';

    unr.forEach(function(u, i){
      var id = 'hubResolve_'+i;
      html += '<tr>'
        + '<td>'+escapeHtml(u.eventName||u.eventKey)+'</td>'
        + '<td><strong>'+escapeHtml(u.playerName)+'</strong></td>'
        + '<td class="muted">'+escapeHtml(u.reason)+'</td>'
        + '<td><select id="'+id+'" data-ek="'+escapeHtml(u.eventKey)+'" data-pn="'+escapeHtml(u.playerName)+'">'+opts+'</select></td>'
        + '</tr>';
    });

    html += '</table></div>'
      + '<div class="row" style="gap:8px; margin-top:10px; flex-wrap:wrap">'
      + '<button class="btn" onclick="applyResolveMappings()">Spara matchningar</button>'
      + '</div>'
      + '</div>';

    box.innerHTML = html;
  }

  function computeEventStats(ev){
    var data = ev.data||{};
    var players = extractEventPlayers(data);
    var nPlayers = players.length || 0;
    var cfg = playoffPointConfig(nPlayers);

    // 1) Slutspelspoäng: endast från playoff-matcher, kval=0.
    var poPts = {};
    try{
      var pm = (data.playoffs && Array.isArray(data.playoffs.matches)) ? data.playoffs.matches : [];
      pm.forEach(function(m){
        if(!m || !m.winnerId) return;
        var g = String(m.group||'').toUpperCase();
        var add = 0;
        if(g==='F') add = cfg.final;
        else if(g==='SF') add = cfg.semi;
        else if(g==='QF') add = cfg.qf;
        else if(g==='R16') add = cfg.r16;
        else if(g==='R32') add = cfg.r32;
        else if(g==='K' || g==='QUAL') add = cfg.qual;
        poPts[m.winnerId] = (poPts[m.winnerId]||0) + add;
      });
    }catch(e){}

    // 2) Bullseye: summeras som statistik (ger inga poäng). Hämtas från matchfält bullsA/bullsB, bakåtkompatibelt: seriesStats.*.bulls
    var bulls = {};
    try{
      var all = extractAllMatches(data);
      all.forEach(function(m){
        if(!m) return;
        var aId = m.aId, bId = m.bId;
        var aB = 0, bB = 0;
        if(typeof m.bullsA !== 'undefined' || typeof m.bullsB !== 'undefined'){
          aB = parseInt(String(m.bullsA||0),10) || 0;
          bB = parseInt(String(m.bullsB||0),10) || 0;
        }else if(m.seriesStats){
          try{ aB = parseInt(String((m.seriesStats.A||{}).bulls||0),10) || 0; }catch(e){}
          try{ bB = parseInt(String((m.seriesStats.B||{}).bulls||0),10) || 0; }catch(e){}
        }
        if(aId) bulls[aId] = (bulls[aId]||0) + aB;
        if(bId) bulls[bId] = (bulls[bId]||0) + bB;
      });
    }catch(e){}

    // 3) Legs won + average (snitt): summera över alla spelade matcher (grundspel + slutspel)
    var legsWon = {};
    var avgSum = {};
    var avgCount = {};
    try{
      var all2 = extractAllMatches(data);
      all2.forEach(function(m){
        if(!m) return;
        var aId = m.aId, bId = m.bId;
        if(!aId || !bId) return;
        // Räkna bara matcher som har ett resultat
        var winner = (m.winnerId || m.winner || '');
        if(!winner) return;
        // Försök läsa legs från olika fält (bakåtkompatibelt)
        var la = 0, lb = 0;
        // Nyare format: explicita legsA/legsB
        if(typeof m.legsA !== 'undefined' || typeof m.legsB !== 'undefined'){
          la = parseInt(String(m.legsA||0),10); if(isNaN(la)) la = 0;
          lb = parseInt(String(m.legsB||0),10); if(isNaN(lb)) lb = 0;
        }else if(typeof m.result === 'string'){
          // Äldre format: result som t.ex. "2-1" (vinnarens legs först)
          var mm = String(m.result||'').match(/(\d+)\s*[-:]\s*(\d+)/);
          if(mm){
            var w = parseInt(mm[1],10)||0;
            var l = parseInt(mm[2],10)||0;
            if(String(winner) === String(aId)) { la = w; lb = l; }
            else if(String(winner) === String(bId)) { la = l; lb = w; }
          }
        }
        legsWon[aId] = (legsWon[aId]||0) + la;
        legsWon[bId] = (legsWon[bId]||0) + lb;

        var aAvg = parseFloat(m.avgA);
        if(m.avgA!=='' && !isNaN(aAvg)){ avgSum[aId] = (avgSum[aId]||0) + aAvg; avgCount[aId] = (avgCount[aId]||0) + 1; }
        var bAvg = parseFloat(m.avgB);
        if(m.avgB!=='' && !isNaN(bAvg)){ avgSum[bId] = (avgSum[bId]||0) + bAvg; avgCount[bId] = (avgCount[bId]||0) + 1; }
      });
    }catch(e){}

    return { playoffPts: poPts, bulls: bulls, legsWon: legsWon, avgSum: avgSum, avgCount: avgCount, cfg: cfg };
  }

  function getSeriesDropCount(n){
  n = parseInt(n||0,10)||0;
  if(n>=7) return 2;
  if(n>=4) return 1;
  return 0;
}

function seriesDropRuleText(){
  try{
    var h=loadHub();
    var n=(h.events||[]).length;
    var d=getSeriesDropCount(n);
    if(!d) return 'Drop-regel: inga resultat räknas bort (korta serier).';
    var kept = Math.max(0, n-d);
    return 'Drop-regel: '+d+' sämsta deltävling'+(d>1?'ar':'')+' räknas bort ('+kept+' räknas).';
  }catch(e){ return ''; }
}

function computeSeriesTable(){
    var h=loadHub();
    var totals = {}; // rosterId -> stats

    (h.events||[]).forEach(function(ev){
      var key = eventKey(ev);
      var data = ev.data||{};
      var players = extractEventPlayers(data);
      var stats = computeEventStats(ev);

      // map participant ids to roster ids via mappings by NAME
      players.forEach(function(p){
        var mk = key + '|' + p.name;
        var rid = h.mappings[mk];
        if(!rid) return;
        if(!totals[rid]) totals[rid] = { rosterId:rid, name: (h.roster.find(function(r){return r.id===rid;})||{}).name || p.name, events:0, points:0, bulls:0, legsWon:0, avgSum:0, avgCount:0, details:[] };

        var pid = p.id;
        if(pid){
          var addP = (stats.playoffPts[pid]||0);
          var addB = (stats.bulls[pid]||0);
          totals[rid].points += addP;
          totals[rid].bulls += addB;
          totals[rid].legsWon += (stats.legsWon && pid ? (stats.legsWon[pid]||0) : 0);
          totals[rid].avgSum  += (stats.avgSum && pid ? (stats.avgSum[pid]||0) : 0);
          totals[rid].avgCount += (stats.avgCount && pid ? (stats.avgCount[pid]||0) : 0);
          totals[rid].details.push({ eventKey:key, eventName:(ev.name||ev.fileName||'Deltävling'), points:addP, bulls:addB, nPlayers:(extractEventPlayers(data).length||0) });
        }
      });

      // count event participation
      var seen = {};
      players.forEach(function(p){
        var mk = key + '|' + p.name;
        var rid = h.mappings[mk];
        if(rid && !seen[rid]){ seen[rid]=1; if(!totals[rid]) totals[rid]={ rosterId:rid, name:(h.roster.find(function(r){return r.id===rid;})||{}).name || p.name, events:0, points:0, bulls:0, legsWon:0, avgSum:0, avgCount:0, details:[] }; totals[rid].events += 1; }
      });
    });

    var nEventsTotal = (h.events||[]).length;
    var dropN = getSeriesDropCount(nEventsTotal);

    var rows = Object.keys(totals).map(function(k){
      var t = totals[k] || {};
      t.totalRaw = (t.points||0);

      // bygg per-deltävling (default 0 för alla uppladdade events)
      var scoreByKey = {};
      (t.details||[]).forEach(function(d){
        if(d && d.eventKey) scoreByKey[d.eventKey] = (scoreByKey[d.eventKey]||0) + (d.points||0);
      });

      var scores = (h.events||[]).map(function(ev){
        var ek = eventKey(ev);
        return { key: ek, name: (ev.name||ev.fileName||ek), pts: (scoreByKey[ek]||0) };
      });

      // räkna bort sämsta
      var sorted = scores.slice().sort(function(a,b){
        if((a.pts||0)!==(b.pts||0)) return (a.pts||0)-(b.pts||0);
        return String(a.key||'').localeCompare(String(b.key||''));
      });
      var dropped = sorted.slice(0, dropN);
      var droppedSum = dropped.reduce(function(s,x){ return s + (x.pts||0); }, 0);
      t.dropCount = dropN;
      t.dropped = dropped;
      t.totalCounted = t.totalRaw - droppedSum;

      t.total = t.totalCounted; // för kompatibilitet i rendering
      t.avg = (t.avgCount ? (t.avgSum/t.avgCount) : 0);
      return t;
    });

    rows.sort(function(a,b){
      if((b.totalCounted||0)!==(a.totalCounted||0)) return (b.totalCounted||0)-(a.totalCounted||0);
      // Tiebreak: flest vunna legs
      if((b.legsWon||0)!==(a.legsWon||0)) return (b.legsWon||0)-(a.legsWon||0);
      // Tiebreak: högst snitt
      if((b.avg||0)!==(a.avg||0)) return (b.avg||0)-(a.avg||0);
      // Extra: bulls som statistik
      if((b.bulls||0)!==(a.bulls||0)) return (b.bulls||0)-(a.bulls||0);
      return (a.name||'').localeCompare(b.name||'');
    });

    rows.sort(function(a,b){
      if((b.total||0)!==(a.total||0)) return (b.total||0)-(a.total||0);
      // Tiebreak: flest vunna legs
      if((b.legsWon||0)!==(a.legsWon||0)) return (b.legsWon||0)-(a.legsWon||0);
      // Tiebreak: högst snitt
      if((b.avg||0)!==(a.avg||0)) return (b.avg||0)-(a.avg||0);
      // Extra: bulls som statistik
      if((b.bulls||0)!==(a.bulls||0)) return (b.bulls||0)-(a.bulls||0);
      return String(a.name).localeCompare(String(b.name));
    });

    return rows;
  }

  function openHubPlayerDetail(rosterId){
    var h=loadHub();
    var rows = computeSeriesTable();
    var r = rows.find(function(x){return x.rosterId===rosterId;});
    if(!r){ alert('Hittade inte spelaren.'); return; }

    var html = '<div class="card" style="margin:0">'
      + '<div style="font-weight:900">'+escapeHtml(r.name||'Spelare')+'</div>'
      + '<div class="hint" style="margin-top:6px">Klicka utanför för att stänga.</div>';
    try{
      var dropInfo = '';
      var raw = (r.totalRaw||0);
      var counted = (r.totalCounted||r.total||0);
      var dropN = (r.dropCount||0);
      if(dropN){
        var droppedSum = (r.dropped||[]).reduce(function(s,x){return s + (x.pts||0);}, 0);
        dropInfo = '<div class="small muted" style="margin-top:8px">'
          + '<strong>Poäng (räknat):</strong> '+escapeHtml(String(counted))
          + ' &nbsp; <span class="muted">•</span> &nbsp; <strong>Poäng (alla):</strong> '+escapeHtml(String(raw))
          + ' &nbsp; <span class="muted">•</span> &nbsp; <strong>Borttaget:</strong> '+escapeHtml(String(droppedSum))
          + '</div>';
      }else{
        dropInfo = '<div class="small muted" style="margin-top:8px"><strong>Poäng:</strong> '+escapeHtml(String(counted))+'</div>';
      }
      html += dropInfo;
    }catch(e){}


    html += '<div style="margin-top:10px; overflow:auto">'
      + '<table class="tbl" style="min-width:520px"><tr><th>Deltävling</th><th>Spelare</th><th>Poäng</th><th>Bulls</th></tr>';

    (r.details||[]).forEach(function(d){
      html += '<tr>'
        + '<td><strong>'+escapeHtml(d.eventName||'Deltävling')+'</strong><div class="muted small">'+escapeHtml(d.eventKey||'')+'</div></td>'
        + '<td class="muted">'+escapeHtml(String(d.nPlayers||0))+'</td>'
        + '<td>'+escapeHtml(String(d.points||0))+'</td>'
        + '<td>'+escapeHtml(String(d.bulls||0))+'</td>'
        + '</tr>';
    });
    html += '</table></div>';

    html += '</div>';
    var ov = document.getElementById('seriesHubPlayerOverlay');
    var body = document.getElementById('seriesHubPlayerBody');
    var title = document.getElementById('seriesHubPlayerTitle');
    if(!ov || !body){ alert('Detaljvy saknas i sidan.'); return; }
    if(title) title.textContent = (r.name||'Spelare');
    body.innerHTML = html;
    ov.classList.remove('hidden');
  }

function renderHub(){
    var h=loadHub();
    var evBox = document.getElementById('seriesHubEvents');
    var tblBox = document.getElementById('seriesHubTable');

    if(evBox){
      if(!h.events.length){
        evBox.innerHTML = '<div class="card" style="margin:0"><div style="font-weight:800">Inga deltävlingar uppladdade</div><div class="hint" style="margin-top:6px">Exportera en turnering som JSON och ladda upp den här.</div></div>';
      }else{
        var html = '<div class="card" style="margin:0"><div style="font-weight:800">Uppladdade deltävlingar</div>';
        html += '<div style="margin-top:10px; overflow:auto"><table class="tbl" style="min-width:700px"><tr><th>Namn</th><th>ID</th><th>Spelare</th><th>Åtgärd</th></tr>';
        h.events.forEach(function(ev){
          var ps = extractEventPlayers(ev.data||{});
          html += '<tr>'
            + '<td><strong>'+escapeHtml(ev.name||ev.fileName||'Deltävling')+'</strong><div class="muted small">'+escapeHtml(ev.fileName||'')+'</div></td>'
            + '<td class="muted">'+escapeHtml(eventKey(ev))+'</td>'
            + '<td>'+ps.length+'</td>'
            + '<td><button class="btn secondary" onclick="removeSeriesEvent(\''+escapeHtml(eventKey(ev))+'\')">Ta bort</button></td>'
            + '</tr>';
        });
        html += '</table></div></div>';
        evBox.innerHTML = html;
      }
    }

    var unr = unresolvedMappings();
    renderResolve(unr);

    if(tblBox){
      if(h.events.length && !unr.length){
        var rows = computeSeriesTable();
        if(!rows.length){
          tblBox.innerHTML = '<div class="card" style="margin:0"><div style="font-weight:800">Serietabell</div><div class="hint" style="margin-top:6px">Ingen statistik att visa ännu. Har du spelat klart matcher och sparat bonusfält?</div></div>';
        }else{
          var html = '<div class="card" style="margin:0"><div style="font-weight:800">Serietabell</div>' + '<div class="small muted" style="margin-top:4px">' + seriesDropRuleText() + '</div>'
          html += '<div style="margin-top:10px; overflow:auto"><table class="tbl hubCompact"><tr>'
            + '<th>#</th><th>Spelare</th><th>Δ</th><th>P (räknat)</th><th>LW</th><th>Snitt</th><th>B</th></tr>';
          rows.forEach(function(r, i){
            html += '<tr>'
              + '<td><strong>'+(i+1)+'</strong></td>'
              + '<td><button type="button" class="linkbtn" style="padding:0" onclick="openHubPlayerDetail(\''+r.rosterId+'\')">'+escapeHtml(r.name||'')+'</button></td>'
              + '<td>'+escapeHtml(String(r.events||0))+'</td>'
              + '<td><strong>'+escapeHtml(String(r.total||0))+'</strong></td>'
              + '<td>'+escapeHtml(String(r.legsWon||0))+'</td>'
              + '<td>'+escapeHtml((r.avg||0).toFixed(1))+'</td>'
              + '<td>'+escapeHtml(String(r.bulls||0))+'</td>'
              + '</tr>';
          });
          html += '</table></div></div>';
          tblBox.innerHTML = html;
        }
      }else{
        tblBox.innerHTML = '';
      }
    }
  }

  // Expose a small API to the global scope (used by buttons)
  window.openHubPlayerDetail = function(rosterId){ openHubPlayerDetail(String(rosterId)); }
  window.openSeriesHub = function(){ showHub(); try{ if(typeof setBottomNav==='function') setBottomNav(); }catch(e){} };
  window.closeSeriesHub = function(){ hideHub(); try{ if(typeof setBottomNav==='function') setBottomNav(); }catch(e){} };
  window.handleSeriesHubFiles = function(files){ handleFiles(files); };

  window.clearSeriesHub = function(){
    if(!confirm('Rensa alla uppladdade deltävlingar och matchningar i serie-hubben?')) return;
    hub = { version:1, roster:[], events:[], mappings:{}, createdAt:new Date().toISOString(), updatedAt:new Date().toISOString() };
    try{ localStorage.setItem(HUB_KEY, JSON.stringify(hub)); }catch(e){}
    renderHub();
  };

  window.removeSeriesEvent = function(key){
    var h=loadHub();
    h.events = (h.events||[]).filter(function(ev){ return eventKey(ev)!==String(key); });
    // keep mappings/roster (kan återanvändas)
    saveHub();
    renderHub();
  };

  window.applyResolveMappings = function(){
    var h=loadHub();
    var box = document.getElementById('seriesHubResolve');
    if(!box) return;
    var sels = box.querySelectorAll('select[id^="hubResolve_"]');
    sels.forEach(function(sel){
      var ek = sel.getAttribute('data-ek');
      var pn = sel.getAttribute('data-pn');
      var val = sel.value;
      if(!val) return;
      var mk = String(ek)+'|'+String(pn);
      if(val==='__new__'){
        var rid = upsertRoster(pn);
        h.mappings[mk] = rid;
      }else{
        h.mappings[mk] = val;
        addAlias(val, pn);
      }
    });
    saveHub();
    renderHub();
  };

  window.exportSeriesHubState = function(){
    var h=loadHub();
    var blob = new Blob([JSON.stringify(h, null, 2)], {type:'application/json'});
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'serie_hubb.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(function(){ try{ URL.revokeObjectURL(a.href); a.remove(); }catch(e){} }, 500);
  };

  window.importSeriesHubState = function(file){
    if(!file) return;
    var fr = new FileReader();
    fr.onload = function(){
      try{
        var data = JSON.parse(String(fr.result||'{}'));
        if(!data || typeof data!=='object') throw new Error('bad');
        hub = data;
        saveHub();
        renderHub();
      }catch(e){
        alert('Kunde inte importera serien (ogiltig fil).');
      }
    };
    fr.readAsText(file);
  };

  // Ensure hub exists
  loadHub();
})();
</script>



<script>
(function(){
  // Long-press on +/− next to sliders: tap = 0.1, hold accelerates (to 1.0 steps)
  function parseNudgeFromOnclick(btn){
    try{
      var oc = btn.getAttribute('onclick') || '';
      // Example: nudgeRange('avgA',-getRangeStep('avgA'))
      var m = oc.match(/nudgeRange\(\x27([^\x27]+)\x27\s*,\s*([^\)]+)\)/);
      if(!m) return null;
      var rangeId = m[1];
      var expr = m[2] || '';
      var dir = /^\s*-/.test(expr) ? -1 : 1;
      return { rangeId: rangeId, dir: dir };
    }catch(e){ return null; }
  }

  function setupHold(btn){
    if(btn.__holdSetup) return;
    btn.__holdSetup = true;

    var info = parseNudgeFromOnclick(btn);
    if(!info) return;

    var hold = { t0:0, startTimer:null, interval:null, active:false };

    function stop(){
      if(hold.startTimer){ clearTimeout(hold.startTimer); hold.startTimer = null; }
      if(hold.interval){ clearInterval(hold.interval); hold.interval = null; }
      // Delay reset so the click that follows pointerup can be suppressed
      if(hold.active){
        setTimeout(function(){ hold.active = false; }, 80);
      }
    }

    function step(){
      try{
        if(typeof window.getRangeStep !== 'function' || typeof window.nudgeRange !== 'function') return;
        var elapsed = Date.now() - hold.t0;
        var small = info.dir * window.getRangeStep(info.rangeId);
        // after ~0.7s: jump in 1.0 steps (heltal)
        var delta = (elapsed >= 700) ? (info.dir * 1.0) : small;
        window.nudgeRange(info.rangeId, delta);
      }catch(e){}
    }

    function onDown(e){
      if(e && e.button != null && e.button !== 0) return;
      hold.t0 = Date.now();
      stop();
      hold.startTimer = setTimeout(function(){
        hold.active = true;
        step();
        hold.interval = setInterval(step, 120);
      }, 350);
    }

    btn.addEventListener('pointerdown', onDown, { passive: true });
    btn.addEventListener('pointerup', stop, { passive: true });
    btn.addEventListener('pointercancel', stop, { passive: true });
    btn.addEventListener('pointerleave', stop, { passive: true });
    btn.addEventListener('blur', stop);

    // Suppress the normal click step if hold-repeat was activated
    btn.addEventListener('click', function(ev){
      if(hold.active){
        try{ ev.preventDefault(); ev.stopImmediatePropagation(); }catch(err){}
        return false;
      }
    }, true);
  }

  function init(){
    try{
      document.querySelectorAll('.sliderNudgeBtn').forEach(setupHold);
    }catch(e){}
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  }else{
    init();
  }
})();
</script>


<script id="topbarSpacingPatchJS">
(function(){
  function applyTopbarSpacing(){
    try{
      var h = document.querySelector('header');
      var m = document.querySelector('main');
      var b = document.getElementById('bottomNav');
      if(!h || !m) return;
      // Header kan fa annan hojd beroende pa font/OS och safe-area
      var hh = Math.ceil(h.getBoundingClientRect().height || 0);
      if(hh < 40) hh = 74;
      document.documentElement.style.setProperty('--topbar-h', hh + 'px');
      // Satt aven inline for att vinna over dubletter i CSS
      m.style.paddingTop = 'calc(' + hh + 'px + 14px)';

      // Bottennavigeringens hojd (for att inte dolja innehall)
      if(b){
        var bh = Math.ceil(b.getBoundingClientRect().height || 0);
        if(bh < 40) bh = 64;
        document.documentElement.style.setProperty('--bottomnav-h', bh + 'px');
        m.style.paddingBottom = 'calc(' + bh + 'px + 14px)';
      }
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', applyTopbarSpacing);
  window.addEventListener('load', applyTopbarSpacing);
  window.addEventListener('resize', applyTopbarSpacing);
  // Extra: kor igen efter en liten stund (WebView kan relayouta efter fonts)
  setTimeout(applyTopbarSpacing, 50);
  setTimeout(applyTopbarSpacing, 250);
})();
</script>

<!-- === TV-läge / turneringsvy (landscape) === -->
<section id="tvModeScreen" aria-hidden="true">
  <div class="tvTopbar">
    <div class="tvTitle">Turneringsvy</div>
    <div class="tvTopActions">
      <button class="tvBtn" type="button" onclick="tvModeRequestFullscreen()">Fullskärm</button>
      <button class="tvBtn primary" type="button" onclick="closeTVMode()">Stäng</button>
    </div>
  </div>

  <div class="tvGrid">
    <div class="tvCol">
      <div class="tvCard" style="flex:1 1 auto; min-height:0;">
        <div class="tvCardHeader">
          <div class="h">Matcher</div>
          <div class="sub" id="tvMatchesSub"></div>
        </div>
        <div class="tvScroll" id="tvMatchesScroll">
          <div class="tvMatchList" id="tvMatchesList"></div>
        </div>
      </div>
    </div>

    <div class="tvCol tvRightStack">
      <div class="tvCard" style="flex:1 1 auto; min-height:0;">
        <div class="tvCardHeader">
          <div class="h">Tabell</div>
          <div class="sub" id="tvTableSub"></div>
        </div>
        <div class="tvScroll" id="tvRightScroll">
          <div class="tvSectionTitle">Tabell</div>
          <div id="tvStandingsWrap" style="padding:8px 10px"></div>

          <div class="tvSectionTitle" style="margin-top:10px">
            Slutspelsschema <span class="muted" id="tvPlayoffsSub" style="margin-left:8px"></span>
          </div>
          <div id="tvPlayoffsWrap" style="padding:8px 10px"></div>
        </div>
      </div>
    </div>
    </div>
  </div>
</section>

<!-- Fast bottennavigering (ersätter hamburgermeny) -->
<nav id="bottomNav" class="bottomNav" aria-label="Navigation"></nav>

<script type="module" id="firebaseModule">
  // Firebase (modular SDK via CDN) — används endast för online-turneringar
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getAuth, onAuthStateChanged, signInAnonymously, signOut
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    getFirestore, doc, setDoc, getDoc, updateDoc, serverTimestamp,
    collection, query, where, getDocs, onSnapshot, arrayUnion
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const firebaseConfig = {
  "apiKey": "AIzaSyAE4zslKdFbgsjXVnWPzcc67OIbE8v1-X0",
  "authDomain": "dart-turnering.firebaseapp.com",
  "projectId": "dart-turnering",
  "storageBucket": "dart-turnering.firebasestorage.app",
  "messagingSenderId": "63007726766",
  "appId": "1:63007726766:web:e1ba313924b72b1dd0613f"
};
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Exponera minimalt till window (så resten av appen kan använda utan bundler)
  window.__fb = {
    app, auth, db,
    onAuthStateChanged, signInAnonymously, signOut,
    doc, setDoc, getDoc, updateDoc, serverTimestamp,
    collection, query, where, getDocs, onSnapshot, arrayUnion
  };
  window.__fbReady = true;
</script>

<script id="onlineFirebaseIntegration">
(function(){
  // ===== Online + Firebase: säkra hooks utan att röra offline-flödet =====
  const USERS_COL = "users";
  const TOURN_COL  = "tournaments";

  const ONLINE_META_KEY = "ONLINE_META_V1"; // lokalt cache: { uid, name, avatar, lastTournamentId? }
  const ONLINE_SESSION_KEY = "ONLINE_SESSION_V1"; // lokalt: { tournamentId, code }

  function isHttpLike(){
    return location.protocol === "http:" || location.protocol === "https:";
  }

  function toast(msg){
    try{ alert(msg); }catch(e){}
  }

  function getMeta(){
    try{ return JSON.parse(localStorage.getItem(ONLINE_META_KEY) || "null"); }catch(e){ return null; }
  }
  function setMeta(m){
    try{ localStorage.setItem(ONLINE_META_KEY, JSON.stringify(m||null)); }catch(e){}
  }

  // UI helpers (befintliga element-id:n i filen)
  function setAccountText(text){
    const el = document.getElementById("accountStatusLine");
    if(el) el.textContent = text;
  }
  function setAccountButtons(isLoggedIn){
    const btnIn = document.getElementById("btnAccountLogin");
    const btnOut = document.getElementById("btnAccountLogout");
    if(btnIn) btnIn.disabled = false;
    if(btnOut) btnOut.style.display = isLoggedIn ? "" : "none";
  }

  // Online list UI (befintliga id:n i filen)
  function setOnlineCounts(ownedN, memberN){
    const a = document.getElementById("countOnlineOwned");
    const b = document.getElementById("countOnlineMember");
    if(a) a.textContent = String(ownedN||0);
    if(b) b.textContent = String(memberN||0);
  }
  function setOnlineListHtml(ownedHtml, memberHtml){
    const owned = document.getElementById("onlineOwnedList");
    const member = document.getElementById("onlineMemberList");
    if(owned) owned.innerHTML = ownedHtml || "<em>Inga ännu.</em>";
    if(member) member.innerHTML = memberHtml || "<em>Inga ännu.</em>";
  }

  // State sync
  let onlineUnsub = null;
  let onlineTournamentId = null;
  let onlineCode = null;
  let suppressUpload = false;
  let uploadTimer = null;
  let lastRemoteVersion = 0;

  function detachOnlineListener(){
    try{ if(typeof onlineUnsub === "function") onlineUnsub(); }catch(e){}
    onlineUnsub = null;
    onlineTournamentId = null;
    onlineCode = null;
    lastRemoteVersion = 0;
    suppressUpload = false;
  }

  function scrubStateForCloud(s){
    // Minimal scrubbing — behåll i princip allt så att online speglar offline.
    // Ta bort 100% UI/temporära flaggor om de finns.
    try{
      const copy = JSON.parse(JSON.stringify(s||{}));
      delete copy._playerRegisterOnly;
      delete copy._importedTournament;
      delete copy.__lastSavedLocal;
      // Markera online (hjälper vid debug)
      copy.__online = true;
      return copy;
    }catch(e){
      return s;
    }
  }

  async function ensureFirebase(){
    // Vänta in module-script
    if(!isHttpLike()){
      throw new Error("Online kräver att appen öppnas via http/https (inte content:// eller file://).");
    }
    const t0 = Date.now();
    while(!window.__fbReady || !window.__fb){
      if(Date.now() - t0 > 6000) throw new Error("Firebase laddades inte. Kontrollera internetanslutning eller blockerande tillägg.");
      await new Promise(r=>setTimeout(r,50));
    }
    return window.__fb;
  }

  async function ensureSignedIn(){
    const fb = await ensureFirebase();
    // Om redan inloggad: returnera user
    const auth = fb.auth;
    const user = auth.currentUser;
    if(user) return user;
    // annars sign in anon
    const cred = await fb.signInAnonymously(auth);
    return cred.user;
  }

  async function upsertUserProfile(uid, name, avatar){
    const fb = await ensureFirebase();
    const ref = fb.doc(fb.db, USERS_COL, uid);
    const payload = {
      name: String(name||"").trim() || "Spelare",
      avatar: String(avatar||"").trim() || "",
      updatedAt: fb.serverTimestamp(),
    };
    // skapa createdAt en gång
    const snap = await fb.getDoc(ref);
    if(!snap.exists()){
      payload.createdAt = fb.serverTimestamp();
    }
    await fb.setDoc(ref, payload, { merge:true });
    // cache lokalt
    const meta = getMeta() || {};
    meta.uid = uid; meta.name = payload.name; meta.avatar = payload.avatar;
    setMeta(meta);
  }

  // Render online lists från Firestore
  let listsUnsubOwned = null;
  let listsUnsubMember = null;

  function detachListListeners(){
    try{ if(typeof listsUnsubOwned === "function") listsUnsubOwned(); }catch(e){}
    try{ if(typeof listsUnsubMember === "function") listsUnsubMember(); }catch(e){}
    listsUnsubOwned = null;
    listsUnsubMember = null;
  }

  async function attachListListeners(){
    const fb = await ensureFirebase();
    const user = fb.auth.currentUser;
    if(!user) return;

    detachListListeners();

    // Owned
    const qOwned = fb.query(
      fb.collection(fb.db, TOURN_COL),
      fb.where("ownerUid", "==", user.uid)
    );
    listsUnsubOwned = fb.onSnapshot(qOwned, (snap)=>{
      const items = [];
      snap.forEach(docSnap=>{
        const d = docSnap.data() || {};
        items.push({ id: docSnap.id, ...d });
      });
      items.sort((a,b)=> (b.updatedAt?.seconds||0) - (a.updatedAt?.seconds||0));
      const html = items.length ? items.map(t=>renderOnlineRow(t,true)).join("") : "<em>Inga ännu.</em>";
      const memberCount = document.getElementById("countOnlineMember")?.textContent || "0";
      setOnlineCounts(items.length, Number(memberCount)||0);
      const curMemberHtml = document.getElementById("onlineMemberList")?.innerHTML || "<em>Inga ännu.</em>";
      setOnlineListHtml(html, curMemberHtml);
    });

    // Member (där jag deltar men inte äger)
    const qMember = fb.query(
      fb.collection(fb.db, TOURN_COL),
      fb.where("memberUids", "array-contains", user.uid)
    );
    listsUnsubMember = fb.onSnapshot(qMember, (snap)=>{
      const items = [];
      snap.forEach(docSnap=>{
        const d = docSnap.data() || {};
        if(d.ownerUid === user.uid) return;
        items.push({ id: docSnap.id, ...d });
      });
      items.sort((a,b)=> (b.updatedAt?.seconds||0) - (a.updatedAt?.seconds||0));
      const html = items.length ? items.map(t=>renderOnlineRow(t,false)).join("") : "<em>Inga ännu.</em>";
      const ownedCount = document.getElementById("countOnlineOwned")?.textContent || "0";
      setOnlineCounts(Number(ownedCount)||0, items.length);
      const curOwnedHtml = document.getElementById("onlineOwnedList")?.innerHTML || "<em>Inga ännu.</em>";
      setOnlineListHtml(curOwnedHtml, html);
    });
  }

  function renderOnlineRow(t, isOwner){
    const safeName = escapeHtml(String(t.name||"Online-turnering"));
    const safeCode = escapeHtml(String(t.code||""));
    const role = isOwner ? "Ägare" : "Deltar";
    const tid = escapeHtml(String(t.id||""));
    return `
      <div class="miniRow">
        <div class="miniLeft">
          <div class="miniTitle"><span aria-hidden="true">🌍</span> ${safeName}</div>
          <div class="miniMeta">Kod: <strong>${safeCode}</strong> • ${role}</div>
        </div>
        <div class="miniRight">
          <button class="btn small secondary" type="button" onclick="window.__onlineOpenFirebase('${tid}')">Öppna</button>
        </div>
      </div>
    `;
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }

  // ===== Hook: spara state -> push till Firestore om online =====
  const originalSaveState = window.saveState;
  window.saveState = function(){
    const r = (typeof originalSaveState === "function") ? originalSaveState() : undefined;
    try{ window.__lastSavedLocal = Date.now(); }catch(e){}
    scheduleUploadIfOnline();
    return r;
  };

  function scheduleUploadIfOnline(){
    if(!onlineTournamentId) return;
    if(suppressUpload) return;
    if(uploadTimer) clearTimeout(uploadTimer);
    uploadTimer = setTimeout(()=>{ uploadTimer=null; uploadOnlineState(); }, 650);
  }

  async function uploadOnlineState(){
    if(!onlineTournamentId) return;
    if(suppressUpload) return;
    const fb = await ensureFirebase();
    const user = fb.auth.currentUser;
    if(!user) return;

    try{
      const ref = fb.doc(fb.db, TOURN_COL, onlineTournamentId);
      const localState = scrubStateForCloud(window.state);
      const nextVersion = Number(lastRemoteVersion||0) + 1;
      await fb.updateDoc(ref, {
        state: localState,
        updatedAt: fb.serverTimestamp(),
        version: nextVersion
      });
      // OBS: version uppdateras också via snapshot, men vi bump:ar lokalt för snabbhet
      lastRemoteVersion = nextVersion;
    }catch(e){
      console.warn("uploadOnlineState failed", e);
    }
  }

  async function attachTournamentListener(tournamentId){
    const fb = await ensureFirebase();
    const ref = fb.doc(fb.db, TOURN_COL, tournamentId);

    detachOnlineListener();
    onlineTournamentId = tournamentId;

    // cache session
    try{
      const sess = { tournamentId };
      localStorage.setItem(ONLINE_SESSION_KEY, JSON.stringify(sess));
    }catch(e){}

    onlineUnsub = fb.onSnapshot(ref, (snap)=>{
      if(!snap.exists()) return;
      const d = snap.data() || {};
      const remoteVersion = Number(d.version||0);

      // Första snapshoten: bara sätt version + code
      if(remoteVersion && remoteVersion > lastRemoteVersion){
        lastRemoteVersion = remoteVersion;
      }

      // Om vi har remote state: applicera när den är nyare än vår senaste remote
      if(d.state){
        // Undvik att vi direkt laddar upp igen efter apply
        suppressUpload = true;
        try{
          window.state = d.state;
          // markera online-meta i state (för UI/diagnostik)
          try{
            window.state.__online = true;
            window.state.__onlineTournamentId = tournamentId;
            window.state.__onlineCode = String(d.code||"");
          }catch(e){}
          if(typeof window.renderAll === "function") window.renderAll();
        }finally{
          setTimeout(()=>{ suppressUpload = false; }, 50);
        }
      }
    });
  }

  // ===== Public API (ersätter stubbar) =====
  window.loginAccount = async function(){
    try{
      const fb = await ensureFirebase();
      const user = await ensureSignedIn();
      // fråga namn
      const meta = getMeta() || {};
      let name = meta.name || "";
      if(!name){
        name = (prompt("Välj ett namn (visas i online-turneringar):", "") || "").trim();
      }else{
        // möjlighet att ändra ibland
        const maybe = (prompt("Ditt namn:", name) || "").trim();
        if(maybe) name = maybe;
      }
      const avatar = (meta.avatar || (prompt("Avatar (valfritt, t.ex. 🙂):", meta.avatar||"") || "")).trim();
      await upsertUserProfile(user.uid, name, avatar);

      setAccountText("Inloggad.");
      setAccountButtons(true);
      try{ await attachListListeners(); }catch(e){}
      toast("Inloggad (enkelt konto utan e-post).");
    }catch(e){
      console.warn(e);
      toast(String(e.message||e));
    }
  };

  window.logoutAccount = async function(){
    try{
      const fb = await ensureFirebase();
      if(!fb.auth.currentUser){
        setMeta(null);
        setAccountText("Inte inloggad.");
        setAccountButtons(false);
        return;
      }
      if(!confirm("Logga ut?")) return;
      await fb.signOut(fb.auth);
      setMeta(null);
      detachListListeners();
      detachOnlineListener();
      setAccountText("Inte inloggad.");
      setAccountButtons(false);
      toast("Utloggad.");
    }catch(e){
      console.warn(e);
      toast(String(e.message||e));
    }
  };

  
// Skapa online-turnering: starta exakt samma flöde som lokal — men vänta med Firestore tills användaren trycker "Skapa turnering"
window.createOnlineTournamentFromUI = async function(){
  try{
    // Kräver http/https (inte content:// eller file://)
    if(!/^https?:/i.test(String(location.protocol||""))){
      alert("Online kräver att appen öppnas via http/https (inte content:// eller file://).");
      return;
    }

    await ensureSignedIn();
    // Markera att NÄSTA createTournament() ska publicera i Firestore
    window.__pendingOnlinePublish = true;

    // Starta befintligt offline-flöde (alla val och spelar-UI är samma)
    if(typeof window.newTournament === "function"){
      window.newTournament();
    }else{
      toast("Kunde inte starta ny turnering.");
    }

    toast("Skapa turneringen som vanligt. När du trycker "Skapa turnering" får du en kod att dela.");
  }catch(e){
    console.warn(e);
    toast(String(e.message||e));
  }
};

// Hooka createTournament(): när en online-turnering är "pending" publicerar vi state till Firestore och startar livesync.
(function(){
  const _origCreateTournament = window.createTournament;
  if(typeof _origCreateTournament !== "function") return;

  window.createTournament = function(){
    // Kör originalet (skapar turneringen lokalt som vanligt)
    const ret = _origCreateTournament.apply(this, arguments);

    // Om detta var en online-creation: publicera efter att state är uppdaterat av originalet
    if(window.__pendingOnlinePublish){
      window.__pendingOnlinePublish = false;

      // Kör async efter callstack så att state hinner bli klar
      setTimeout(async ()=>{
        try{
          const fb = await ensureFirebase();
          const user = fb.auth.currentUser;
          if(!user){ await ensureSignedIn(); }

          // Om den redan är online: gör inget
          if(window.state && window.state.__onlineTournamentId){
            await attachTournamentListener(window.state.__onlineTournamentId);
            await attachListListeners();
            return;
          }

          // Generera kod och säkerställ unikhet
          let code = (typeof window.genCode === "function") ? window.genCode() : Math.random().toString(36).toUpperCase().slice(2,8);
          code = String(code).toUpperCase();

          for(let i=0;i<10;i++){
            const q = fb.query(fb.collection(fb.db, TOURN_COL), fb.where("code","==",code));
            const res = await fb.getDocs(q);
            if(res.empty) break;
            code = (typeof window.genCode === "function") ? window.genCode() : Math.random().toString(36).toUpperCase().slice(2,8);
            code = String(code).toUpperCase();
          }

          const docId = "T_" + code;
          const ref = fb.doc(fb.db, TOURN_COL, docId);

          // Markera state som online
          try{
            window.state.__online = true;
            window.state.__onlineTournamentId = docId;
            window.state.__onlineCode = code;
          }catch(e){}

          await fb.setDoc(ref, {
            code,
            name: window.state?.tournamentName || "Online-turnering",
            ownerUid: fb.auth.currentUser.uid,
            memberUids: [fb.auth.currentUser.uid],
            createdAt: fb.serverTimestamp(),
            updatedAt: fb.serverTimestamp(),
            version: 1,
            state: scrubStateForCloud(window.state)
          }, { merge: true });

          toast("Online-turnering skapad! Kod: " + code);
          alert("Online-turnering skapad!

Kod: " + code + "

Dela koden med andra så kan de ansluta via "Anslut med kod".");

          await attachTournamentListener(docId);
          await attachListListeners();
        }catch(e){
          console.warn(e);
          toast("Kunde inte skapa online-turnering: " + (e.message||e));
        }
      }, 0);
    }

    return ret;
  };
})();

  // Join med kod
  window.joinOnlineByCodeFromUI = async function(){
    try{
      await ensureSignedIn();
      const codeRaw = (document.getElementById("joinOnlineCode")?.value || "").trim().toUpperCase();
      if(!codeRaw){ toast("Skriv en kod."); return; }

      const fb = await ensureFirebase();
      const user = fb.auth.currentUser;
      if(!user){ toast("Logga in först."); return; }

      // query by code
      const q = fb.query(fb.collection(fb.db, TOURN_COL), fb.where("code","==",codeRaw));
      const res = await fb.getDocs(q);
      if(res.empty){ toast("Ingen turnering hittades."); return; }
      const docSnap = res.docs[0];
      const tid = docSnap.id;

      // lägg till medlem
      await fb.updateDoc(fb.doc(fb.db, TOURN_COL, tid), {
        memberUids: fb.arrayUnion(user.uid),
        updatedAt: fb.serverTimestamp()
      });

      // ladda state + öppna
      const d = docSnap.data() || {};
      if(d.state){
        window.state = d.state;
        try{
          window.state.__online = true;
          window.state.__onlineTournamentId = tid;
          window.state.__onlineCode = codeRaw;
        }catch(e){}
        if(typeof window.renderAll === "function") window.renderAll();
      }

      if(typeof window.closeJoinOnlineOverlay === "function") window.closeJoinOnlineOverlay();
      await attachTournamentListener(tid);
      await attachListListeners();
      toast("Ansluten!");
    }catch(e){
      console.warn(e);
      toast(String(e.message||e));
    }
  };

  // Öppna online-turnering från listan
  window.__onlineOpenFirebase = async function(tournamentId){
    try{
      await ensureSignedIn();
      const fb = await ensureFirebase();
      const ref = fb.doc(fb.db, TOURN_COL, tournamentId);
      const snap = await fb.getDoc(ref);
      if(!snap.exists()){ toast("Turneringen finns inte längre."); return; }
      const d = snap.data() || {};
      if(d.state){
        window.state = d.state;
        try{
          window.state.__online = true;
          window.state.__onlineTournamentId = tournamentId;
          window.state.__onlineCode = String(d.code||"");
        }catch(e){}
        if(typeof window.renderAll === "function") window.renderAll();
      }
      await attachTournamentListener(tournamentId);
      toast("Öppnad online-turnering.");
    }catch(e){
      console.warn(e);
      toast(String(e.message||e));
    }
  };

  // Render online lists - om inte inloggad, visa instruktion
  window.renderOnlineLists = async function(){
    try{
      if(!isHttpLike()){
        setOnlineCounts(0,0);
        setOnlineListHtml("<em>Online kräver att appen öppnas via http/https.</em>", "<em>Online kräver att appen öppnas via http/https.</em>");
        return;
      }
      const fb = await ensureFirebase();
      const user = fb.auth.currentUser;
      if(!user){
        setOnlineCounts(0,0);
        setOnlineListHtml("<em>Logga in för att se dina online-turneringar.</em>", "<em>Logga in för att se dina online-turneringar.</em>");
        return;
      }
      // Snapshot-listeners sköter detta, men om de inte sitter: attach
      await attachListListeners();
    }catch(e){
      setOnlineListHtml("<em>Kunde inte ladda online-listor.</em>", "<em>Kunde inte ladda online-listor.</em>");
    }
  };

  // Bootstrap: koppla knappar om de finns
  function bind(){
    const bIn = document.getElementById("btnAccountLogin");
    const bOut = document.getElementById("btnAccountLogout");
    if(bIn && !bIn.dataset.boundFb){
      bIn.dataset.boundFb = "1";
      bIn.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); window.loginAccount(); });
    }
    if(bOut && !bOut.dataset.boundFb){
      bOut.dataset.boundFb = "1";
      bOut.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); window.logoutAccount(); });
    }
  }

  // När DOM är klar, bind + init status
  document.addEventListener("DOMContentLoaded", function(){
    bind();
    setAccountButtons(false);
    setAccountText("Inte inloggad.");
    // Render online lists (kommer visa 'logga in' tills auth finns)
    try{ window.renderOnlineLists(); }catch(e){}
  });

})();
</script>
</body>
</html>
